{"ast":null,"code":"'use strict';\n\nexports.__esModule = true; // istanbul ignore next\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nvar _visitor = require('./visitor');\n\nvar _visitor2 = _interopRequireDefault(_visitor);\n\nfunction WhitespaceControl() {\n  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n  this.options = options;\n}\n\nWhitespaceControl.prototype = new _visitor2['default']();\n\nWhitespaceControl.prototype.Program = function (program) {\n  var doStandalone = !this.options.ignoreStandalone;\n  var isRoot = !this.isRootSeen;\n  this.isRootSeen = true;\n  var body = program.body;\n\n  for (var i = 0, l = body.length; i < l; i++) {\n    var current = body[i],\n        strip = this.accept(current);\n\n    if (!strip) {\n      continue;\n    }\n\n    var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot),\n        _isNextWhitespace = isNextWhitespace(body, i, isRoot),\n        openStandalone = strip.openStandalone && _isPrevWhitespace,\n        closeStandalone = strip.closeStandalone && _isNextWhitespace,\n        inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;\n\n    if (strip.close) {\n      omitRight(body, i, true);\n    }\n\n    if (strip.open) {\n      omitLeft(body, i, true);\n    }\n\n    if (doStandalone && inlineStandalone) {\n      omitRight(body, i);\n\n      if (omitLeft(body, i)) {\n        // If we are on a standalone node, save the indent info for partials\n        if (current.type === 'PartialStatement') {\n          // Pull out the whitespace from the final line\n          current.indent = /([ \\t]+$)/.exec(body[i - 1].original)[1];\n        }\n      }\n    }\n\n    if (doStandalone && openStandalone) {\n      omitRight((current.program || current.inverse).body); // Strip out the previous content node if it's whitespace only\n\n      omitLeft(body, i);\n    }\n\n    if (doStandalone && closeStandalone) {\n      // Always strip the next node\n      omitRight(body, i);\n      omitLeft((current.inverse || current.program).body);\n    }\n  }\n\n  return program;\n};\n\nWhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function (block) {\n  this.accept(block.program);\n  this.accept(block.inverse); // Find the inverse program that is involed with whitespace stripping.\n\n  var program = block.program || block.inverse,\n      inverse = block.program && block.inverse,\n      firstInverse = inverse,\n      lastInverse = inverse;\n\n  if (inverse && inverse.chained) {\n    firstInverse = inverse.body[0].program; // Walk the inverse chain to find the last inverse that is actually in the chain.\n\n    while (lastInverse.chained) {\n      lastInverse = lastInverse.body[lastInverse.body.length - 1].program;\n    }\n  }\n\n  var strip = {\n    open: block.openStrip.open,\n    close: block.closeStrip.close,\n    // Determine the standalone candiacy. Basically flag our content as being possibly standalone\n    // so our parent can determine if we actually are standalone\n    openStandalone: isNextWhitespace(program.body),\n    closeStandalone: isPrevWhitespace((firstInverse || program).body)\n  };\n\n  if (block.openStrip.close) {\n    omitRight(program.body, null, true);\n  }\n\n  if (inverse) {\n    var inverseStrip = block.inverseStrip;\n\n    if (inverseStrip.open) {\n      omitLeft(program.body, null, true);\n    }\n\n    if (inverseStrip.close) {\n      omitRight(firstInverse.body, null, true);\n    }\n\n    if (block.closeStrip.open) {\n      omitLeft(lastInverse.body, null, true);\n    } // Find standalone else statments\n\n\n    if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {\n      omitLeft(program.body);\n      omitRight(firstInverse.body);\n    }\n  } else if (block.closeStrip.open) {\n    omitLeft(program.body, null, true);\n  }\n\n  return strip;\n};\n\nWhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function (mustache) {\n  return mustache.strip;\n};\n\nWhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function (node) {\n  /* istanbul ignore next */\n  var strip = node.strip || {};\n  return {\n    inlineStandalone: true,\n    open: strip.open,\n    close: strip.close\n  };\n};\n\nfunction isPrevWhitespace(body, i, isRoot) {\n  if (i === undefined) {\n    i = body.length;\n  } // Nodes that end with newlines are considered whitespace (but are special\n  // cased for strip operations)\n\n\n  var prev = body[i - 1],\n      sibling = body[i - 2];\n\n  if (!prev) {\n    return isRoot;\n  }\n\n  if (prev.type === 'ContentStatement') {\n    return (sibling || !isRoot ? /\\r?\\n\\s*?$/ : /(^|\\r?\\n)\\s*?$/).test(prev.original);\n  }\n}\n\nfunction isNextWhitespace(body, i, isRoot) {\n  if (i === undefined) {\n    i = -1;\n  }\n\n  var next = body[i + 1],\n      sibling = body[i + 2];\n\n  if (!next) {\n    return isRoot;\n  }\n\n  if (next.type === 'ContentStatement') {\n    return (sibling || !isRoot ? /^\\s*?\\r?\\n/ : /^\\s*?(\\r?\\n|$)/).test(next.original);\n  }\n} // Marks the node to the right of the position as omitted.\n// I.e. {{foo}}' ' will mark the ' ' node as omitted.\n//\n// If i is undefined, then the first child will be marked as such.\n//\n// If mulitple is truthy then all whitespace will be stripped out until non-whitespace\n// content is met.\n\n\nfunction omitRight(body, i, multiple) {\n  var current = body[i == null ? 0 : i + 1];\n\n  if (!current || current.type !== 'ContentStatement' || !multiple && current.rightStripped) {\n    return;\n  }\n\n  var original = current.value;\n  current.value = current.value.replace(multiple ? /^\\s+/ : /^[ \\t]*\\r?\\n?/, '');\n  current.rightStripped = current.value !== original;\n} // Marks the node to the left of the position as omitted.\n// I.e. ' '{{foo}} will mark the ' ' node as omitted.\n//\n// If i is undefined then the last child will be marked as such.\n//\n// If mulitple is truthy then all whitespace will be stripped out until non-whitespace\n// content is met.\n\n\nfunction omitLeft(body, i, multiple) {\n  var current = body[i == null ? body.length - 1 : i - 1];\n\n  if (!current || current.type !== 'ContentStatement' || !multiple && current.leftStripped) {\n    return;\n  } // We omit the last node if it's whitespace only and not preceded by a non-content node.\n\n\n  var original = current.value;\n  current.value = current.value.replace(multiple ? /\\s+$/ : /[ \\t]+$/, '');\n  current.leftStripped = current.value !== original;\n  return current.leftStripped;\n}\n\nexports['default'] = WhitespaceControl;\nmodule.exports = exports['default'];","map":{"version":3,"sources":["../../../../lib/handlebars/compiler/whitespace-control.js"],"names":[],"mappings":"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","sourcesContent":["import Visitor from './visitor';\n\nfunction WhitespaceControl(options = {}) {\n  this.options = options;\n}\nWhitespaceControl.prototype = new Visitor();\n\nWhitespaceControl.prototype.Program = function(program) {\n  const doStandalone = !this.options.ignoreStandalone;\n\n  let isRoot = !this.isRootSeen;\n  this.isRootSeen = true;\n\n  let body = program.body;\n  for (let i = 0, l = body.length; i < l; i++) {\n    let current = body[i],\n      strip = this.accept(current);\n\n    if (!strip) {\n      continue;\n    }\n\n    let _isPrevWhitespace = isPrevWhitespace(body, i, isRoot),\n      _isNextWhitespace = isNextWhitespace(body, i, isRoot),\n      openStandalone = strip.openStandalone && _isPrevWhitespace,\n      closeStandalone = strip.closeStandalone && _isNextWhitespace,\n      inlineStandalone =\n        strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;\n\n    if (strip.close) {\n      omitRight(body, i, true);\n    }\n    if (strip.open) {\n      omitLeft(body, i, true);\n    }\n\n    if (doStandalone && inlineStandalone) {\n      omitRight(body, i);\n\n      if (omitLeft(body, i)) {\n        // If we are on a standalone node, save the indent info for partials\n        if (current.type === 'PartialStatement') {\n          // Pull out the whitespace from the final line\n          current.indent = /([ \\t]+$)/.exec(body[i - 1].original)[1];\n        }\n      }\n    }\n    if (doStandalone && openStandalone) {\n      omitRight((current.program || current.inverse).body);\n\n      // Strip out the previous content node if it's whitespace only\n      omitLeft(body, i);\n    }\n    if (doStandalone && closeStandalone) {\n      // Always strip the next node\n      omitRight(body, i);\n\n      omitLeft((current.inverse || current.program).body);\n    }\n  }\n\n  return program;\n};\n\nWhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function(\n  block\n) {\n  this.accept(block.program);\n  this.accept(block.inverse);\n\n  // Find the inverse program that is involed with whitespace stripping.\n  let program = block.program || block.inverse,\n    inverse = block.program && block.inverse,\n    firstInverse = inverse,\n    lastInverse = inverse;\n\n  if (inverse && inverse.chained) {\n    firstInverse = inverse.body[0].program;\n\n    // Walk the inverse chain to find the last inverse that is actually in the chain.\n    while (lastInverse.chained) {\n      lastInverse = lastInverse.body[lastInverse.body.length - 1].program;\n    }\n  }\n\n  let strip = {\n    open: block.openStrip.open,\n    close: block.closeStrip.close,\n\n    // Determine the standalone candiacy. Basically flag our content as being possibly standalone\n    // so our parent can determine if we actually are standalone\n    openStandalone: isNextWhitespace(program.body),\n    closeStandalone: isPrevWhitespace((firstInverse || program).body)\n  };\n\n  if (block.openStrip.close) {\n    omitRight(program.body, null, true);\n  }\n\n  if (inverse) {\n    let inverseStrip = block.inverseStrip;\n\n    if (inverseStrip.open) {\n      omitLeft(program.body, null, true);\n    }\n\n    if (inverseStrip.close) {\n      omitRight(firstInverse.body, null, true);\n    }\n    if (block.closeStrip.open) {\n      omitLeft(lastInverse.body, null, true);\n    }\n\n    // Find standalone else statments\n    if (\n      !this.options.ignoreStandalone &&\n      isPrevWhitespace(program.body) &&\n      isNextWhitespace(firstInverse.body)\n    ) {\n      omitLeft(program.body);\n      omitRight(firstInverse.body);\n    }\n  } else if (block.closeStrip.open) {\n    omitLeft(program.body, null, true);\n  }\n\n  return strip;\n};\n\nWhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function(\n  mustache\n) {\n  return mustache.strip;\n};\n\nWhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function(\n  node\n) {\n  /* istanbul ignore next */\n  let strip = node.strip || {};\n  return {\n    inlineStandalone: true,\n    open: strip.open,\n    close: strip.close\n  };\n};\n\nfunction isPrevWhitespace(body, i, isRoot) {\n  if (i === undefined) {\n    i = body.length;\n  }\n\n  // Nodes that end with newlines are considered whitespace (but are special\n  // cased for strip operations)\n  let prev = body[i - 1],\n    sibling = body[i - 2];\n  if (!prev) {\n    return isRoot;\n  }\n\n  if (prev.type === 'ContentStatement') {\n    return (sibling || !isRoot ? /\\r?\\n\\s*?$/ : /(^|\\r?\\n)\\s*?$/).test(\n      prev.original\n    );\n  }\n}\nfunction isNextWhitespace(body, i, isRoot) {\n  if (i === undefined) {\n    i = -1;\n  }\n\n  let next = body[i + 1],\n    sibling = body[i + 2];\n  if (!next) {\n    return isRoot;\n  }\n\n  if (next.type === 'ContentStatement') {\n    return (sibling || !isRoot ? /^\\s*?\\r?\\n/ : /^\\s*?(\\r?\\n|$)/).test(\n      next.original\n    );\n  }\n}\n\n// Marks the node to the right of the position as omitted.\n// I.e. {{foo}}' ' will mark the ' ' node as omitted.\n//\n// If i is undefined, then the first child will be marked as such.\n//\n// If mulitple is truthy then all whitespace will be stripped out until non-whitespace\n// content is met.\nfunction omitRight(body, i, multiple) {\n  let current = body[i == null ? 0 : i + 1];\n  if (\n    !current ||\n    current.type !== 'ContentStatement' ||\n    (!multiple && current.rightStripped)\n  ) {\n    return;\n  }\n\n  let original = current.value;\n  current.value = current.value.replace(\n    multiple ? /^\\s+/ : /^[ \\t]*\\r?\\n?/,\n    ''\n  );\n  current.rightStripped = current.value !== original;\n}\n\n// Marks the node to the left of the position as omitted.\n// I.e. ' '{{foo}} will mark the ' ' node as omitted.\n//\n// If i is undefined then the last child will be marked as such.\n//\n// If mulitple is truthy then all whitespace will be stripped out until non-whitespace\n// content is met.\nfunction omitLeft(body, i, multiple) {\n  let current = body[i == null ? body.length - 1 : i - 1];\n  if (\n    !current ||\n    current.type !== 'ContentStatement' ||\n    (!multiple && current.leftStripped)\n  ) {\n    return;\n  }\n\n  // We omit the last node if it's whitespace only and not preceded by a non-content node.\n  let original = current.value;\n  current.value = current.value.replace(multiple ? /\\s+$/ : /[ \\t]+$/, '');\n  current.leftStripped = current.value !== original;\n  return current.leftStripped;\n}\n\nexport default WhitespaceControl;\n"]},"metadata":{},"sourceType":"script"}