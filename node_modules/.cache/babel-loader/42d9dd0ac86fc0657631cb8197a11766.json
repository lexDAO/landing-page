{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethUtil = require(\"ethereumjs-util\");\n\nvar ethers = require(\"ethers\");\n\nvar configured_bignumber_1 = require(\"./configured_bignumber\");\n\nexports.signTypedDataUtils = {\n  /**\n   * Generates the EIP712 Typed Data hash for signing\n   * @param   typedData An object that conforms to the EIP712TypedData interface\n   * @return  A Buffer containing the hash of the typed data.\n   */\n  generateTypedDataHash: function (typedData) {\n    return ethUtil.sha3(Buffer.concat([Buffer.from('1901', 'hex'), exports.signTypedDataUtils._structHash('EIP712Domain', typedData.domain, typedData.types), exports.signTypedDataUtils._structHash(typedData.primaryType, typedData.message, typedData.types)]));\n  },\n  _findDependencies: function (primaryType, types, found) {\n    if (found === void 0) {\n      found = [];\n    }\n\n    var e_1, _a, e_2, _b;\n\n    if (found.includes(primaryType) || types[primaryType] === undefined) {\n      return found;\n    }\n\n    found.push(primaryType);\n\n    try {\n      for (var _c = __values(types[primaryType]), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var field = _d.value;\n\n        try {\n          for (var _e = __values(exports.signTypedDataUtils._findDependencies(field.type, types, found)), _f = _e.next(); !_f.done; _f = _e.next()) {\n            var dep = _f.value;\n\n            if (!found.includes(dep)) {\n              found.push(dep);\n            }\n          }\n        } catch (e_2_1) {\n          e_2 = {\n            error: e_2_1\n          };\n        } finally {\n          try {\n            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n          } finally {\n            if (e_2) throw e_2.error;\n          }\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return found;\n  },\n  _encodeType: function (primaryType, types) {\n    var e_3, _a;\n\n    var deps = exports.signTypedDataUtils._findDependencies(primaryType, types);\n\n    deps = deps.filter(function (d) {\n      return d !== primaryType;\n    });\n    deps = [primaryType].concat(deps.sort());\n    var result = '';\n\n    try {\n      for (var deps_1 = __values(deps), deps_1_1 = deps_1.next(); !deps_1_1.done; deps_1_1 = deps_1.next()) {\n        var dep = deps_1_1.value;\n        result += dep + \"(\" + types[dep].map(function (_a) {\n          var name = _a.name,\n              type = _a.type;\n          return type + \" \" + name;\n        }).join(',') + \")\";\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (deps_1_1 && !deps_1_1.done && (_a = deps_1.return)) _a.call(deps_1);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n\n    return result;\n  },\n  _encodeData: function (primaryType, data, types) {\n    var e_4, _a;\n\n    var encodedTypes = ['bytes32'];\n    var encodedValues = [exports.signTypedDataUtils._typeHash(primaryType, types)];\n\n    try {\n      for (var _b = __values(types[primaryType]), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var field = _c.value;\n        var value = data[field.name];\n\n        if (field.type === 'string' || field.type === 'bytes') {\n          var hashValue = ethUtil.sha3(value);\n          encodedTypes.push('bytes32');\n          encodedValues.push(hashValue);\n        } else if (types[field.type] !== undefined) {\n          encodedTypes.push('bytes32');\n          var hashValue = ethUtil.sha3( // tslint:disable-next-line:no-unnecessary-type-assertion\n          exports.signTypedDataUtils._encodeData(field.type, value, types));\n          encodedValues.push(hashValue);\n        } else if (field.type.lastIndexOf(']') === field.type.length - 1) {\n          throw new Error('Arrays currently unimplemented in encodeData');\n        } else {\n          encodedTypes.push(field.type);\n\n          var normalizedValue = exports.signTypedDataUtils._normalizeValue(field.type, value);\n\n          encodedValues.push(normalizedValue);\n        }\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    }\n\n    return ethers.utils.defaultAbiCoder.encode(encodedTypes, encodedValues);\n  },\n  _normalizeValue: function (type, value) {\n    var normalizedValue = type === 'uint256' && configured_bignumber_1.BigNumber.isBigNumber(value) ? value.toString() : value;\n    return normalizedValue;\n  },\n  _typeHash: function (primaryType, types) {\n    return ethUtil.sha3(exports.signTypedDataUtils._encodeType(primaryType, types));\n  },\n  _structHash: function (primaryType, data, types) {\n    return ethUtil.sha3(exports.signTypedDataUtils._encodeData(primaryType, data, types));\n  }\n};","map":{"version":3,"sources":["../../src/sign_typed_data_utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ethUtil = require(\"ethereumjs-util\");\nvar ethers = require(\"ethers\");\nvar configured_bignumber_1 = require(\"./configured_bignumber\");\nexports.signTypedDataUtils = {\n    /**\n     * Generates the EIP712 Typed Data hash for signing\n     * @param   typedData An object that conforms to the EIP712TypedData interface\n     * @return  A Buffer containing the hash of the typed data.\n     */\n    generateTypedDataHash: function (typedData) {\n        return ethUtil.sha3(Buffer.concat([\n            Buffer.from('1901', 'hex'),\n            exports.signTypedDataUtils._structHash('EIP712Domain', typedData.domain, typedData.types),\n            exports.signTypedDataUtils._structHash(typedData.primaryType, typedData.message, typedData.types),\n        ]));\n    },\n    _findDependencies: function (primaryType, types, found) {\n        if (found === void 0) { found = []; }\n        var e_1, _a, e_2, _b;\n        if (found.includes(primaryType) || types[primaryType] === undefined) {\n            return found;\n        }\n        found.push(primaryType);\n        try {\n            for (var _c = __values(types[primaryType]), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var field = _d.value;\n                try {\n                    for (var _e = __values(exports.signTypedDataUtils._findDependencies(field.type, types, found)), _f = _e.next(); !_f.done; _f = _e.next()) {\n                        var dep = _f.value;\n                        if (!found.includes(dep)) {\n                            found.push(dep);\n                        }\n                    }\n                }\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                finally {\n                    try {\n                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n                    }\n                    finally { if (e_2) throw e_2.error; }\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return found;\n    },\n    _encodeType: function (primaryType, types) {\n        var e_3, _a;\n        var deps = exports.signTypedDataUtils._findDependencies(primaryType, types);\n        deps = deps.filter(function (d) { return d !== primaryType; });\n        deps = [primaryType].concat(deps.sort());\n        var result = '';\n        try {\n            for (var deps_1 = __values(deps), deps_1_1 = deps_1.next(); !deps_1_1.done; deps_1_1 = deps_1.next()) {\n                var dep = deps_1_1.value;\n                result += dep + \"(\" + types[dep].map(function (_a) {\n                    var name = _a.name, type = _a.type;\n                    return type + \" \" + name;\n                }).join(',') + \")\";\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (deps_1_1 && !deps_1_1.done && (_a = deps_1.return)) _a.call(deps_1);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        return result;\n    },\n    _encodeData: function (primaryType, data, types) {\n        var e_4, _a;\n        var encodedTypes = ['bytes32'];\n        var encodedValues = [exports.signTypedDataUtils._typeHash(primaryType, types)];\n        try {\n            for (var _b = __values(types[primaryType]), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var field = _c.value;\n                var value = data[field.name];\n                if (field.type === 'string' || field.type === 'bytes') {\n                    var hashValue = ethUtil.sha3(value);\n                    encodedTypes.push('bytes32');\n                    encodedValues.push(hashValue);\n                }\n                else if (types[field.type] !== undefined) {\n                    encodedTypes.push('bytes32');\n                    var hashValue = ethUtil.sha3(\n                    // tslint:disable-next-line:no-unnecessary-type-assertion\n                    exports.signTypedDataUtils._encodeData(field.type, value, types));\n                    encodedValues.push(hashValue);\n                }\n                else if (field.type.lastIndexOf(']') === field.type.length - 1) {\n                    throw new Error('Arrays currently unimplemented in encodeData');\n                }\n                else {\n                    encodedTypes.push(field.type);\n                    var normalizedValue = exports.signTypedDataUtils._normalizeValue(field.type, value);\n                    encodedValues.push(normalizedValue);\n                }\n            }\n        }\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_4) throw e_4.error; }\n        }\n        return ethers.utils.defaultAbiCoder.encode(encodedTypes, encodedValues);\n    },\n    _normalizeValue: function (type, value) {\n        var normalizedValue = type === 'uint256' && configured_bignumber_1.BigNumber.isBigNumber(value) ? value.toString() : value;\n        return normalizedValue;\n    },\n    _typeHash: function (primaryType, types) {\n        return ethUtil.sha3(exports.signTypedDataUtils._encodeType(primaryType, types));\n    },\n    _structHash: function (primaryType, data, types) {\n        return ethUtil.sha3(exports.signTypedDataUtils._encodeData(primaryType, data, types));\n    },\n};\n//# sourceMappingURL=sign_typed_data_utils.js.map"]},"metadata":{},"sourceType":"script"}