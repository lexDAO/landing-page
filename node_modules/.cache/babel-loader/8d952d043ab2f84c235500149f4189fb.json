{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.SourceLocation = SourceLocation;\nexports.id = id;\nexports.stripFlags = stripFlags;\nexports.stripComment = stripComment;\nexports.preparePath = preparePath;\nexports.prepareMustache = prepareMustache;\nexports.prepareRawBlock = prepareRawBlock;\nexports.prepareBlock = prepareBlock;\nexports.prepareProgram = prepareProgram;\nexports.preparePartialBlock = preparePartialBlock; // istanbul ignore next\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nvar _exception = require('../exception');\n\nvar _exception2 = _interopRequireDefault(_exception);\n\nfunction validateClose(open, close) {\n  close = close.path ? close.path.original : close;\n\n  if (open.path.original !== close) {\n    var errorNode = {\n      loc: open.path.loc\n    };\n    throw new _exception2['default'](open.path.original + \" doesn't match \" + close, errorNode);\n  }\n}\n\nfunction SourceLocation(source, locInfo) {\n  this.source = source;\n  this.start = {\n    line: locInfo.first_line,\n    column: locInfo.first_column\n  };\n  this.end = {\n    line: locInfo.last_line,\n    column: locInfo.last_column\n  };\n}\n\nfunction id(token) {\n  if (/^\\[.*\\]$/.test(token)) {\n    return token.substring(1, token.length - 1);\n  } else {\n    return token;\n  }\n}\n\nfunction stripFlags(open, close) {\n  return {\n    open: open.charAt(2) === '~',\n    close: close.charAt(close.length - 3) === '~'\n  };\n}\n\nfunction stripComment(comment) {\n  return comment.replace(/^\\{\\{~?!-?-?/, '').replace(/-?-?~?\\}\\}$/, '');\n}\n\nfunction preparePath(data, parts, loc) {\n  loc = this.locInfo(loc);\n  var original = data ? '@' : '',\n      dig = [],\n      depth = 0;\n\n  for (var i = 0, l = parts.length; i < l; i++) {\n    var part = parts[i].part,\n        // If we have [] syntax then we do not treat path references as operators,\n    // i.e. foo.[this] resolves to approximately context.foo['this']\n    isLiteral = parts[i].original !== part;\n    original += (parts[i].separator || '') + part;\n\n    if (!isLiteral && (part === '..' || part === '.' || part === 'this')) {\n      if (dig.length > 0) {\n        throw new _exception2['default']('Invalid path: ' + original, {\n          loc: loc\n        });\n      } else if (part === '..') {\n        depth++;\n      }\n    } else {\n      dig.push(part);\n    }\n  }\n\n  return {\n    type: 'PathExpression',\n    data: data,\n    depth: depth,\n    parts: dig,\n    original: original,\n    loc: loc\n  };\n}\n\nfunction prepareMustache(path, params, hash, open, strip, locInfo) {\n  // Must use charAt to support IE pre-10\n  var escapeFlag = open.charAt(3) || open.charAt(2),\n      escaped = escapeFlag !== '{' && escapeFlag !== '&';\n  var decorator = /\\*/.test(open);\n  return {\n    type: decorator ? 'Decorator' : 'MustacheStatement',\n    path: path,\n    params: params,\n    hash: hash,\n    escaped: escaped,\n    strip: strip,\n    loc: this.locInfo(locInfo)\n  };\n}\n\nfunction prepareRawBlock(openRawBlock, contents, close, locInfo) {\n  validateClose(openRawBlock, close);\n  locInfo = this.locInfo(locInfo);\n  var program = {\n    type: 'Program',\n    body: contents,\n    strip: {},\n    loc: locInfo\n  };\n  return {\n    type: 'BlockStatement',\n    path: openRawBlock.path,\n    params: openRawBlock.params,\n    hash: openRawBlock.hash,\n    program: program,\n    openStrip: {},\n    inverseStrip: {},\n    closeStrip: {},\n    loc: locInfo\n  };\n}\n\nfunction prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {\n  if (close && close.path) {\n    validateClose(openBlock, close);\n  }\n\n  var decorator = /\\*/.test(openBlock.open);\n  program.blockParams = openBlock.blockParams;\n  var inverse = undefined,\n      inverseStrip = undefined;\n\n  if (inverseAndProgram) {\n    if (decorator) {\n      throw new _exception2['default']('Unexpected inverse block on decorator', inverseAndProgram);\n    }\n\n    if (inverseAndProgram.chain) {\n      inverseAndProgram.program.body[0].closeStrip = close.strip;\n    }\n\n    inverseStrip = inverseAndProgram.strip;\n    inverse = inverseAndProgram.program;\n  }\n\n  if (inverted) {\n    inverted = inverse;\n    inverse = program;\n    program = inverted;\n  }\n\n  return {\n    type: decorator ? 'DecoratorBlock' : 'BlockStatement',\n    path: openBlock.path,\n    params: openBlock.params,\n    hash: openBlock.hash,\n    program: program,\n    inverse: inverse,\n    openStrip: openBlock.strip,\n    inverseStrip: inverseStrip,\n    closeStrip: close && close.strip,\n    loc: this.locInfo(locInfo)\n  };\n}\n\nfunction prepareProgram(statements, loc) {\n  if (!loc && statements.length) {\n    var firstLoc = statements[0].loc,\n        lastLoc = statements[statements.length - 1].loc;\n    /* istanbul ignore else */\n\n    if (firstLoc && lastLoc) {\n      loc = {\n        source: firstLoc.source,\n        start: {\n          line: firstLoc.start.line,\n          column: firstLoc.start.column\n        },\n        end: {\n          line: lastLoc.end.line,\n          column: lastLoc.end.column\n        }\n      };\n    }\n  }\n\n  return {\n    type: 'Program',\n    body: statements,\n    strip: {},\n    loc: loc\n  };\n}\n\nfunction preparePartialBlock(open, program, close, locInfo) {\n  validateClose(open, close);\n  return {\n    type: 'PartialBlockStatement',\n    name: open.path,\n    params: open.params,\n    hash: open.hash,\n    program: program,\n    openStrip: open.strip,\n    closeStrip: close && close.strip,\n    loc: this.locInfo(locInfo)\n  };\n}","map":{"version":3,"sources":["../../../../lib/handlebars/compiler/helpers.js"],"names":[],"mappings":"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","sourcesContent":["import Exception from '../exception';\n\nfunction validateClose(open, close) {\n  close = close.path ? close.path.original : close;\n\n  if (open.path.original !== close) {\n    let errorNode = { loc: open.path.loc };\n\n    throw new Exception(\n      open.path.original + \" doesn't match \" + close,\n      errorNode\n    );\n  }\n}\n\nexport function SourceLocation(source, locInfo) {\n  this.source = source;\n  this.start = {\n    line: locInfo.first_line,\n    column: locInfo.first_column\n  };\n  this.end = {\n    line: locInfo.last_line,\n    column: locInfo.last_column\n  };\n}\n\nexport function id(token) {\n  if (/^\\[.*\\]$/.test(token)) {\n    return token.substring(1, token.length - 1);\n  } else {\n    return token;\n  }\n}\n\nexport function stripFlags(open, close) {\n  return {\n    open: open.charAt(2) === '~',\n    close: close.charAt(close.length - 3) === '~'\n  };\n}\n\nexport function stripComment(comment) {\n  return comment.replace(/^\\{\\{~?!-?-?/, '').replace(/-?-?~?\\}\\}$/, '');\n}\n\nexport function preparePath(data, parts, loc) {\n  loc = this.locInfo(loc);\n\n  let original = data ? '@' : '',\n    dig = [],\n    depth = 0;\n\n  for (let i = 0, l = parts.length; i < l; i++) {\n    let part = parts[i].part,\n      // If we have [] syntax then we do not treat path references as operators,\n      // i.e. foo.[this] resolves to approximately context.foo['this']\n      isLiteral = parts[i].original !== part;\n    original += (parts[i].separator || '') + part;\n\n    if (!isLiteral && (part === '..' || part === '.' || part === 'this')) {\n      if (dig.length > 0) {\n        throw new Exception('Invalid path: ' + original, { loc });\n      } else if (part === '..') {\n        depth++;\n      }\n    } else {\n      dig.push(part);\n    }\n  }\n\n  return {\n    type: 'PathExpression',\n    data,\n    depth,\n    parts: dig,\n    original,\n    loc\n  };\n}\n\nexport function prepareMustache(path, params, hash, open, strip, locInfo) {\n  // Must use charAt to support IE pre-10\n  let escapeFlag = open.charAt(3) || open.charAt(2),\n    escaped = escapeFlag !== '{' && escapeFlag !== '&';\n\n  let decorator = /\\*/.test(open);\n  return {\n    type: decorator ? 'Decorator' : 'MustacheStatement',\n    path,\n    params,\n    hash,\n    escaped,\n    strip,\n    loc: this.locInfo(locInfo)\n  };\n}\n\nexport function prepareRawBlock(openRawBlock, contents, close, locInfo) {\n  validateClose(openRawBlock, close);\n\n  locInfo = this.locInfo(locInfo);\n  let program = {\n    type: 'Program',\n    body: contents,\n    strip: {},\n    loc: locInfo\n  };\n\n  return {\n    type: 'BlockStatement',\n    path: openRawBlock.path,\n    params: openRawBlock.params,\n    hash: openRawBlock.hash,\n    program,\n    openStrip: {},\n    inverseStrip: {},\n    closeStrip: {},\n    loc: locInfo\n  };\n}\n\nexport function prepareBlock(\n  openBlock,\n  program,\n  inverseAndProgram,\n  close,\n  inverted,\n  locInfo\n) {\n  if (close && close.path) {\n    validateClose(openBlock, close);\n  }\n\n  let decorator = /\\*/.test(openBlock.open);\n\n  program.blockParams = openBlock.blockParams;\n\n  let inverse, inverseStrip;\n\n  if (inverseAndProgram) {\n    if (decorator) {\n      throw new Exception(\n        'Unexpected inverse block on decorator',\n        inverseAndProgram\n      );\n    }\n\n    if (inverseAndProgram.chain) {\n      inverseAndProgram.program.body[0].closeStrip = close.strip;\n    }\n\n    inverseStrip = inverseAndProgram.strip;\n    inverse = inverseAndProgram.program;\n  }\n\n  if (inverted) {\n    inverted = inverse;\n    inverse = program;\n    program = inverted;\n  }\n\n  return {\n    type: decorator ? 'DecoratorBlock' : 'BlockStatement',\n    path: openBlock.path,\n    params: openBlock.params,\n    hash: openBlock.hash,\n    program,\n    inverse,\n    openStrip: openBlock.strip,\n    inverseStrip,\n    closeStrip: close && close.strip,\n    loc: this.locInfo(locInfo)\n  };\n}\n\nexport function prepareProgram(statements, loc) {\n  if (!loc && statements.length) {\n    const firstLoc = statements[0].loc,\n      lastLoc = statements[statements.length - 1].loc;\n\n    /* istanbul ignore else */\n    if (firstLoc && lastLoc) {\n      loc = {\n        source: firstLoc.source,\n        start: {\n          line: firstLoc.start.line,\n          column: firstLoc.start.column\n        },\n        end: {\n          line: lastLoc.end.line,\n          column: lastLoc.end.column\n        }\n      };\n    }\n  }\n\n  return {\n    type: 'Program',\n    body: statements,\n    strip: {},\n    loc: loc\n  };\n}\n\nexport function preparePartialBlock(open, program, close, locInfo) {\n  validateClose(open, close);\n\n  return {\n    type: 'PartialBlockStatement',\n    name: open.path,\n    params: open.params,\n    hash: open.hash,\n    program,\n    openStrip: open.strip,\n    closeStrip: close && close.strip,\n    loc: this.locInfo(locInfo)\n  };\n}\n"]},"metadata":{},"sourceType":"script"}