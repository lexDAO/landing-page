{"ast":null,"code":"/* eslint-disable new-cap */\n'use strict';\n\nexports.__esModule = true;\nexports.Compiler = Compiler;\nexports.precompile = precompile;\nexports.compile = compile; // istanbul ignore next\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nvar _exception = require('../exception');\n\nvar _exception2 = _interopRequireDefault(_exception);\n\nvar _utils = require('../utils');\n\nvar _ast = require('./ast');\n\nvar _ast2 = _interopRequireDefault(_ast);\n\nvar slice = [].slice;\n\nfunction Compiler() {} // the foundHelper register will disambiguate helper lookup from finding a\n// function in a context. This is necessary for mustache compatibility, which\n// requires that context functions in blocks are evaluated by blockHelperMissing,\n// and then proceed as if the resulting value was provided to blockHelperMissing.\n\n\nCompiler.prototype = {\n  compiler: Compiler,\n  equals: function equals(other) {\n    var len = this.opcodes.length;\n\n    if (other.opcodes.length !== len) {\n      return false;\n    }\n\n    for (var i = 0; i < len; i++) {\n      var opcode = this.opcodes[i],\n          otherOpcode = other.opcodes[i];\n\n      if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {\n        return false;\n      }\n    } // We know that length is the same between the two arrays because they are directly tied\n    // to the opcode behavior above.\n\n\n    len = this.children.length;\n\n    for (var i = 0; i < len; i++) {\n      if (!this.children[i].equals(other.children[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n  guid: 0,\n  compile: function compile(program, options) {\n    this.sourceNode = [];\n    this.opcodes = [];\n    this.children = [];\n    this.options = options;\n    this.stringParams = options.stringParams;\n    this.trackIds = options.trackIds;\n    options.blockParams = options.blockParams || [];\n    options.knownHelpers = _utils.extend(Object.create(null), {\n      helperMissing: true,\n      blockHelperMissing: true,\n      each: true,\n      'if': true,\n      unless: true,\n      'with': true,\n      log: true,\n      lookup: true\n    }, options.knownHelpers);\n    return this.accept(program);\n  },\n  compileProgram: function compileProgram(program) {\n    var childCompiler = new this.compiler(),\n        // eslint-disable-line new-cap\n    result = childCompiler.compile(program, this.options),\n        guid = this.guid++;\n    this.usePartial = this.usePartial || result.usePartial;\n    this.children[guid] = result;\n    this.useDepths = this.useDepths || result.useDepths;\n    return guid;\n  },\n  accept: function accept(node) {\n    /* istanbul ignore next: Sanity code */\n    if (!this[node.type]) {\n      throw new _exception2['default']('Unknown type: ' + node.type, node);\n    }\n\n    this.sourceNode.unshift(node);\n    var ret = this[node.type](node);\n    this.sourceNode.shift();\n    return ret;\n  },\n  Program: function Program(program) {\n    this.options.blockParams.unshift(program.blockParams);\n    var body = program.body,\n        bodyLength = body.length;\n\n    for (var i = 0; i < bodyLength; i++) {\n      this.accept(body[i]);\n    }\n\n    this.options.blockParams.shift();\n    this.isSimple = bodyLength === 1;\n    this.blockParams = program.blockParams ? program.blockParams.length : 0;\n    return this;\n  },\n  BlockStatement: function BlockStatement(block) {\n    transformLiteralToPath(block);\n    var program = block.program,\n        inverse = block.inverse;\n    program = program && this.compileProgram(program);\n    inverse = inverse && this.compileProgram(inverse);\n    var type = this.classifySexpr(block);\n\n    if (type === 'helper') {\n      this.helperSexpr(block, program, inverse);\n    } else if (type === 'simple') {\n      this.simpleSexpr(block); // now that the simple mustache is resolved, we need to\n      // evaluate it by executing `blockHelperMissing`\n\n      this.opcode('pushProgram', program);\n      this.opcode('pushProgram', inverse);\n      this.opcode('emptyHash');\n      this.opcode('blockValue', block.path.original);\n    } else {\n      this.ambiguousSexpr(block, program, inverse); // now that the simple mustache is resolved, we need to\n      // evaluate it by executing `blockHelperMissing`\n\n      this.opcode('pushProgram', program);\n      this.opcode('pushProgram', inverse);\n      this.opcode('emptyHash');\n      this.opcode('ambiguousBlockValue');\n    }\n\n    this.opcode('append');\n  },\n  DecoratorBlock: function DecoratorBlock(decorator) {\n    var program = decorator.program && this.compileProgram(decorator.program);\n    var params = this.setupFullMustacheParams(decorator, program, undefined),\n        path = decorator.path;\n    this.useDecorators = true;\n    this.opcode('registerDecorator', params.length, path.original);\n  },\n  PartialStatement: function PartialStatement(partial) {\n    this.usePartial = true;\n    var program = partial.program;\n\n    if (program) {\n      program = this.compileProgram(partial.program);\n    }\n\n    var params = partial.params;\n\n    if (params.length > 1) {\n      throw new _exception2['default']('Unsupported number of partial arguments: ' + params.length, partial);\n    } else if (!params.length) {\n      if (this.options.explicitPartialContext) {\n        this.opcode('pushLiteral', 'undefined');\n      } else {\n        params.push({\n          type: 'PathExpression',\n          parts: [],\n          depth: 0\n        });\n      }\n    }\n\n    var partialName = partial.name.original,\n        isDynamic = partial.name.type === 'SubExpression';\n\n    if (isDynamic) {\n      this.accept(partial.name);\n    }\n\n    this.setupFullMustacheParams(partial, program, undefined, true);\n    var indent = partial.indent || '';\n\n    if (this.options.preventIndent && indent) {\n      this.opcode('appendContent', indent);\n      indent = '';\n    }\n\n    this.opcode('invokePartial', isDynamic, partialName, indent);\n    this.opcode('append');\n  },\n  PartialBlockStatement: function PartialBlockStatement(partialBlock) {\n    this.PartialStatement(partialBlock);\n  },\n  MustacheStatement: function MustacheStatement(mustache) {\n    this.SubExpression(mustache);\n\n    if (mustache.escaped && !this.options.noEscape) {\n      this.opcode('appendEscaped');\n    } else {\n      this.opcode('append');\n    }\n  },\n  Decorator: function Decorator(decorator) {\n    this.DecoratorBlock(decorator);\n  },\n  ContentStatement: function ContentStatement(content) {\n    if (content.value) {\n      this.opcode('appendContent', content.value);\n    }\n  },\n  CommentStatement: function CommentStatement() {},\n  SubExpression: function SubExpression(sexpr) {\n    transformLiteralToPath(sexpr);\n    var type = this.classifySexpr(sexpr);\n\n    if (type === 'simple') {\n      this.simpleSexpr(sexpr);\n    } else if (type === 'helper') {\n      this.helperSexpr(sexpr);\n    } else {\n      this.ambiguousSexpr(sexpr);\n    }\n  },\n  ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {\n    var path = sexpr.path,\n        name = path.parts[0],\n        isBlock = program != null || inverse != null;\n    this.opcode('getContext', path.depth);\n    this.opcode('pushProgram', program);\n    this.opcode('pushProgram', inverse);\n    path.strict = true;\n    this.accept(path);\n    this.opcode('invokeAmbiguous', name, isBlock);\n  },\n  simpleSexpr: function simpleSexpr(sexpr) {\n    var path = sexpr.path;\n    path.strict = true;\n    this.accept(path);\n    this.opcode('resolvePossibleLambda');\n  },\n  helperSexpr: function helperSexpr(sexpr, program, inverse) {\n    var params = this.setupFullMustacheParams(sexpr, program, inverse),\n        path = sexpr.path,\n        name = path.parts[0];\n\n    if (this.options.knownHelpers[name]) {\n      this.opcode('invokeKnownHelper', params.length, name);\n    } else if (this.options.knownHelpersOnly) {\n      throw new _exception2['default']('You specified knownHelpersOnly, but used the unknown helper ' + name, sexpr);\n    } else {\n      path.strict = true;\n      path.falsy = true;\n      this.accept(path);\n      this.opcode('invokeHelper', params.length, path.original, _ast2['default'].helpers.simpleId(path));\n    }\n  },\n  PathExpression: function PathExpression(path) {\n    this.addDepth(path.depth);\n    this.opcode('getContext', path.depth);\n\n    var name = path.parts[0],\n        scoped = _ast2['default'].helpers.scopedId(path),\n        blockParamId = !path.depth && !scoped && this.blockParamIndex(name);\n\n    if (blockParamId) {\n      this.opcode('lookupBlockParam', blockParamId, path.parts);\n    } else if (!name) {\n      // Context reference, i.e. `{{foo .}}` or `{{foo ..}}`\n      this.opcode('pushContext');\n    } else if (path.data) {\n      this.options.data = true;\n      this.opcode('lookupData', path.depth, path.parts, path.strict);\n    } else {\n      this.opcode('lookupOnContext', path.parts, path.falsy, path.strict, scoped);\n    }\n  },\n  StringLiteral: function StringLiteral(string) {\n    this.opcode('pushString', string.value);\n  },\n  NumberLiteral: function NumberLiteral(number) {\n    this.opcode('pushLiteral', number.value);\n  },\n  BooleanLiteral: function BooleanLiteral(bool) {\n    this.opcode('pushLiteral', bool.value);\n  },\n  UndefinedLiteral: function UndefinedLiteral() {\n    this.opcode('pushLiteral', 'undefined');\n  },\n  NullLiteral: function NullLiteral() {\n    this.opcode('pushLiteral', 'null');\n  },\n  Hash: function Hash(hash) {\n    var pairs = hash.pairs,\n        i = 0,\n        l = pairs.length;\n    this.opcode('pushHash');\n\n    for (; i < l; i++) {\n      this.pushParam(pairs[i].value);\n    }\n\n    while (i--) {\n      this.opcode('assignToHash', pairs[i].key);\n    }\n\n    this.opcode('popHash');\n  },\n  // HELPERS\n  opcode: function opcode(name) {\n    this.opcodes.push({\n      opcode: name,\n      args: slice.call(arguments, 1),\n      loc: this.sourceNode[0].loc\n    });\n  },\n  addDepth: function addDepth(depth) {\n    if (!depth) {\n      return;\n    }\n\n    this.useDepths = true;\n  },\n  classifySexpr: function classifySexpr(sexpr) {\n    var isSimple = _ast2['default'].helpers.simpleId(sexpr.path);\n\n    var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]); // a mustache is an eligible helper if:\n    // * its id is simple (a single part, not `this` or `..`)\n\n    var isHelper = !isBlockParam && _ast2['default'].helpers.helperExpression(sexpr); // if a mustache is an eligible helper but not a definite\n    // helper, it is ambiguous, and will be resolved in a later\n    // pass or at runtime.\n\n\n    var isEligible = !isBlockParam && (isHelper || isSimple); // if ambiguous, we can possibly resolve the ambiguity now\n    // An eligible helper is one that does not have a complex path, i.e. `this.foo`, `../foo` etc.\n\n    if (isEligible && !isHelper) {\n      var _name = sexpr.path.parts[0],\n          options = this.options;\n\n      if (options.knownHelpers[_name]) {\n        isHelper = true;\n      } else if (options.knownHelpersOnly) {\n        isEligible = false;\n      }\n    }\n\n    if (isHelper) {\n      return 'helper';\n    } else if (isEligible) {\n      return 'ambiguous';\n    } else {\n      return 'simple';\n    }\n  },\n  pushParams: function pushParams(params) {\n    for (var i = 0, l = params.length; i < l; i++) {\n      this.pushParam(params[i]);\n    }\n  },\n  pushParam: function pushParam(val) {\n    var value = val.value != null ? val.value : val.original || '';\n\n    if (this.stringParams) {\n      if (value.replace) {\n        value = value.replace(/^(\\.?\\.\\/)*/g, '').replace(/\\//g, '.');\n      }\n\n      if (val.depth) {\n        this.addDepth(val.depth);\n      }\n\n      this.opcode('getContext', val.depth || 0);\n      this.opcode('pushStringParam', value, val.type);\n\n      if (val.type === 'SubExpression') {\n        // SubExpressions get evaluated and passed in\n        // in string params mode.\n        this.accept(val);\n      }\n    } else {\n      if (this.trackIds) {\n        var blockParamIndex = undefined;\n\n        if (val.parts && !_ast2['default'].helpers.scopedId(val) && !val.depth) {\n          blockParamIndex = this.blockParamIndex(val.parts[0]);\n        }\n\n        if (blockParamIndex) {\n          var blockParamChild = val.parts.slice(1).join('.');\n          this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);\n        } else {\n          value = val.original || value;\n\n          if (value.replace) {\n            value = value.replace(/^this(?:\\.|$)/, '').replace(/^\\.\\//, '').replace(/^\\.$/, '');\n          }\n\n          this.opcode('pushId', val.type, value);\n        }\n      }\n\n      this.accept(val);\n    }\n  },\n  setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {\n    var params = sexpr.params;\n    this.pushParams(params);\n    this.opcode('pushProgram', program);\n    this.opcode('pushProgram', inverse);\n\n    if (sexpr.hash) {\n      this.accept(sexpr.hash);\n    } else {\n      this.opcode('emptyHash', omitEmpty);\n    }\n\n    return params;\n  },\n  blockParamIndex: function blockParamIndex(name) {\n    for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {\n      var blockParams = this.options.blockParams[depth],\n          param = blockParams && _utils.indexOf(blockParams, name);\n\n      if (blockParams && param >= 0) {\n        return [depth, param];\n      }\n    }\n  }\n};\n\nfunction precompile(input, options, env) {\n  if (input == null || typeof input !== 'string' && input.type !== 'Program') {\n    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' + input);\n  }\n\n  options = options || {};\n\n  if (!('data' in options)) {\n    options.data = true;\n  }\n\n  if (options.compat) {\n    options.useDepths = true;\n  }\n\n  var ast = env.parse(input, options),\n      environment = new env.Compiler().compile(ast, options);\n  return new env.JavaScriptCompiler().compile(environment, options);\n}\n\nfunction compile(input, options, env) {\n  if (options === undefined) options = {};\n\n  if (input == null || typeof input !== 'string' && input.type !== 'Program') {\n    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.compile. You passed ' + input);\n  }\n\n  options = _utils.extend({}, options);\n\n  if (!('data' in options)) {\n    options.data = true;\n  }\n\n  if (options.compat) {\n    options.useDepths = true;\n  }\n\n  var compiled = undefined;\n\n  function compileInput() {\n    var ast = env.parse(input, options),\n        environment = new env.Compiler().compile(ast, options),\n        templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);\n    return env.template(templateSpec);\n  } // Template is only compiled on first use and cached after that point.\n\n\n  function ret(context, execOptions) {\n    if (!compiled) {\n      compiled = compileInput();\n    }\n\n    return compiled.call(this, context, execOptions);\n  }\n\n  ret._setup = function (setupOptions) {\n    if (!compiled) {\n      compiled = compileInput();\n    }\n\n    return compiled._setup(setupOptions);\n  };\n\n  ret._child = function (i, data, blockParams, depths) {\n    if (!compiled) {\n      compiled = compileInput();\n    }\n\n    return compiled._child(i, data, blockParams, depths);\n  };\n\n  return ret;\n}\n\nfunction argEquals(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (_utils.isArray(a) && _utils.isArray(b) && a.length === b.length) {\n    for (var i = 0; i < a.length; i++) {\n      if (!argEquals(a[i], b[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\n\nfunction transformLiteralToPath(sexpr) {\n  if (!sexpr.path.parts) {\n    var literal = sexpr.path; // Casting to string here to make false and 0 literal values play nicely with the rest\n    // of the system.\n\n    sexpr.path = {\n      type: 'PathExpression',\n      data: false,\n      depth: 0,\n      parts: [literal.original + ''],\n      original: literal.original + '',\n      loc: literal.loc\n    };\n  }\n}","map":{"version":3,"sources":["../../../../lib/handlebars/compiler/compiler.js"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable new-cap */\n\nimport Exception from '../exception';\nimport { isArray, indexOf, extend } from '../utils';\nimport AST from './ast';\n\nconst slice = [].slice;\n\nexport function Compiler() {}\n\n// the foundHelper register will disambiguate helper lookup from finding a\n// function in a context. This is necessary for mustache compatibility, which\n// requires that context functions in blocks are evaluated by blockHelperMissing,\n// and then proceed as if the resulting value was provided to blockHelperMissing.\n\nCompiler.prototype = {\n  compiler: Compiler,\n\n  equals: function(other) {\n    let len = this.opcodes.length;\n    if (other.opcodes.length !== len) {\n      return false;\n    }\n\n    for (let i = 0; i < len; i++) {\n      let opcode = this.opcodes[i],\n        otherOpcode = other.opcodes[i];\n      if (\n        opcode.opcode !== otherOpcode.opcode ||\n        !argEquals(opcode.args, otherOpcode.args)\n      ) {\n        return false;\n      }\n    }\n\n    // We know that length is the same between the two arrays because they are directly tied\n    // to the opcode behavior above.\n    len = this.children.length;\n    for (let i = 0; i < len; i++) {\n      if (!this.children[i].equals(other.children[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  guid: 0,\n\n  compile: function(program, options) {\n    this.sourceNode = [];\n    this.opcodes = [];\n    this.children = [];\n    this.options = options;\n    this.stringParams = options.stringParams;\n    this.trackIds = options.trackIds;\n\n    options.blockParams = options.blockParams || [];\n\n    options.knownHelpers = extend(\n      Object.create(null),\n      {\n        helperMissing: true,\n        blockHelperMissing: true,\n        each: true,\n        if: true,\n        unless: true,\n        with: true,\n        log: true,\n        lookup: true\n      },\n      options.knownHelpers\n    );\n\n    return this.accept(program);\n  },\n\n  compileProgram: function(program) {\n    let childCompiler = new this.compiler(), // eslint-disable-line new-cap\n      result = childCompiler.compile(program, this.options),\n      guid = this.guid++;\n\n    this.usePartial = this.usePartial || result.usePartial;\n\n    this.children[guid] = result;\n    this.useDepths = this.useDepths || result.useDepths;\n\n    return guid;\n  },\n\n  accept: function(node) {\n    /* istanbul ignore next: Sanity code */\n    if (!this[node.type]) {\n      throw new Exception('Unknown type: ' + node.type, node);\n    }\n\n    this.sourceNode.unshift(node);\n    let ret = this[node.type](node);\n    this.sourceNode.shift();\n    return ret;\n  },\n\n  Program: function(program) {\n    this.options.blockParams.unshift(program.blockParams);\n\n    let body = program.body,\n      bodyLength = body.length;\n    for (let i = 0; i < bodyLength; i++) {\n      this.accept(body[i]);\n    }\n\n    this.options.blockParams.shift();\n\n    this.isSimple = bodyLength === 1;\n    this.blockParams = program.blockParams ? program.blockParams.length : 0;\n\n    return this;\n  },\n\n  BlockStatement: function(block) {\n    transformLiteralToPath(block);\n\n    let program = block.program,\n      inverse = block.inverse;\n\n    program = program && this.compileProgram(program);\n    inverse = inverse && this.compileProgram(inverse);\n\n    let type = this.classifySexpr(block);\n\n    if (type === 'helper') {\n      this.helperSexpr(block, program, inverse);\n    } else if (type === 'simple') {\n      this.simpleSexpr(block);\n\n      // now that the simple mustache is resolved, we need to\n      // evaluate it by executing `blockHelperMissing`\n      this.opcode('pushProgram', program);\n      this.opcode('pushProgram', inverse);\n      this.opcode('emptyHash');\n      this.opcode('blockValue', block.path.original);\n    } else {\n      this.ambiguousSexpr(block, program, inverse);\n\n      // now that the simple mustache is resolved, we need to\n      // evaluate it by executing `blockHelperMissing`\n      this.opcode('pushProgram', program);\n      this.opcode('pushProgram', inverse);\n      this.opcode('emptyHash');\n      this.opcode('ambiguousBlockValue');\n    }\n\n    this.opcode('append');\n  },\n\n  DecoratorBlock(decorator) {\n    let program = decorator.program && this.compileProgram(decorator.program);\n    let params = this.setupFullMustacheParams(decorator, program, undefined),\n      path = decorator.path;\n\n    this.useDecorators = true;\n    this.opcode('registerDecorator', params.length, path.original);\n  },\n\n  PartialStatement: function(partial) {\n    this.usePartial = true;\n\n    let program = partial.program;\n    if (program) {\n      program = this.compileProgram(partial.program);\n    }\n\n    let params = partial.params;\n    if (params.length > 1) {\n      throw new Exception(\n        'Unsupported number of partial arguments: ' + params.length,\n        partial\n      );\n    } else if (!params.length) {\n      if (this.options.explicitPartialContext) {\n        this.opcode('pushLiteral', 'undefined');\n      } else {\n        params.push({ type: 'PathExpression', parts: [], depth: 0 });\n      }\n    }\n\n    let partialName = partial.name.original,\n      isDynamic = partial.name.type === 'SubExpression';\n    if (isDynamic) {\n      this.accept(partial.name);\n    }\n\n    this.setupFullMustacheParams(partial, program, undefined, true);\n\n    let indent = partial.indent || '';\n    if (this.options.preventIndent && indent) {\n      this.opcode('appendContent', indent);\n      indent = '';\n    }\n\n    this.opcode('invokePartial', isDynamic, partialName, indent);\n    this.opcode('append');\n  },\n  PartialBlockStatement: function(partialBlock) {\n    this.PartialStatement(partialBlock);\n  },\n\n  MustacheStatement: function(mustache) {\n    this.SubExpression(mustache);\n\n    if (mustache.escaped && !this.options.noEscape) {\n      this.opcode('appendEscaped');\n    } else {\n      this.opcode('append');\n    }\n  },\n  Decorator(decorator) {\n    this.DecoratorBlock(decorator);\n  },\n\n  ContentStatement: function(content) {\n    if (content.value) {\n      this.opcode('appendContent', content.value);\n    }\n  },\n\n  CommentStatement: function() {},\n\n  SubExpression: function(sexpr) {\n    transformLiteralToPath(sexpr);\n    let type = this.classifySexpr(sexpr);\n\n    if (type === 'simple') {\n      this.simpleSexpr(sexpr);\n    } else if (type === 'helper') {\n      this.helperSexpr(sexpr);\n    } else {\n      this.ambiguousSexpr(sexpr);\n    }\n  },\n  ambiguousSexpr: function(sexpr, program, inverse) {\n    let path = sexpr.path,\n      name = path.parts[0],\n      isBlock = program != null || inverse != null;\n\n    this.opcode('getContext', path.depth);\n\n    this.opcode('pushProgram', program);\n    this.opcode('pushProgram', inverse);\n\n    path.strict = true;\n    this.accept(path);\n\n    this.opcode('invokeAmbiguous', name, isBlock);\n  },\n\n  simpleSexpr: function(sexpr) {\n    let path = sexpr.path;\n    path.strict = true;\n    this.accept(path);\n    this.opcode('resolvePossibleLambda');\n  },\n\n  helperSexpr: function(sexpr, program, inverse) {\n    let params = this.setupFullMustacheParams(sexpr, program, inverse),\n      path = sexpr.path,\n      name = path.parts[0];\n\n    if (this.options.knownHelpers[name]) {\n      this.opcode('invokeKnownHelper', params.length, name);\n    } else if (this.options.knownHelpersOnly) {\n      throw new Exception(\n        'You specified knownHelpersOnly, but used the unknown helper ' + name,\n        sexpr\n      );\n    } else {\n      path.strict = true;\n      path.falsy = true;\n\n      this.accept(path);\n      this.opcode(\n        'invokeHelper',\n        params.length,\n        path.original,\n        AST.helpers.simpleId(path)\n      );\n    }\n  },\n\n  PathExpression: function(path) {\n    this.addDepth(path.depth);\n    this.opcode('getContext', path.depth);\n\n    let name = path.parts[0],\n      scoped = AST.helpers.scopedId(path),\n      blockParamId = !path.depth && !scoped && this.blockParamIndex(name);\n\n    if (blockParamId) {\n      this.opcode('lookupBlockParam', blockParamId, path.parts);\n    } else if (!name) {\n      // Context reference, i.e. `{{foo .}}` or `{{foo ..}}`\n      this.opcode('pushContext');\n    } else if (path.data) {\n      this.options.data = true;\n      this.opcode('lookupData', path.depth, path.parts, path.strict);\n    } else {\n      this.opcode(\n        'lookupOnContext',\n        path.parts,\n        path.falsy,\n        path.strict,\n        scoped\n      );\n    }\n  },\n\n  StringLiteral: function(string) {\n    this.opcode('pushString', string.value);\n  },\n\n  NumberLiteral: function(number) {\n    this.opcode('pushLiteral', number.value);\n  },\n\n  BooleanLiteral: function(bool) {\n    this.opcode('pushLiteral', bool.value);\n  },\n\n  UndefinedLiteral: function() {\n    this.opcode('pushLiteral', 'undefined');\n  },\n\n  NullLiteral: function() {\n    this.opcode('pushLiteral', 'null');\n  },\n\n  Hash: function(hash) {\n    let pairs = hash.pairs,\n      i = 0,\n      l = pairs.length;\n\n    this.opcode('pushHash');\n\n    for (; i < l; i++) {\n      this.pushParam(pairs[i].value);\n    }\n    while (i--) {\n      this.opcode('assignToHash', pairs[i].key);\n    }\n    this.opcode('popHash');\n  },\n\n  // HELPERS\n  opcode: function(name) {\n    this.opcodes.push({\n      opcode: name,\n      args: slice.call(arguments, 1),\n      loc: this.sourceNode[0].loc\n    });\n  },\n\n  addDepth: function(depth) {\n    if (!depth) {\n      return;\n    }\n\n    this.useDepths = true;\n  },\n\n  classifySexpr: function(sexpr) {\n    let isSimple = AST.helpers.simpleId(sexpr.path);\n\n    let isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);\n\n    // a mustache is an eligible helper if:\n    // * its id is simple (a single part, not `this` or `..`)\n    let isHelper = !isBlockParam && AST.helpers.helperExpression(sexpr);\n\n    // if a mustache is an eligible helper but not a definite\n    // helper, it is ambiguous, and will be resolved in a later\n    // pass or at runtime.\n    let isEligible = !isBlockParam && (isHelper || isSimple);\n\n    // if ambiguous, we can possibly resolve the ambiguity now\n    // An eligible helper is one that does not have a complex path, i.e. `this.foo`, `../foo` etc.\n    if (isEligible && !isHelper) {\n      let name = sexpr.path.parts[0],\n        options = this.options;\n      if (options.knownHelpers[name]) {\n        isHelper = true;\n      } else if (options.knownHelpersOnly) {\n        isEligible = false;\n      }\n    }\n\n    if (isHelper) {\n      return 'helper';\n    } else if (isEligible) {\n      return 'ambiguous';\n    } else {\n      return 'simple';\n    }\n  },\n\n  pushParams: function(params) {\n    for (let i = 0, l = params.length; i < l; i++) {\n      this.pushParam(params[i]);\n    }\n  },\n\n  pushParam: function(val) {\n    let value = val.value != null ? val.value : val.original || '';\n\n    if (this.stringParams) {\n      if (value.replace) {\n        value = value.replace(/^(\\.?\\.\\/)*/g, '').replace(/\\//g, '.');\n      }\n\n      if (val.depth) {\n        this.addDepth(val.depth);\n      }\n      this.opcode('getContext', val.depth || 0);\n      this.opcode('pushStringParam', value, val.type);\n\n      if (val.type === 'SubExpression') {\n        // SubExpressions get evaluated and passed in\n        // in string params mode.\n        this.accept(val);\n      }\n    } else {\n      if (this.trackIds) {\n        let blockParamIndex;\n        if (val.parts && !AST.helpers.scopedId(val) && !val.depth) {\n          blockParamIndex = this.blockParamIndex(val.parts[0]);\n        }\n        if (blockParamIndex) {\n          let blockParamChild = val.parts.slice(1).join('.');\n          this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);\n        } else {\n          value = val.original || value;\n          if (value.replace) {\n            value = value\n              .replace(/^this(?:\\.|$)/, '')\n              .replace(/^\\.\\//, '')\n              .replace(/^\\.$/, '');\n          }\n\n          this.opcode('pushId', val.type, value);\n        }\n      }\n      this.accept(val);\n    }\n  },\n\n  setupFullMustacheParams: function(sexpr, program, inverse, omitEmpty) {\n    let params = sexpr.params;\n    this.pushParams(params);\n\n    this.opcode('pushProgram', program);\n    this.opcode('pushProgram', inverse);\n\n    if (sexpr.hash) {\n      this.accept(sexpr.hash);\n    } else {\n      this.opcode('emptyHash', omitEmpty);\n    }\n\n    return params;\n  },\n\n  blockParamIndex: function(name) {\n    for (\n      let depth = 0, len = this.options.blockParams.length;\n      depth < len;\n      depth++\n    ) {\n      let blockParams = this.options.blockParams[depth],\n        param = blockParams && indexOf(blockParams, name);\n      if (blockParams && param >= 0) {\n        return [depth, param];\n      }\n    }\n  }\n};\n\nexport function precompile(input, options, env) {\n  if (\n    input == null ||\n    (typeof input !== 'string' && input.type !== 'Program')\n  ) {\n    throw new Exception(\n      'You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' +\n        input\n    );\n  }\n\n  options = options || {};\n  if (!('data' in options)) {\n    options.data = true;\n  }\n  if (options.compat) {\n    options.useDepths = true;\n  }\n\n  let ast = env.parse(input, options),\n    environment = new env.Compiler().compile(ast, options);\n  return new env.JavaScriptCompiler().compile(environment, options);\n}\n\nexport function compile(input, options = {}, env) {\n  if (\n    input == null ||\n    (typeof input !== 'string' && input.type !== 'Program')\n  ) {\n    throw new Exception(\n      'You must pass a string or Handlebars AST to Handlebars.compile. You passed ' +\n        input\n    );\n  }\n\n  options = extend({}, options);\n  if (!('data' in options)) {\n    options.data = true;\n  }\n  if (options.compat) {\n    options.useDepths = true;\n  }\n\n  let compiled;\n\n  function compileInput() {\n    let ast = env.parse(input, options),\n      environment = new env.Compiler().compile(ast, options),\n      templateSpec = new env.JavaScriptCompiler().compile(\n        environment,\n        options,\n        undefined,\n        true\n      );\n    return env.template(templateSpec);\n  }\n\n  // Template is only compiled on first use and cached after that point.\n  function ret(context, execOptions) {\n    if (!compiled) {\n      compiled = compileInput();\n    }\n    return compiled.call(this, context, execOptions);\n  }\n  ret._setup = function(setupOptions) {\n    if (!compiled) {\n      compiled = compileInput();\n    }\n    return compiled._setup(setupOptions);\n  };\n  ret._child = function(i, data, blockParams, depths) {\n    if (!compiled) {\n      compiled = compileInput();\n    }\n    return compiled._child(i, data, blockParams, depths);\n  };\n  return ret;\n}\n\nfunction argEquals(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (isArray(a) && isArray(b) && a.length === b.length) {\n    for (let i = 0; i < a.length; i++) {\n      if (!argEquals(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\nfunction transformLiteralToPath(sexpr) {\n  if (!sexpr.path.parts) {\n    let literal = sexpr.path;\n    // Casting to string here to make false and 0 literal values play nicely with the rest\n    // of the system.\n    sexpr.path = {\n      type: 'PathExpression',\n      data: false,\n      depth: 0,\n      parts: [literal.original + ''],\n      original: literal.original + '',\n      loc: literal.loc\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"script"}