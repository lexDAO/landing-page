{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _ = require(\"lodash\");\n\nexports.classUtils = {\n  // This is useful for classes that have nested methods. Nested methods don't get bound out of the box.\n  bindAll: function bindAll(self, exclude, thisArg) {\n    if (exclude === void 0) {\n      exclude = ['contructor'];\n    }\n\n    var e_1, _a;\n\n    try {\n      for (var _b = __values(Object.getOwnPropertyNames(self)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var key = _c.value;\n        var val = self[key];\n\n        if (!_.includes(exclude, key)) {\n          if (_.isFunction(val)) {\n            self[key] = val.bind(thisArg || self);\n          } else if (_.isObject(val)) {\n            exports.classUtils.bindAll(val, exclude, self);\n          }\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return self;\n  }\n};","map":{"version":3,"sources":["../../src/class_utils.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,CAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AAEa,OAAA,CAAA,UAAA,GAAa;AACtB;AACA,EAAA,OAAO,EAAP,iBAAQ,IAAR,EAAmB,OAAnB,EAAuD,OAAvD,EAAoE;AAAjD,QAAA,OAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,OAAA,GAAA,CAAqB,YAArB,CAAA;AAAkC;;;;;AACjD,WAAkB,IAAA,EAAA,GAAA,QAAA,CAAA,MAAM,CAAC,mBAAP,CAA2B,IAA3B,CAAA,CAAA,EAAgC,EAAA,GAAA,EAAA,CAAA,IAAA,EAAlD,EAAkD,CAAA,EAAA,CAAA,IAAlD,EAAkD,EAAA,GAAA,EAAA,CAAA,IAAA,EAAlD,EAAoD;AAA/C,YAAM,GAAG,GAAA,EAAA,CAAA,KAAT;AACD,YAAM,GAAG,GAAG,IAAI,CAAC,GAAD,CAAhB;;AACA,YAAI,CAAC,CAAC,CAAC,QAAF,CAAW,OAAX,EAAoB,GAApB,CAAL,EAA+B;AAC3B,cAAI,CAAC,CAAC,UAAF,CAAa,GAAb,CAAJ,EAAuB;AACnB,YAAA,IAAI,CAAC,GAAD,CAAJ,GAAY,GAAG,CAAC,IAAJ,CAAS,OAAO,IAAI,IAApB,CAAZ;AACH,WAFD,MAEO,IAAI,CAAC,CAAC,QAAF,CAAW,GAAX,CAAJ,EAAqB;AACxB,YAAA,OAAA,CAAA,UAAA,CAAW,OAAX,CAAmB,GAAnB,EAAwB,OAAxB,EAAiC,IAAjC;AACH;AACJ;AACJ;;;;;;;;;;;;;AACD,WAAO,IAAP;AACH;AAdqB,CAAb","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _ = require(\"lodash\");\nexports.classUtils = {\n    // This is useful for classes that have nested methods. Nested methods don't get bound out of the box.\n    bindAll: function (self, exclude, thisArg) {\n        if (exclude === void 0) { exclude = ['contructor']; }\n        var e_1, _a;\n        try {\n            for (var _b = __values(Object.getOwnPropertyNames(self)), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var key = _c.value;\n                var val = self[key];\n                if (!_.includes(exclude, key)) {\n                    if (_.isFunction(val)) {\n                        self[key] = val.bind(thisArg || self);\n                    }\n                    else if (_.isObject(val)) {\n                        exports.classUtils.bindAll(val, exclude, self);\n                    }\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return self;\n    },\n};\n//# sourceMappingURL=class_utils.js.map"]},"metadata":{},"sourceType":"script"}