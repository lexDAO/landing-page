{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _ = require(\"lodash\");\n\nexports.providerUtils = {\n  /**\n   * Starts the Web3ProviderEngine without excess block polling\n   * @param providerEngine The Web3ProviderEngine\n   */\n  startProviderEngine: function startProviderEngine(providerEngine) {\n    if (providerEngine.start === undefined) {\n      throw new Error(\"Invalid Web3ProviderEngine\");\n    } // HACK: When calling start() Web3ProviderEngine starts a block polling service\n    // this continuously pulls data from the network and can result in high data usage\n    // for long running services. If used in a front end application this can cause\n    // a high amount of load on a node (one request per user per block).\n\n\n    providerEngine._ready.go();\n\n    providerEngine._running = true;\n  },\n\n  /**\n   * Standardize the supported provider types into our internal provider interface\n   * or throw if unsupported provider supplied.\n   * @param supportedProvider Potentially supported provider instance\n   * @return Provider that conforms of our internal provider interface\n   */\n  standardizeOrThrow: function standardizeOrThrow(supportedProvider) {\n    if (supportedProvider === undefined) {\n      throw new Error(\"supportedProvider cannot be 'undefined'\");\n    }\n\n    var provider = {\n      isStandardizedProvider: true,\n      isMetaMask: supportedProvider.isMetaMask,\n      isParity: supportedProvider.isParity,\n      stop: supportedProvider.stop,\n      enable: supportedProvider.enable,\n      sendAsync: _.noop.bind(_)\n    }; // Case 1: We've already converted to our ZeroExProvider so noop.\n\n    if (supportedProvider.isStandardizedProvider) {\n      // tslint:disable-next-line:no-unnecessary-type-assertion\n      return supportedProvider; // Case 2: It's a compliant EIP 1193 Provider\n      // tslint:disable-next-line:no-unnecessary-type-assertion\n    } else if (supportedProvider.isEIP1193) {\n      provider.sendAsync = function (payload, callback) {\n        var method = payload.method;\n        var params = payload.params;\n        supportedProvider.send(method, params).then(function (result) {\n          callback(null, result);\n        }).catch(function (err) {\n          callback(err);\n        });\n      };\n\n      return provider; // Case 3: The provider has a `sendAsync` method, so we use it.\n    } else if (supportedProvider.sendAsync !== undefined) {\n      provider.sendAsync = supportedProvider.sendAsync.bind(supportedProvider);\n      return provider; // Case 4: The provider does not have a `sendAsync` method but does have a `send` method\n    } else if (supportedProvider.send !== undefined) {\n      // HACK(fabio): Detect if the `send` method has the old interface `send(payload, cb)` such\n      // as in versions < Web3.js@1.0.0-beta.37. If so, do a simple re-mapping\n      if (_.includes(supportedProvider.send.toString(), 'function (payload, callback)')) {\n        provider.sendAsync = supportedProvider.send.bind(supportedProvider);\n        return provider;\n      } else {\n        // If doesn't have old interface, we assume it has new interface `send(method, payload)`\n        // such as in versions > Web3.js@1.0.0-beta.38 and convert it to `sendAsync`\n        provider.sendAsync = function (payload, callback) {\n          var method = payload.method;\n          var params = payload.params;\n          supportedProvider.send(method, params).then(function (result) {\n            callback(null, result);\n          }).catch(function (err) {\n            callback(err);\n          });\n        };\n\n        return provider;\n      }\n    }\n\n    throw new Error(\"Unsupported provider found. Please make sure it conforms to one of the supported providers. See 'Provider' type in 'ethereum-types' package.\");\n  }\n};","map":{"version":3,"sources":["../../src/provider_utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _ = require(\"lodash\");\nexports.providerUtils = {\n    /**\n     * Starts the Web3ProviderEngine without excess block polling\n     * @param providerEngine The Web3ProviderEngine\n     */\n    startProviderEngine: function (providerEngine) {\n        if (providerEngine.start === undefined) {\n            throw new Error(\"Invalid Web3ProviderEngine\");\n        }\n        // HACK: When calling start() Web3ProviderEngine starts a block polling service\n        // this continuously pulls data from the network and can result in high data usage\n        // for long running services. If used in a front end application this can cause\n        // a high amount of load on a node (one request per user per block).\n        providerEngine._ready.go();\n        providerEngine._running = true;\n    },\n    /**\n     * Standardize the supported provider types into our internal provider interface\n     * or throw if unsupported provider supplied.\n     * @param supportedProvider Potentially supported provider instance\n     * @return Provider that conforms of our internal provider interface\n     */\n    standardizeOrThrow: function (supportedProvider) {\n        if (supportedProvider === undefined) {\n            throw new Error(\"supportedProvider cannot be 'undefined'\");\n        }\n        var provider = {\n            isStandardizedProvider: true,\n            isMetaMask: supportedProvider.isMetaMask,\n            isParity: supportedProvider.isParity,\n            stop: supportedProvider.stop,\n            enable: supportedProvider.enable,\n            sendAsync: _.noop.bind(_),\n        };\n        // Case 1: We've already converted to our ZeroExProvider so noop.\n        if (supportedProvider.isStandardizedProvider) {\n            // tslint:disable-next-line:no-unnecessary-type-assertion\n            return supportedProvider;\n            // Case 2: It's a compliant EIP 1193 Provider\n            // tslint:disable-next-line:no-unnecessary-type-assertion\n        }\n        else if (supportedProvider.isEIP1193) {\n            provider.sendAsync = function (payload, callback) {\n                var method = payload.method;\n                var params = payload.params;\n                supportedProvider\n                    .send(method, params)\n                    .then(function (result) {\n                    callback(null, result);\n                })\n                    .catch(function (err) {\n                    callback(err);\n                });\n            };\n            return provider;\n            // Case 3: The provider has a `sendAsync` method, so we use it.\n        }\n        else if (supportedProvider.sendAsync !== undefined) {\n            provider.sendAsync = supportedProvider.sendAsync.bind(supportedProvider);\n            return provider;\n            // Case 4: The provider does not have a `sendAsync` method but does have a `send` method\n        }\n        else if (supportedProvider.send !== undefined) {\n            // HACK(fabio): Detect if the `send` method has the old interface `send(payload, cb)` such\n            // as in versions < Web3.js@1.0.0-beta.37. If so, do a simple re-mapping\n            if (_.includes(supportedProvider.send.toString(), 'function (payload, callback)')) {\n                provider.sendAsync = supportedProvider.send.bind(supportedProvider);\n                return provider;\n            }\n            else {\n                // If doesn't have old interface, we assume it has new interface `send(method, payload)`\n                // such as in versions > Web3.js@1.0.0-beta.38 and convert it to `sendAsync`\n                provider.sendAsync = function (payload, callback) {\n                    var method = payload.method;\n                    var params = payload.params;\n                    supportedProvider\n                        .send(method, params)\n                        .then(function (result) {\n                        callback(null, result);\n                    })\n                        .catch(function (err) {\n                        callback(err);\n                    });\n                };\n                return provider;\n            }\n        }\n        throw new Error(\"Unsupported provider found. Please make sure it conforms to one of the supported providers. See 'Provider' type in 'ethereum-types' package.\");\n    },\n};\n//# sourceMappingURL=provider_utils.js.map"]},"metadata":{},"sourceType":"script"}