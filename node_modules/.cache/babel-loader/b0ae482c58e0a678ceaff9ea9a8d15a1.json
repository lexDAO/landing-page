{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar types_1 = require(\"../types\");\n\nvar constants_1 = require(\"../constants\");\n\nvar _utils_1 = require(\"../_utils\");\n\nvar _utils_2 = require(\"./_utils\");\n\nfunction normalizeTokenAmount(tokenAmount) {\n  _utils_1.ensureAllUInt8([tokenAmount.token.decimals]);\n\n  var normalizedAmount = _utils_1.normalizeBigNumberish(tokenAmount.amount);\n\n  _utils_1.ensureAllUInt256([normalizedAmount]);\n\n  return {\n    token: __assign({}, tokenAmount.token),\n    amount: normalizedAmount\n  };\n}\n\nfunction normalizeTokenReserves(tokenReserves) {\n  _utils_1.ensureAllUInt8([tokenReserves.token.decimals]);\n\n  return __assign({\n    token: __assign({}, tokenReserves.token)\n  }, tokenReserves.exchange ? {\n    exchange: __assign({}, tokenReserves.exchange)\n  } : {}, {\n    ethReserve: normalizeTokenAmount(tokenReserves.ethReserve),\n    tokenReserve: normalizeTokenAmount(tokenReserves.tokenReserve)\n  });\n}\n\nfunction parseOptionalReserves(optionalReservesInput, optionalReservesOutput) {\n  if (types_1.areTokenReserves(optionalReservesInput) && types_1.areTokenReserves(optionalReservesOutput)) {\n    return {\n      tradeType: constants_1.TRADE_TYPE.TOKEN_TO_TOKEN,\n      inputReserves: normalizeTokenReserves(optionalReservesInput),\n      outputReserves: normalizeTokenReserves(optionalReservesOutput)\n    };\n  } else if (types_1.areTokenReserves(optionalReservesInput) && !types_1.areTokenReserves(optionalReservesOutput)) {\n    return {\n      tradeType: constants_1.TRADE_TYPE.TOKEN_TO_ETH,\n      inputReserves: normalizeTokenReserves(optionalReservesInput),\n      outputReserves: types_1.areETHReserves(optionalReservesOutput) ? optionalReservesOutput : {\n        token: _utils_1.getEthToken(optionalReservesInput.token.chainId)\n      }\n    };\n  } else if (!types_1.areTokenReserves(optionalReservesInput) && types_1.areTokenReserves(optionalReservesOutput)) {\n    return {\n      tradeType: constants_1.TRADE_TYPE.ETH_TO_TOKEN,\n      inputReserves: types_1.areETHReserves(optionalReservesInput) ? optionalReservesInput : {\n        token: _utils_1.getEthToken(optionalReservesOutput.token.chainId)\n      },\n      outputReserves: normalizeTokenReserves(optionalReservesOutput)\n    };\n  } else {\n    throw Error('optionalReservesInput, optionalReservesOutput, or both must be defined.');\n  }\n}\n\nfunction getMarketRate(tradeType, reserves, keepAsDecimal) {\n  if (!types_1.areTokenReservesNormalized(reserves)) {\n    throw Error;\n  }\n\n  var numerator = tradeType === constants_1.TRADE_TYPE.ETH_TO_TOKEN ? reserves.tokenReserve : reserves.ethReserve;\n  var denominator = tradeType === constants_1.TRADE_TYPE.ETH_TO_TOKEN ? reserves.ethReserve : reserves.tokenReserve;\n  return _utils_2.calculateDecimalRate(numerator, denominator, keepAsDecimal);\n}\n\nfunction getMarketDetails(optionalReservesInput, optionalReservesOutput) {\n  var _a = parseOptionalReserves(optionalReservesInput, optionalReservesOutput),\n      tradeType = _a.tradeType,\n      inputReserves = _a.inputReserves,\n      outputReserves = _a.outputReserves;\n\n  if (tradeType === constants_1.TRADE_TYPE.TOKEN_TO_TOKEN) {\n    var _b = getMarketRate(constants_1.TRADE_TYPE.TOKEN_TO_ETH, inputReserves, true),\n        numeratorInput = _b.numerator,\n        denominatorInput = _b.denominator,\n        decimalScalarInput = _b.decimalScalar,\n        decimalScalarInvertedInput = _b.decimalScalarInverted;\n\n    var _c = getMarketRate(constants_1.TRADE_TYPE.ETH_TO_TOKEN, outputReserves, true),\n        numeratorOutput = _c.numerator,\n        denominatorOutput = _c.denominator,\n        decimalScalarOutput = _c.decimalScalar,\n        decimalScalarInvertedOutput = _c.decimalScalarInverted;\n\n    var marketRate = numeratorInput.multipliedBy(decimalScalarInput).multipliedBy(numeratorOutput).multipliedBy(decimalScalarOutput).dividedBy(denominatorInput.multipliedBy(denominatorOutput));\n    var marketRateInverted = denominatorInput.multipliedBy(decimalScalarInvertedInput).multipliedBy(denominatorOutput).multipliedBy(decimalScalarInvertedOutput).dividedBy(numeratorInput.multipliedBy(numeratorOutput));\n    return {\n      tradeType: tradeType,\n      inputReserves: inputReserves,\n      outputReserves: outputReserves,\n      marketRate: {\n        rate: marketRate,\n        rateInverted: marketRateInverted\n      }\n    };\n  } else {\n    var reserves = tradeType === constants_1.TRADE_TYPE.ETH_TO_TOKEN ? outputReserves : inputReserves;\n    return {\n      tradeType: tradeType,\n      inputReserves: inputReserves,\n      outputReserves: outputReserves,\n      marketRate: getMarketRate(tradeType, reserves)\n    };\n  }\n}\n\nexports.getMarketDetails = getMarketDetails;","map":{"version":3,"sources":["../../src/computation/market.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar types_1 = require(\"../types\");\nvar constants_1 = require(\"../constants\");\nvar _utils_1 = require(\"../_utils\");\nvar _utils_2 = require(\"./_utils\");\nfunction normalizeTokenAmount(tokenAmount) {\n    _utils_1.ensureAllUInt8([tokenAmount.token.decimals]);\n    var normalizedAmount = _utils_1.normalizeBigNumberish(tokenAmount.amount);\n    _utils_1.ensureAllUInt256([normalizedAmount]);\n    return {\n        token: __assign({}, tokenAmount.token),\n        amount: normalizedAmount\n    };\n}\nfunction normalizeTokenReserves(tokenReserves) {\n    _utils_1.ensureAllUInt8([tokenReserves.token.decimals]);\n    return __assign({ token: __assign({}, tokenReserves.token) }, (tokenReserves.exchange ? { exchange: __assign({}, tokenReserves.exchange) } : {}), { ethReserve: normalizeTokenAmount(tokenReserves.ethReserve), tokenReserve: normalizeTokenAmount(tokenReserves.tokenReserve) });\n}\nfunction parseOptionalReserves(optionalReservesInput, optionalReservesOutput) {\n    if (types_1.areTokenReserves(optionalReservesInput) && types_1.areTokenReserves(optionalReservesOutput)) {\n        return {\n            tradeType: constants_1.TRADE_TYPE.TOKEN_TO_TOKEN,\n            inputReserves: normalizeTokenReserves(optionalReservesInput),\n            outputReserves: normalizeTokenReserves(optionalReservesOutput)\n        };\n    }\n    else if (types_1.areTokenReserves(optionalReservesInput) && !types_1.areTokenReserves(optionalReservesOutput)) {\n        return {\n            tradeType: constants_1.TRADE_TYPE.TOKEN_TO_ETH,\n            inputReserves: normalizeTokenReserves(optionalReservesInput),\n            outputReserves: types_1.areETHReserves(optionalReservesOutput)\n                ? optionalReservesOutput\n                : {\n                    token: _utils_1.getEthToken(optionalReservesInput.token.chainId)\n                }\n        };\n    }\n    else if (!types_1.areTokenReserves(optionalReservesInput) && types_1.areTokenReserves(optionalReservesOutput)) {\n        return {\n            tradeType: constants_1.TRADE_TYPE.ETH_TO_TOKEN,\n            inputReserves: types_1.areETHReserves(optionalReservesInput)\n                ? optionalReservesInput\n                : {\n                    token: _utils_1.getEthToken(optionalReservesOutput.token.chainId)\n                },\n            outputReserves: normalizeTokenReserves(optionalReservesOutput)\n        };\n    }\n    else {\n        throw Error('optionalReservesInput, optionalReservesOutput, or both must be defined.');\n    }\n}\nfunction getMarketRate(tradeType, reserves, keepAsDecimal) {\n    if (!types_1.areTokenReservesNormalized(reserves)) {\n        throw Error;\n    }\n    var numerator = tradeType === constants_1.TRADE_TYPE.ETH_TO_TOKEN ? reserves.tokenReserve : reserves.ethReserve;\n    var denominator = tradeType === constants_1.TRADE_TYPE.ETH_TO_TOKEN ? reserves.ethReserve : reserves.tokenReserve;\n    return _utils_2.calculateDecimalRate(numerator, denominator, keepAsDecimal);\n}\nfunction getMarketDetails(optionalReservesInput, optionalReservesOutput) {\n    var _a = parseOptionalReserves(optionalReservesInput, optionalReservesOutput), tradeType = _a.tradeType, inputReserves = _a.inputReserves, outputReserves = _a.outputReserves;\n    if (tradeType === constants_1.TRADE_TYPE.TOKEN_TO_TOKEN) {\n        var _b = getMarketRate(constants_1.TRADE_TYPE.TOKEN_TO_ETH, inputReserves, true), numeratorInput = _b.numerator, denominatorInput = _b.denominator, decimalScalarInput = _b.decimalScalar, decimalScalarInvertedInput = _b.decimalScalarInverted;\n        var _c = getMarketRate(constants_1.TRADE_TYPE.ETH_TO_TOKEN, outputReserves, true), numeratorOutput = _c.numerator, denominatorOutput = _c.denominator, decimalScalarOutput = _c.decimalScalar, decimalScalarInvertedOutput = _c.decimalScalarInverted;\n        var marketRate = numeratorInput\n            .multipliedBy(decimalScalarInput)\n            .multipliedBy(numeratorOutput)\n            .multipliedBy(decimalScalarOutput)\n            .dividedBy(denominatorInput.multipliedBy(denominatorOutput));\n        var marketRateInverted = denominatorInput\n            .multipliedBy(decimalScalarInvertedInput)\n            .multipliedBy(denominatorOutput)\n            .multipliedBy(decimalScalarInvertedOutput)\n            .dividedBy(numeratorInput.multipliedBy(numeratorOutput));\n        return {\n            tradeType: tradeType,\n            inputReserves: inputReserves,\n            outputReserves: outputReserves,\n            marketRate: { rate: marketRate, rateInverted: marketRateInverted }\n        };\n    }\n    else {\n        var reserves = (tradeType === constants_1.TRADE_TYPE.ETH_TO_TOKEN\n            ? outputReserves\n            : inputReserves);\n        return {\n            tradeType: tradeType,\n            inputReserves: inputReserves,\n            outputReserves: outputReserves,\n            marketRate: getMarketRate(tradeType, reserves)\n        };\n    }\n}\nexports.getMarketDetails = getMarketDetails;\n//# sourceMappingURL=market.js.map"]},"metadata":{},"sourceType":"script"}