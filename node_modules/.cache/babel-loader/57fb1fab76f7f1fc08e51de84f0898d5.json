{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethUtil = require(\"ethereumjs-util\");\n\nvar _ = require(\"lodash\");\n\nvar constants_1 = require(\"../utils/constants\");\n\nvar pointer_1 = require(\"./blocks/pointer\");\n\nvar set_1 = require(\"./blocks/set\");\n\nvar iterator_1 = require(\"./iterator\");\n\nvar Calldata =\n/** @class */\nfunction () {\n  function Calldata(rules) {\n    this._rules = rules;\n    this._selector = '';\n    this._root = undefined;\n  }\n  /**\n   * Sets the root calldata block. This block usually corresponds to a Method.\n   */\n\n\n  Calldata.prototype.setRoot = function (block) {\n    this._root = block;\n  };\n  /**\n   * Sets the selector to be prepended onto the calldata.\n   * If the root block was created by a Method then a selector will likely be set.\n   */\n\n\n  Calldata.prototype.setSelector = function (selector) {\n    if (!_.startsWith(selector, '0x')) {\n      throw new Error(\"Expected selector to be hex. Missing prefix '0x'\");\n    } else if (selector.length !== constants_1.constants.HEX_SELECTOR_LENGTH_IN_CHARS) {\n      throw new Error(\"Invalid selector '\" + selector + \"'\");\n    }\n\n    this._selector = selector;\n  };\n  /**\n   * Iterates through the calldata blocks, starting from the root block, to construct calldata as a hex string.\n   * If the `optimize` flag is set then this calldata will be condensed, to save gas.\n   * If the `annotate` flag is set then this will return human-readable calldata.\n   * If the `annotate` flag is *not* set then this will return EVM-compatible calldata.\n   */\n\n\n  Calldata.prototype.toString = function () {\n    var e_1, _a; // Sanity check: root block must be set\n\n\n    if (this._root === undefined) {\n      throw new Error('expected root');\n    } // Optimize, if flag set\n\n\n    if (this._rules.shouldOptimize) {\n      this._optimize();\n    } // Set offsets\n\n\n    var iterator = new iterator_1.CalldataIterator(this._root);\n    var offset = 0;\n\n    try {\n      for (var iterator_2 = __values(iterator), iterator_2_1 = iterator_2.next(); !iterator_2_1.done; iterator_2_1 = iterator_2.next()) {\n        var block = iterator_2_1.value;\n        block.setOffset(offset);\n        offset += block.getSizeInBytes();\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (iterator_2_1 && !iterator_2_1.done && (_a = iterator_2.return)) _a.call(iterator_2);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    } // Generate hex string\n\n\n    var hexString = this._rules.shouldAnnotate ? this._toHumanReadableCallData() : this._toEvmCompatibeCallDataHex();\n    return hexString;\n  };\n  /**\n   * There are three types of calldata blocks: Blob, Set and Pointer.\n   * Scenarios arise where distinct pointers resolve to identical values.\n   * We optimize by keeping only one such instance of the identical value, and redirecting all pointers here.\n   * We keep the last such duplicate value because pointers can only be positive (they cannot point backwards).\n   *\n   * Example #1:\n   *  function f(string[], string[])\n   *  f([\"foo\", \"bar\", \"blitz\"], [\"foo\", \"bar\", \"blitz\"])\n   *  The array [\"foo\", \"bar\", \"blitz\"] will only be included in the calldata once.\n   *\n   * Example #2:\n   *  function f(string[], string)\n   *  f([\"foo\", \"bar\", \"blitz\"], \"foo\")\n   *  The string \"foo\" will only be included in the calldata once.\n   *\n   * Example #3:\n   *  function f((string, uint, bytes), string, uint, bytes)\n   *  f((\"foo\", 5, \"0x05\"), \"foo\", 5, \"0x05\")\n   *  The string \"foo\" and bytes \"0x05\" will only be included in the calldata once.\n   *  The duplicate `uint 5` values cannot be optimized out because they are static values (no pointer points to them).\n   *\n   * @TODO #1:\n   *   This optimization strategy handles blocks that are exact duplicates of one another.\n   *   But what if some block is a combination of two other blocks? Or a subset of another block?\n   *   This optimization problem is not much different from the current implemetation.\n   *   Instead of tracking \"observed\" hashes, at each node we would simply do pattern-matching on the calldata.\n   *   This strategy would be applied after assigning offsets to the tree, rather than before (as in this strategy).\n   *   Note that one consequence of this strategy is pointers may resolve to offsets that are not word-aligned.\n   *   This shouldn't be a problem but further investigation should be done.\n   *\n   * @TODO #2:\n   *   To be done as a follow-up to @TODO #1.\n   *   Since we optimize from the bottom-up, we could be affecting the outcome of a later potential optimization.\n   *   For example, what if by removing one duplicate value we miss out on optimizing another block higher in the tree.\n   *   To handle this case, at each node we can store a candidate optimization in a priority queue (sorted by calldata size).\n   *   At the end of traversing the tree, the candidate at the front of the queue will be the most optimal output.\n   *\n   */\n\n\n  Calldata.prototype._optimize = function () {\n    var e_2, _a; // Step 1/1 Create a reverse iterator (starts from the end of the calldata to the beginning)\n\n\n    if (this._root === undefined) {\n      throw new Error('expected root');\n    }\n\n    var iterator = new iterator_1.ReverseCalldataIterator(this._root); // Step 2/2 Iterate over each block, keeping track of which blocks have been seen and pruning redundant blocks.\n\n    var blocksByHash = {};\n\n    try {\n      for (var iterator_3 = __values(iterator), iterator_3_1 = iterator_3.next(); !iterator_3_1.done; iterator_3_1 = iterator_3.next()) {\n        var block = iterator_3_1.value; // If a block is a pointer and its value has already been observed, then update\n        // the pointer to resolve to the existing value.\n\n        if (block instanceof pointer_1.PointerCalldataBlock) {\n          var dependencyBlockHashBuf = block.getDependency().computeHash();\n          var dependencyBlockHash = ethUtil.bufferToHex(dependencyBlockHashBuf);\n\n          if (dependencyBlockHash in blocksByHash) {\n            var blockWithSameHash = blocksByHash[dependencyBlockHash];\n\n            if (blockWithSameHash !== block.getDependency()) {\n              block.setAlias(blockWithSameHash);\n            }\n          }\n\n          continue;\n        } // This block has not been seen. Record its hash.\n\n\n        var blockHashBuf = block.computeHash();\n        var blockHash = ethUtil.bufferToHex(blockHashBuf);\n\n        if (!(blockHash in blocksByHash)) {\n          blocksByHash[blockHash] = block;\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (iterator_3_1 && !iterator_3_1.done && (_a = iterator_3.return)) _a.call(iterator_3);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n  };\n\n  Calldata.prototype._toEvmCompatibeCallDataHex = function () {\n    var e_3, _a; // Sanity check: must have a root block.\n\n\n    if (this._root === undefined) {\n      throw new Error('expected root');\n    } // Construct an array of buffers (one buffer for each block).\n\n\n    var selectorBuffer = ethUtil.toBuffer(this._selector);\n    var valueBufs = [selectorBuffer];\n    var iterator = new iterator_1.CalldataIterator(this._root);\n\n    try {\n      for (var iterator_4 = __values(iterator), iterator_4_1 = iterator_4.next(); !iterator_4_1.done; iterator_4_1 = iterator_4.next()) {\n        var block = iterator_4_1.value;\n        valueBufs.push(block.toBuffer());\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (iterator_4_1 && !iterator_4_1.done && (_a = iterator_4.return)) _a.call(iterator_4);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    } // Create hex from buffer array.\n\n\n    var combinedBuffers = Buffer.concat(valueBufs);\n    var hexValue = ethUtil.bufferToHex(combinedBuffers);\n    return hexValue;\n  };\n  /**\n   * Returns human-readable calldata.\n   *\n   * Example:\n   *   simpleFunction(string[], string[])\n   *   strings = [\"Hello\", \"World\"]\n   *   simpleFunction(strings, strings)\n   *\n   * Output:\n   *   0xbb4f12e3\n   *                                                                                      ### simpleFunction\n   *   0x0       0000000000000000000000000000000000000000000000000000000000000040              ptr<array1> (alias for array2)\n   *   0x20      0000000000000000000000000000000000000000000000000000000000000040              ptr<array2>\n   *\n   *   0x40      0000000000000000000000000000000000000000000000000000000000000002          ### array2\n   *   0x60      0000000000000000000000000000000000000000000000000000000000000040              ptr<array2[0]>\n   *   0x80      0000000000000000000000000000000000000000000000000000000000000080              ptr<array2[1]>\n   *   0xa0      0000000000000000000000000000000000000000000000000000000000000005              array2[0]\n   *   0xc0      48656c6c6f000000000000000000000000000000000000000000000000000000\n   *   0xe0      0000000000000000000000000000000000000000000000000000000000000005              array2[1]\n   *   0x100     576f726c64000000000000000000000000000000000000000000000000000000\n   */\n\n\n  Calldata.prototype._toHumanReadableCallData = function () {\n    var e_4, _a; // Sanity check: must have a root block.\n\n\n    if (this._root === undefined) {\n      throw new Error('expected root');\n    } // Constants for constructing annotated string\n\n\n    var offsetPadding = 10;\n    var valuePadding = 74;\n    var namePadding = 80;\n    var evmWordStartIndex = 0;\n    var emptySize = 0; // Construct annotated calldata\n\n    var hexValue = \"\" + this._selector;\n    var offset = 0;\n\n    var functionName = this._root.getName();\n\n    var iterator = new iterator_1.CalldataIterator(this._root);\n\n    try {\n      for (var iterator_5 = __values(iterator), iterator_5_1 = iterator_5.next(); !iterator_5_1.done; iterator_5_1 = iterator_5.next()) {\n        var block = iterator_5_1.value; // Process each block 1 word at a time\n\n        var size = block.getSizeInBytes();\n        var name_1 = block.getName();\n        var parentName = block.getParentName();\n        var prettyName = name_1.replace(parentName + \".\", '').replace(functionName + \".\", ''); // Resulting line will be <offsetStr><valueStr><nameStr>\n\n        var offsetStr = '';\n        var valueStr = '';\n        var nameStr = '';\n        var lineStr = '';\n\n        if (size === emptySize) {\n          // This is a Set block with no header.\n          // For example, a tuple or an array with a defined length.\n          offsetStr = ' '.repeat(offsetPadding);\n          valueStr = ' '.repeat(valuePadding);\n          nameStr = \"### \" + prettyName.padEnd(namePadding);\n          lineStr = \"\\n\" + offsetStr + valueStr + nameStr;\n        } else {\n          // This block has at least one word of value.\n          offsetStr = (\"0x\" + offset.toString(constants_1.constants.HEX_BASE)).padEnd(offsetPadding);\n          valueStr = ethUtil.stripHexPrefix(ethUtil.bufferToHex(block.toBuffer().slice(evmWordStartIndex, constants_1.constants.EVM_WORD_WIDTH_IN_BYTES))).padEnd(valuePadding);\n\n          if (block instanceof set_1.SetCalldataBlock) {\n            nameStr = \"### \" + prettyName.padEnd(namePadding);\n            lineStr = \"\\n\" + offsetStr + valueStr + nameStr;\n          } else {\n            nameStr = \"    \" + prettyName.padEnd(namePadding);\n            lineStr = \"\" + offsetStr + valueStr + nameStr;\n          }\n        } // This block has a value that is more than 1 word.\n\n\n        for (var j = constants_1.constants.EVM_WORD_WIDTH_IN_BYTES; j < size; j += constants_1.constants.EVM_WORD_WIDTH_IN_BYTES) {\n          offsetStr = (\"0x\" + (offset + j).toString(constants_1.constants.HEX_BASE)).padEnd(offsetPadding);\n          valueStr = ethUtil.stripHexPrefix(ethUtil.bufferToHex(block.toBuffer().slice(j, j + constants_1.constants.EVM_WORD_WIDTH_IN_BYTES))).padEnd(valuePadding);\n          nameStr = ' '.repeat(namePadding);\n          lineStr = lineStr + \"\\n\" + offsetStr + valueStr + nameStr;\n        } // Append to hex value\n\n\n        hexValue = hexValue + \"\\n\" + lineStr;\n        offset += size;\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (iterator_5_1 && !iterator_5_1.done && (_a = iterator_5.return)) _a.call(iterator_5);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    }\n\n    return hexValue;\n  };\n\n  return Calldata;\n}();\n\nexports.Calldata = Calldata;","map":{"version":3,"sources":["../../../../src/abi_encoder/calldata/calldata.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,OAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AACA,IAAA,CAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AAEA,IAAA,WAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;;AAGA,IAAA,SAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;;AACA,IAAA,KAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;AAEA,IAAA,UAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AAEA,IAAA,QAAA;AAAA;AAAA,YAAA;AAKI,WAAA,QAAA,CAAmB,KAAnB,EAAuC;AACnC,SAAK,MAAL,GAAc,KAAd;AACA,SAAK,SAAL,GAAiB,EAAjB;AACA,SAAK,KAAL,GAAa,SAAb;AACH;AACD;;;;;AAGO,EAAA,QAAA,CAAA,SAAA,CAAA,OAAA,GAAP,UAAe,KAAf,EAAmC;AAC/B,SAAK,KAAL,GAAa,KAAb;AACH,GAFM;AAGP;;;;;;AAIO,EAAA,QAAA,CAAA,SAAA,CAAA,WAAA,GAAP,UAAmB,QAAnB,EAAmC;AAC/B,QAAI,CAAC,CAAC,CAAC,UAAF,CAAa,QAAb,EAAuB,IAAvB,CAAL,EAAmC;AAC/B,YAAM,IAAI,KAAJ,CAAU,kDAAV,CAAN;AACH,KAFD,MAEO,IAAI,QAAQ,CAAC,MAAT,KAAoB,WAAA,CAAA,SAAA,CAAU,4BAAlC,EAAgE;AACnE,YAAM,IAAI,KAAJ,CAAU,uBAAqB,QAArB,GAA6B,GAAvC,CAAN;AACH;;AACD,SAAK,SAAL,GAAiB,QAAjB;AACH,GAPM;AAQP;;;;;;;;AAMO,EAAA,QAAA,CAAA,SAAA,CAAA,QAAA,GAAP,YAAA;gBAAA,CACI;;;AACA,QAAI,KAAK,KAAL,KAAe,SAAnB,EAA8B;AAC1B,YAAM,IAAI,KAAJ,CAAU,eAAV,CAAN;AACH,KAJL,CAKI;;;AACA,QAAI,KAAK,MAAL,CAAY,cAAhB,EAAgC;AAC5B,WAAK,SAAL;AACH,KARL,CASI;;;AACA,QAAM,QAAQ,GAAG,IAAI,UAAA,CAAA,gBAAJ,CAAqB,KAAK,KAA1B,CAAjB;AACA,QAAI,MAAM,GAAG,CAAb;;;AACA,WAAoB,IAAA,UAAA,GAAA,QAAA,CAAA,QAAA,CAAA,EAAQ,YAAA,GAAA,UAAA,CAAA,IAAA,EAA5B,EAA4B,CAAA,YAAA,CAAA,IAA5B,EAA4B,YAAA,GAAA,UAAA,CAAA,IAAA,EAA5B,EAA8B;AAAzB,YAAM,KAAK,GAAA,YAAA,CAAA,KAAX;AACD,QAAA,KAAK,CAAC,SAAN,CAAgB,MAAhB;AACA,QAAA,MAAM,IAAI,KAAK,CAAC,cAAN,EAAV;AACH;;;;;;;;;;;KAfL,CAgBI;;;AACA,QAAM,SAAS,GAAG,KAAK,MAAL,CAAY,cAAZ,GACZ,KAAK,wBAAL,EADY,GAEZ,KAAK,0BAAL,EAFN;AAGA,WAAO,SAAP;AACH,GArBM;AAsBP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCQ,EAAA,QAAA,CAAA,SAAA,CAAA,SAAA,GAAR,YAAA;gBAAA,CACI;;;AACA,QAAI,KAAK,KAAL,KAAe,SAAnB,EAA8B;AAC1B,YAAM,IAAI,KAAJ,CAAU,eAAV,CAAN;AACH;;AACD,QAAM,QAAQ,GAAG,IAAI,UAAA,CAAA,uBAAJ,CAA4B,KAAK,KAAjC,CAAjB,CALJ,CAMI;;AACA,QAAM,YAAY,GAAqC,EAAvD;;;AACA,WAAoB,IAAA,UAAA,GAAA,QAAA,CAAA,QAAA,CAAA,EAAQ,YAAA,GAAA,UAAA,CAAA,IAAA,EAA5B,EAA4B,CAAA,YAAA,CAAA,IAA5B,EAA4B,YAAA,GAAA,UAAA,CAAA,IAAA,EAA5B,EAA8B;AAAzB,YAAM,KAAK,GAAA,YAAA,CAAA,KAAX,CAAyB,CAC1B;AACA;;AACA,YAAI,KAAK,YAAY,SAAA,CAAA,oBAArB,EAA2C;AACvC,cAAM,sBAAsB,GAAG,KAAK,CAAC,aAAN,GAAsB,WAAtB,EAA/B;AACA,cAAM,mBAAmB,GAAG,OAAO,CAAC,WAAR,CAAoB,sBAApB,CAA5B;;AACA,cAAI,mBAAmB,IAAI,YAA3B,EAAyC;AACrC,gBAAM,iBAAiB,GAAG,YAAY,CAAC,mBAAD,CAAtC;;AACA,gBAAI,iBAAiB,KAAK,KAAK,CAAC,aAAN,EAA1B,EAAiD;AAC7C,cAAA,KAAK,CAAC,QAAN,CAAe,iBAAf;AACH;AACJ;;AACD;AACH,SAbyB,CAc1B;;;AACA,YAAM,YAAY,GAAG,KAAK,CAAC,WAAN,EAArB;AACA,YAAM,SAAS,GAAG,OAAO,CAAC,WAAR,CAAoB,YAApB,CAAlB;;AACA,YAAI,EAAE,SAAS,IAAI,YAAf,CAAJ,EAAkC;AAC9B,UAAA,YAAY,CAAC,SAAD,CAAZ,GAA0B,KAA1B;AACH;AACJ;;;;;;;;;;;;AACJ,GA7BO;;AA8BA,EAAA,QAAA,CAAA,SAAA,CAAA,0BAAA,GAAR,YAAA;gBAAA,CACI;;;AACA,QAAI,KAAK,KAAL,KAAe,SAAnB,EAA8B;AAC1B,YAAM,IAAI,KAAJ,CAAU,eAAV,CAAN;AACH,KAJL,CAKI;;;AACA,QAAM,cAAc,GAAG,OAAO,CAAC,QAAR,CAAiB,KAAK,SAAtB,CAAvB;AACA,QAAM,SAAS,GAAa,CAAC,cAAD,CAA5B;AACA,QAAM,QAAQ,GAAG,IAAI,UAAA,CAAA,gBAAJ,CAAqB,KAAK,KAA1B,CAAjB;;;AACA,WAAoB,IAAA,UAAA,GAAA,QAAA,CAAA,QAAA,CAAA,EAAQ,YAAA,GAAA,UAAA,CAAA,IAAA,EAA5B,EAA4B,CAAA,YAAA,CAAA,IAA5B,EAA4B,YAAA,GAAA,UAAA,CAAA,IAAA,EAA5B,EAA8B;AAAzB,YAAM,KAAK,GAAA,YAAA,CAAA,KAAX;AACD,QAAA,SAAS,CAAC,IAAV,CAAe,KAAK,CAAC,QAAN,EAAf;AACH;;;;;;;;;;;KAXL,CAYI;;;AACA,QAAM,eAAe,GAAG,MAAM,CAAC,MAAP,CAAc,SAAd,CAAxB;AACA,QAAM,QAAQ,GAAG,OAAO,CAAC,WAAR,CAAoB,eAApB,CAAjB;AACA,WAAO,QAAP;AACH,GAhBO;AAiBR;;;;;;;;;;;;;;;;;;;;;;;;AAsBQ,EAAA,QAAA,CAAA,SAAA,CAAA,wBAAA,GAAR,YAAA;gBAAA,CACI;;;AACA,QAAI,KAAK,KAAL,KAAe,SAAnB,EAA8B;AAC1B,YAAM,IAAI,KAAJ,CAAU,eAAV,CAAN;AACH,KAJL,CAKI;;;AACA,QAAM,aAAa,GAAG,EAAtB;AACA,QAAM,YAAY,GAAG,EAArB;AACA,QAAM,WAAW,GAAG,EAApB;AACA,QAAM,iBAAiB,GAAG,CAA1B;AACA,QAAM,SAAS,GAAG,CAAlB,CAVJ,CAWI;;AACA,QAAI,QAAQ,GAAG,KAAG,KAAK,SAAvB;AACA,QAAI,MAAM,GAAG,CAAb;;AACA,QAAM,YAAY,GAAW,KAAK,KAAL,CAAW,OAAX,EAA7B;;AACA,QAAM,QAAQ,GAAG,IAAI,UAAA,CAAA,gBAAJ,CAAqB,KAAK,KAA1B,CAAjB;;;AACA,WAAoB,IAAA,UAAA,GAAA,QAAA,CAAA,QAAA,CAAA,EAAQ,YAAA,GAAA,UAAA,CAAA,IAAA,EAA5B,EAA4B,CAAA,YAAA,CAAA,IAA5B,EAA4B,YAAA,GAAA,UAAA,CAAA,IAAA,EAA5B,EAA8B;AAAzB,YAAM,KAAK,GAAA,YAAA,CAAA,KAAX,CAAyB,CAC1B;;AACA,YAAM,IAAI,GAAG,KAAK,CAAC,cAAN,EAAb;AACA,YAAM,MAAI,GAAG,KAAK,CAAC,OAAN,EAAb;AACA,YAAM,UAAU,GAAG,KAAK,CAAC,aAAN,EAAnB;AACA,YAAM,UAAU,GAAG,MAAI,CAAC,OAAL,CAAgB,UAAU,GAAA,GAA1B,EAA+B,EAA/B,EAAmC,OAAnC,CAA8C,YAAY,GAAA,GAA1D,EAA+D,EAA/D,CAAnB,CAL0B,CAM1B;;AACA,YAAI,SAAS,GAAG,EAAhB;AACA,YAAI,QAAQ,GAAG,EAAf;AACA,YAAI,OAAO,GAAG,EAAd;AACA,YAAI,OAAO,GAAG,EAAd;;AACA,YAAI,IAAI,KAAK,SAAb,EAAwB;AACpB;AACA;AACA,UAAA,SAAS,GAAG,IAAI,MAAJ,CAAW,aAAX,CAAZ;AACA,UAAA,QAAQ,GAAG,IAAI,MAAJ,CAAW,YAAX,CAAX;AACA,UAAA,OAAO,GAAG,SAAO,UAAU,CAAC,MAAX,CAAkB,WAAlB,CAAjB;AACA,UAAA,OAAO,GAAG,OAAK,SAAL,GAAiB,QAAjB,GAA4B,OAAtC;AACH,SAPD,MAOO;AACH;AACA,UAAA,SAAS,GAAG,CAAA,OAAK,MAAM,CAAC,QAAP,CAAgB,WAAA,CAAA,SAAA,CAAU,QAA1B,CAAL,EAA2C,MAA3C,CAAkD,aAAlD,CAAZ;AACA,UAAA,QAAQ,GAAG,OAAO,CACb,cADM,CAEH,OAAO,CAAC,WAAR,CACI,KAAK,CAAC,QAAN,GAAiB,KAAjB,CAAuB,iBAAvB,EAA0C,WAAA,CAAA,SAAA,CAAU,uBAApD,CADJ,CAFG,EAMN,MANM,CAMC,YAND,CAAX;;AAOA,cAAI,KAAK,YAAY,KAAA,CAAA,gBAArB,EAAuC;AACnC,YAAA,OAAO,GAAG,SAAO,UAAU,CAAC,MAAX,CAAkB,WAAlB,CAAjB;AACA,YAAA,OAAO,GAAG,OAAK,SAAL,GAAiB,QAAjB,GAA4B,OAAtC;AACH,WAHD,MAGO;AACH,YAAA,OAAO,GAAG,SAAO,UAAU,CAAC,MAAX,CAAkB,WAAlB,CAAjB;AACA,YAAA,OAAO,GAAG,KAAG,SAAH,GAAe,QAAf,GAA0B,OAApC;AACH;AACJ,SAnCyB,CAoC1B;;;AACA,aAAK,IAAI,CAAC,GAAG,WAAA,CAAA,SAAA,CAAU,uBAAvB,EAAgD,CAAC,GAAG,IAApD,EAA0D,CAAC,IAAI,WAAA,CAAA,SAAA,CAAU,uBAAzE,EAAkG;AAC9F,UAAA,SAAS,GAAG,CAAA,OAAK,CAAC,MAAM,GAAG,CAAV,EAAa,QAAb,CAAsB,WAAA,CAAA,SAAA,CAAU,QAAhC,CAAL,EAAiD,MAAjD,CAAwD,aAAxD,CAAZ;AACA,UAAA,QAAQ,GAAG,OAAO,CACb,cADM,CAEH,OAAO,CAAC,WAAR,CAAoB,KAAK,CAAC,QAAN,GAAiB,KAAjB,CAAuB,CAAvB,EAA0B,CAAC,GAAG,WAAA,CAAA,SAAA,CAAU,uBAAxC,CAApB,CAFG,EAIN,MAJM,CAIC,YAJD,CAAX;AAKA,UAAA,OAAO,GAAG,IAAI,MAAJ,CAAW,WAAX,CAAV;AACA,UAAA,OAAO,GAAM,OAAO,GAAA,IAAP,GAAY,SAAZ,GAAwB,QAAxB,GAAmC,OAAhD;AACH,SA9CyB,CA+C1B;;;AACA,QAAA,QAAQ,GAAM,QAAQ,GAAA,IAAR,GAAa,OAA3B;AACA,QAAA,MAAM,IAAI,IAAV;AACH;;;;;;;;;;;;;AACD,WAAO,QAAP;AACH,GApEO;;AAqEZ,SAAA,QAAA;AAAC,CAzOD,EAAA;;AAAa,OAAA,CAAA,QAAA,GAAA,QAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ethUtil = require(\"ethereumjs-util\");\nvar _ = require(\"lodash\");\nvar constants_1 = require(\"../utils/constants\");\nvar pointer_1 = require(\"./blocks/pointer\");\nvar set_1 = require(\"./blocks/set\");\nvar iterator_1 = require(\"./iterator\");\nvar Calldata = /** @class */ (function () {\n    function Calldata(rules) {\n        this._rules = rules;\n        this._selector = '';\n        this._root = undefined;\n    }\n    /**\n     * Sets the root calldata block. This block usually corresponds to a Method.\n     */\n    Calldata.prototype.setRoot = function (block) {\n        this._root = block;\n    };\n    /**\n     * Sets the selector to be prepended onto the calldata.\n     * If the root block was created by a Method then a selector will likely be set.\n     */\n    Calldata.prototype.setSelector = function (selector) {\n        if (!_.startsWith(selector, '0x')) {\n            throw new Error(\"Expected selector to be hex. Missing prefix '0x'\");\n        }\n        else if (selector.length !== constants_1.constants.HEX_SELECTOR_LENGTH_IN_CHARS) {\n            throw new Error(\"Invalid selector '\" + selector + \"'\");\n        }\n        this._selector = selector;\n    };\n    /**\n     * Iterates through the calldata blocks, starting from the root block, to construct calldata as a hex string.\n     * If the `optimize` flag is set then this calldata will be condensed, to save gas.\n     * If the `annotate` flag is set then this will return human-readable calldata.\n     * If the `annotate` flag is *not* set then this will return EVM-compatible calldata.\n     */\n    Calldata.prototype.toString = function () {\n        var e_1, _a;\n        // Sanity check: root block must be set\n        if (this._root === undefined) {\n            throw new Error('expected root');\n        }\n        // Optimize, if flag set\n        if (this._rules.shouldOptimize) {\n            this._optimize();\n        }\n        // Set offsets\n        var iterator = new iterator_1.CalldataIterator(this._root);\n        var offset = 0;\n        try {\n            for (var iterator_2 = __values(iterator), iterator_2_1 = iterator_2.next(); !iterator_2_1.done; iterator_2_1 = iterator_2.next()) {\n                var block = iterator_2_1.value;\n                block.setOffset(offset);\n                offset += block.getSizeInBytes();\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (iterator_2_1 && !iterator_2_1.done && (_a = iterator_2.return)) _a.call(iterator_2);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        // Generate hex string\n        var hexString = this._rules.shouldAnnotate\n            ? this._toHumanReadableCallData()\n            : this._toEvmCompatibeCallDataHex();\n        return hexString;\n    };\n    /**\n     * There are three types of calldata blocks: Blob, Set and Pointer.\n     * Scenarios arise where distinct pointers resolve to identical values.\n     * We optimize by keeping only one such instance of the identical value, and redirecting all pointers here.\n     * We keep the last such duplicate value because pointers can only be positive (they cannot point backwards).\n     *\n     * Example #1:\n     *  function f(string[], string[])\n     *  f([\"foo\", \"bar\", \"blitz\"], [\"foo\", \"bar\", \"blitz\"])\n     *  The array [\"foo\", \"bar\", \"blitz\"] will only be included in the calldata once.\n     *\n     * Example #2:\n     *  function f(string[], string)\n     *  f([\"foo\", \"bar\", \"blitz\"], \"foo\")\n     *  The string \"foo\" will only be included in the calldata once.\n     *\n     * Example #3:\n     *  function f((string, uint, bytes), string, uint, bytes)\n     *  f((\"foo\", 5, \"0x05\"), \"foo\", 5, \"0x05\")\n     *  The string \"foo\" and bytes \"0x05\" will only be included in the calldata once.\n     *  The duplicate `uint 5` values cannot be optimized out because they are static values (no pointer points to them).\n     *\n     * @TODO #1:\n     *   This optimization strategy handles blocks that are exact duplicates of one another.\n     *   But what if some block is a combination of two other blocks? Or a subset of another block?\n     *   This optimization problem is not much different from the current implemetation.\n     *   Instead of tracking \"observed\" hashes, at each node we would simply do pattern-matching on the calldata.\n     *   This strategy would be applied after assigning offsets to the tree, rather than before (as in this strategy).\n     *   Note that one consequence of this strategy is pointers may resolve to offsets that are not word-aligned.\n     *   This shouldn't be a problem but further investigation should be done.\n     *\n     * @TODO #2:\n     *   To be done as a follow-up to @TODO #1.\n     *   Since we optimize from the bottom-up, we could be affecting the outcome of a later potential optimization.\n     *   For example, what if by removing one duplicate value we miss out on optimizing another block higher in the tree.\n     *   To handle this case, at each node we can store a candidate optimization in a priority queue (sorted by calldata size).\n     *   At the end of traversing the tree, the candidate at the front of the queue will be the most optimal output.\n     *\n     */\n    Calldata.prototype._optimize = function () {\n        var e_2, _a;\n        // Step 1/1 Create a reverse iterator (starts from the end of the calldata to the beginning)\n        if (this._root === undefined) {\n            throw new Error('expected root');\n        }\n        var iterator = new iterator_1.ReverseCalldataIterator(this._root);\n        // Step 2/2 Iterate over each block, keeping track of which blocks have been seen and pruning redundant blocks.\n        var blocksByHash = {};\n        try {\n            for (var iterator_3 = __values(iterator), iterator_3_1 = iterator_3.next(); !iterator_3_1.done; iterator_3_1 = iterator_3.next()) {\n                var block = iterator_3_1.value;\n                // If a block is a pointer and its value has already been observed, then update\n                // the pointer to resolve to the existing value.\n                if (block instanceof pointer_1.PointerCalldataBlock) {\n                    var dependencyBlockHashBuf = block.getDependency().computeHash();\n                    var dependencyBlockHash = ethUtil.bufferToHex(dependencyBlockHashBuf);\n                    if (dependencyBlockHash in blocksByHash) {\n                        var blockWithSameHash = blocksByHash[dependencyBlockHash];\n                        if (blockWithSameHash !== block.getDependency()) {\n                            block.setAlias(blockWithSameHash);\n                        }\n                    }\n                    continue;\n                }\n                // This block has not been seen. Record its hash.\n                var blockHashBuf = block.computeHash();\n                var blockHash = ethUtil.bufferToHex(blockHashBuf);\n                if (!(blockHash in blocksByHash)) {\n                    blocksByHash[blockHash] = block;\n                }\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (iterator_3_1 && !iterator_3_1.done && (_a = iterator_3.return)) _a.call(iterator_3);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n    };\n    Calldata.prototype._toEvmCompatibeCallDataHex = function () {\n        var e_3, _a;\n        // Sanity check: must have a root block.\n        if (this._root === undefined) {\n            throw new Error('expected root');\n        }\n        // Construct an array of buffers (one buffer for each block).\n        var selectorBuffer = ethUtil.toBuffer(this._selector);\n        var valueBufs = [selectorBuffer];\n        var iterator = new iterator_1.CalldataIterator(this._root);\n        try {\n            for (var iterator_4 = __values(iterator), iterator_4_1 = iterator_4.next(); !iterator_4_1.done; iterator_4_1 = iterator_4.next()) {\n                var block = iterator_4_1.value;\n                valueBufs.push(block.toBuffer());\n            }\n        }\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n        finally {\n            try {\n                if (iterator_4_1 && !iterator_4_1.done && (_a = iterator_4.return)) _a.call(iterator_4);\n            }\n            finally { if (e_3) throw e_3.error; }\n        }\n        // Create hex from buffer array.\n        var combinedBuffers = Buffer.concat(valueBufs);\n        var hexValue = ethUtil.bufferToHex(combinedBuffers);\n        return hexValue;\n    };\n    /**\n     * Returns human-readable calldata.\n     *\n     * Example:\n     *   simpleFunction(string[], string[])\n     *   strings = [\"Hello\", \"World\"]\n     *   simpleFunction(strings, strings)\n     *\n     * Output:\n     *   0xbb4f12e3\n     *                                                                                      ### simpleFunction\n     *   0x0       0000000000000000000000000000000000000000000000000000000000000040              ptr<array1> (alias for array2)\n     *   0x20      0000000000000000000000000000000000000000000000000000000000000040              ptr<array2>\n     *\n     *   0x40      0000000000000000000000000000000000000000000000000000000000000002          ### array2\n     *   0x60      0000000000000000000000000000000000000000000000000000000000000040              ptr<array2[0]>\n     *   0x80      0000000000000000000000000000000000000000000000000000000000000080              ptr<array2[1]>\n     *   0xa0      0000000000000000000000000000000000000000000000000000000000000005              array2[0]\n     *   0xc0      48656c6c6f000000000000000000000000000000000000000000000000000000\n     *   0xe0      0000000000000000000000000000000000000000000000000000000000000005              array2[1]\n     *   0x100     576f726c64000000000000000000000000000000000000000000000000000000\n     */\n    Calldata.prototype._toHumanReadableCallData = function () {\n        var e_4, _a;\n        // Sanity check: must have a root block.\n        if (this._root === undefined) {\n            throw new Error('expected root');\n        }\n        // Constants for constructing annotated string\n        var offsetPadding = 10;\n        var valuePadding = 74;\n        var namePadding = 80;\n        var evmWordStartIndex = 0;\n        var emptySize = 0;\n        // Construct annotated calldata\n        var hexValue = \"\" + this._selector;\n        var offset = 0;\n        var functionName = this._root.getName();\n        var iterator = new iterator_1.CalldataIterator(this._root);\n        try {\n            for (var iterator_5 = __values(iterator), iterator_5_1 = iterator_5.next(); !iterator_5_1.done; iterator_5_1 = iterator_5.next()) {\n                var block = iterator_5_1.value;\n                // Process each block 1 word at a time\n                var size = block.getSizeInBytes();\n                var name_1 = block.getName();\n                var parentName = block.getParentName();\n                var prettyName = name_1.replace(parentName + \".\", '').replace(functionName + \".\", '');\n                // Resulting line will be <offsetStr><valueStr><nameStr>\n                var offsetStr = '';\n                var valueStr = '';\n                var nameStr = '';\n                var lineStr = '';\n                if (size === emptySize) {\n                    // This is a Set block with no header.\n                    // For example, a tuple or an array with a defined length.\n                    offsetStr = ' '.repeat(offsetPadding);\n                    valueStr = ' '.repeat(valuePadding);\n                    nameStr = \"### \" + prettyName.padEnd(namePadding);\n                    lineStr = \"\\n\" + offsetStr + valueStr + nameStr;\n                }\n                else {\n                    // This block has at least one word of value.\n                    offsetStr = (\"0x\" + offset.toString(constants_1.constants.HEX_BASE)).padEnd(offsetPadding);\n                    valueStr = ethUtil\n                        .stripHexPrefix(ethUtil.bufferToHex(block.toBuffer().slice(evmWordStartIndex, constants_1.constants.EVM_WORD_WIDTH_IN_BYTES)))\n                        .padEnd(valuePadding);\n                    if (block instanceof set_1.SetCalldataBlock) {\n                        nameStr = \"### \" + prettyName.padEnd(namePadding);\n                        lineStr = \"\\n\" + offsetStr + valueStr + nameStr;\n                    }\n                    else {\n                        nameStr = \"    \" + prettyName.padEnd(namePadding);\n                        lineStr = \"\" + offsetStr + valueStr + nameStr;\n                    }\n                }\n                // This block has a value that is more than 1 word.\n                for (var j = constants_1.constants.EVM_WORD_WIDTH_IN_BYTES; j < size; j += constants_1.constants.EVM_WORD_WIDTH_IN_BYTES) {\n                    offsetStr = (\"0x\" + (offset + j).toString(constants_1.constants.HEX_BASE)).padEnd(offsetPadding);\n                    valueStr = ethUtil\n                        .stripHexPrefix(ethUtil.bufferToHex(block.toBuffer().slice(j, j + constants_1.constants.EVM_WORD_WIDTH_IN_BYTES)))\n                        .padEnd(valuePadding);\n                    nameStr = ' '.repeat(namePadding);\n                    lineStr = lineStr + \"\\n\" + offsetStr + valueStr + nameStr;\n                }\n                // Append to hex value\n                hexValue = hexValue + \"\\n\" + lineStr;\n                offset += size;\n            }\n        }\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\n        finally {\n            try {\n                if (iterator_5_1 && !iterator_5_1.done && (_a = iterator_5.return)) _a.call(iterator_5);\n            }\n            finally { if (e_4) throw e_4.error; }\n        }\n        return hexValue;\n    };\n    return Calldata;\n}());\nexports.Calldata = Calldata;\n//# sourceMappingURL=calldata.js.map"]},"metadata":{},"sourceType":"script"}