{"ast":null,"code":"var _jsxFileName = \"/Users/kerp/Documents/GitHub/landing-page/src/contexts/Balances.tsx\";\nimport React, { createContext, useContext, useReducer, useState, useRef, useMemo, useCallback, useEffect } from 'react';\nimport { BigNumber } from '@uniswap/sdk';\nimport { ethers } from 'ethers';\nimport { useWeb3React, useDebounce } from '../hooks';\nimport { getEtherBalance, getTokenBalance, isAddress } from '../utils';\nimport { useBlockNumber } from './Application';\nimport { useTokenDetails, useAllTokenDetails } from './Tokens';\nimport { getUSDPrice } from '../utils/price';\nconst LOCAL_STORAGE_KEY = 'BALANCES';\nconst SHORT_BLOCK_TIMEOUT = 60 * 2 / 15; // in seconds, represented as a block number delta\n\nconst LONG_BLOCK_TIMEOUT = 60 * 15 / 15; // in seconds, represented as a block number delta\n\nconst EXCHANGES_BLOCK_TIMEOUT = 60 * 5 / 15; // in seconds, represented as a block number delta\n\nfunction initialize() {\n  try {\n    return JSON.parse(window.localStorage.getItem(LOCAL_STORAGE_KEY));\n  } catch {\n    return {};\n  }\n}\n\nvar Action;\n\n(function (Action) {\n  Action[Action[\"START_LISTENING\"] = 0] = \"START_LISTENING\";\n  Action[Action[\"STOP_LISTENING\"] = 1] = \"STOP_LISTENING\";\n  Action[Action[\"UPDATE\"] = 2] = \"UPDATE\";\n  Action[Action[\"BATCH_UPDATE_ACCOUNT\"] = 3] = \"BATCH_UPDATE_ACCOUNT\";\n  Action[Action[\"BATCH_UPDATE_EXCHANGES\"] = 4] = \"BATCH_UPDATE_EXCHANGES\";\n})(Action || (Action = {}));\n\nfunction reducer(state, {\n  type,\n  payload\n}) {\n  switch (type) {\n    case Action.START_LISTENING:\n      {\n        var _state$chainId, _state$chainId$addres, _state$chainId2;\n\n        const {\n          chainId,\n          address,\n          tokenAddress\n        } = payload;\n        const uninitialized = !!!(state === null || state === void 0 ? void 0 : (_state$chainId = state[chainId]) === null || _state$chainId === void 0 ? void 0 : (_state$chainId$addres = _state$chainId[address]) === null || _state$chainId$addres === void 0 ? void 0 : _state$chainId$addres[tokenAddress]);\n        return { ...state,\n          [chainId]: { ...(state === null || state === void 0 ? void 0 : state[chainId]),\n            [address]: { ...(state === null || state === void 0 ? void 0 : (_state$chainId2 = state[chainId]) === null || _state$chainId2 === void 0 ? void 0 : _state$chainId2[address]),\n              [tokenAddress]: uninitialized ? {\n                listenerCount: 1\n              } : { ...state[chainId][address][tokenAddress],\n                listenerCount: state[chainId][address][tokenAddress].listenerCount + 1\n              }\n            }\n          }\n        };\n      }\n\n    case Action.STOP_LISTENING:\n      {\n        var _state$chainId3, _state$chainId4, _state$chainId4$addre;\n\n        const {\n          chainId,\n          address,\n          tokenAddress\n        } = payload;\n        return { ...state,\n          [chainId]: { ...(state === null || state === void 0 ? void 0 : state[chainId]),\n            [address]: { ...(state === null || state === void 0 ? void 0 : (_state$chainId3 = state[chainId]) === null || _state$chainId3 === void 0 ? void 0 : _state$chainId3[address]),\n              [tokenAddress]: { ...(state === null || state === void 0 ? void 0 : (_state$chainId4 = state[chainId]) === null || _state$chainId4 === void 0 ? void 0 : (_state$chainId4$addre = _state$chainId4[address]) === null || _state$chainId4$addre === void 0 ? void 0 : _state$chainId4$addre[tokenAddress]),\n                listenerCount: state[chainId][address][tokenAddress].listenerCount - 1\n              }\n            }\n          }\n        };\n      }\n\n    case Action.UPDATE:\n      {\n        var _state$chainId5, _state$chainId6, _state$chainId6$addre;\n\n        const {\n          chainId,\n          address,\n          tokenAddress,\n          value,\n          blockNumber\n        } = payload;\n        return { ...state,\n          [chainId]: { ...(state === null || state === void 0 ? void 0 : state[chainId]),\n            [address]: { ...(state === null || state === void 0 ? void 0 : (_state$chainId5 = state[chainId]) === null || _state$chainId5 === void 0 ? void 0 : _state$chainId5[address]),\n              [tokenAddress]: { ...(state === null || state === void 0 ? void 0 : (_state$chainId6 = state[chainId]) === null || _state$chainId6 === void 0 ? void 0 : (_state$chainId6$addre = _state$chainId6[address]) === null || _state$chainId6$addre === void 0 ? void 0 : _state$chainId6$addre[tokenAddress]),\n                value,\n                blockNumber\n              }\n            }\n          }\n        };\n      }\n\n    case Action.BATCH_UPDATE_ACCOUNT:\n      {\n        var _state$chainId7;\n\n        const {\n          chainId,\n          address,\n          tokenAddresses,\n          values,\n          blockNumber\n        } = payload;\n        return { ...state,\n          [chainId]: { ...(state === null || state === void 0 ? void 0 : state[chainId]),\n            [address]: { ...(state === null || state === void 0 ? void 0 : (_state$chainId7 = state[chainId]) === null || _state$chainId7 === void 0 ? void 0 : _state$chainId7[address]),\n              ...tokenAddresses.reduce((accumulator, tokenAddress, i) => {\n                var _state$chainId8, _state$chainId8$addre;\n\n                const value = values[i];\n                accumulator[tokenAddress] = { ...(state === null || state === void 0 ? void 0 : (_state$chainId8 = state[chainId]) === null || _state$chainId8 === void 0 ? void 0 : (_state$chainId8$addre = _state$chainId8[address]) === null || _state$chainId8$addre === void 0 ? void 0 : _state$chainId8$addre[tokenAddress]),\n                  value,\n                  blockNumber\n                };\n                return accumulator;\n              }, {})\n            }\n          }\n        };\n      }\n\n    case Action.BATCH_UPDATE_EXCHANGES:\n      {\n        const {\n          chainId,\n          exchangeAddresses,\n          tokenAddresses,\n          values,\n          blockNumber\n        } = payload;\n        return { ...state,\n          [chainId]: { ...(state === null || state === void 0 ? void 0 : state[chainId]),\n            ...exchangeAddresses.reduce((accumulator, exchangeAddress, i) => {\n              var _state$chainId9, _state$chainId10, _state$chainId10$exch;\n\n              const tokenAddress = tokenAddresses[i];\n              const value = values[i];\n              accumulator[exchangeAddress] = { ...(state === null || state === void 0 ? void 0 : (_state$chainId9 = state[chainId]) === null || _state$chainId9 === void 0 ? void 0 : _state$chainId9[exchangeAddress]),\n                ...(accumulator === null || accumulator === void 0 ? void 0 : accumulator[exchangeAddress]),\n                [tokenAddress]: { ...(state === null || state === void 0 ? void 0 : (_state$chainId10 = state[chainId]) === null || _state$chainId10 === void 0 ? void 0 : (_state$chainId10$exch = _state$chainId10[exchangeAddress]) === null || _state$chainId10$exch === void 0 ? void 0 : _state$chainId10$exch[tokenAddress]),\n                  value,\n                  blockNumber\n                }\n              };\n              return accumulator;\n            }, {})\n          }\n        };\n      }\n\n    default:\n      {\n        throw Error(`Unexpected action type in BalancesContext reducer: '${type}'.`);\n      }\n  }\n}\n\nconst BalancesContext = createContext([{}, {}]);\n\nfunction useBalancesContext() {\n  return useContext(BalancesContext);\n}\n\nexport default function Provider({\n  children\n}) {\n  const [state, dispatch] = useReducer(reducer, undefined, initialize);\n  const startListening = useCallback((chainId, address, tokenAddress) => {\n    dispatch({\n      type: Action.START_LISTENING,\n      payload: {\n        chainId,\n        address,\n        tokenAddress\n      }\n    });\n  }, []);\n  const stopListening = useCallback((chainId, address, tokenAddress) => {\n    dispatch({\n      type: Action.STOP_LISTENING,\n      payload: {\n        chainId,\n        address,\n        tokenAddress\n      }\n    });\n  }, []);\n  const update = useCallback((chainId, address, tokenAddress, value, blockNumber) => {\n    dispatch({\n      type: Action.UPDATE,\n      payload: {\n        chainId,\n        address,\n        tokenAddress,\n        value,\n        blockNumber\n      }\n    });\n  }, []);\n  const batchUpdateAccount = useCallback((chainId, address, tokenAddresses, values, blockNumber) => {\n    dispatch({\n      type: Action.BATCH_UPDATE_ACCOUNT,\n      payload: {\n        chainId,\n        address,\n        tokenAddresses,\n        values,\n        blockNumber\n      }\n    });\n  }, []);\n  const batchUpdateExchanges = useCallback((chainId, exchangeAddresses, tokenAddresses, values, blockNumber) => {\n    dispatch({\n      type: Action.BATCH_UPDATE_EXCHANGES,\n      payload: {\n        chainId,\n        exchangeAddresses,\n        tokenAddresses,\n        values,\n        blockNumber\n      }\n    });\n  }, []);\n  return /*#__PURE__*/React.createElement(BalancesContext.Provider, {\n    value: useMemo(() => [state, {\n      startListening,\n      stopListening,\n      update,\n      batchUpdateAccount,\n      batchUpdateExchanges\n    }], [state, startListening, stopListening, update, batchUpdateAccount, batchUpdateExchanges]),\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 195,\n      columnNumber: 5\n    }\n  }, children);\n}\nexport function Updater() {\n  const {\n    chainId,\n    account,\n    library\n  } = useWeb3React();\n  const blockNumber = useBlockNumber();\n  const [state, {\n    update,\n    batchUpdateAccount,\n    batchUpdateExchanges\n  }] = useBalancesContext(); // debounce state a little bit to prevent useEffect craziness\n\n  const debouncedState = useDebounce(state, 1000); // cache this debounced state in localstorage\n\n  useEffect(() => {\n    window.localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(debouncedState));\n  }, [debouncedState]); // (slightly janky) balances-wide cache to prevent double/triple/etc. fetching\n\n  const fetchedAsOfCache = useRef({}); // generic balances fetcher abstracting away difference between fetching ETH + token balances\n\n  const fetchBalance = useCallback((address, tokenAddress) => (tokenAddress === 'ETH' ? getEtherBalance(address, library) : getTokenBalance(tokenAddress, address, library)).then(value => {\n    return value.toString();\n  }).catch(() => {\n    return null;\n  }), [library]); // ensure that all balances with >=1 listeners are updated every block\n\n  useEffect(() => {\n    if (typeof chainId === 'number' && typeof blockNumber === 'number') {\n      for (const address of Object.keys((_debouncedState$chain = debouncedState === null || debouncedState === void 0 ? void 0 : debouncedState[chainId]) !== null && _debouncedState$chain !== void 0 ? _debouncedState$chain : {})) {\n        var _debouncedState$chain;\n\n        for (const tokenAddress of Object.keys(debouncedState === null || debouncedState === void 0 ? void 0 : debouncedState[chainId][address])) {\n          const active = debouncedState[chainId][address][tokenAddress].listenerCount > 0;\n\n          if (active) {\n            var _fetchedAsOfCache$cur, _fetchedAsOfCache$cur2, _fetchedAsOfCache$cur3, _debouncedState$chain2, _debouncedState$chain3;\n\n            const cachedFetchedAsOf = (_fetchedAsOfCache$cur = fetchedAsOfCache.current) === null || _fetchedAsOfCache$cur === void 0 ? void 0 : (_fetchedAsOfCache$cur2 = _fetchedAsOfCache$cur[chainId]) === null || _fetchedAsOfCache$cur2 === void 0 ? void 0 : (_fetchedAsOfCache$cur3 = _fetchedAsOfCache$cur2[address]) === null || _fetchedAsOfCache$cur3 === void 0 ? void 0 : _fetchedAsOfCache$cur3[tokenAddress];\n            const fetchedAsOf = (_debouncedState$chain2 = (_debouncedState$chain3 = debouncedState[chainId][address][tokenAddress]) === null || _debouncedState$chain3 === void 0 ? void 0 : _debouncedState$chain3.blockNumber) !== null && _debouncedState$chain2 !== void 0 ? _debouncedState$chain2 : cachedFetchedAsOf;\n\n            if (fetchedAsOf !== blockNumber) {\n              var _fetchedAsOfCache$cur4, _fetchedAsOfCache$cur5, _fetchedAsOfCache$cur6;\n\n              // fetch the balance...\n              fetchBalance(address, tokenAddress).then(value => {\n                update(chainId, address, tokenAddress, value, blockNumber);\n              }); // ...and cache the fetch\n\n              fetchedAsOfCache.current = { ...fetchedAsOfCache.current,\n                [chainId]: { ...((_fetchedAsOfCache$cur4 = fetchedAsOfCache.current) === null || _fetchedAsOfCache$cur4 === void 0 ? void 0 : _fetchedAsOfCache$cur4[chainId]),\n                  [address]: { ...((_fetchedAsOfCache$cur5 = fetchedAsOfCache.current) === null || _fetchedAsOfCache$cur5 === void 0 ? void 0 : (_fetchedAsOfCache$cur6 = _fetchedAsOfCache$cur5[chainId]) === null || _fetchedAsOfCache$cur6 === void 0 ? void 0 : _fetchedAsOfCache$cur6[address]),\n                    [tokenAddress]: blockNumber\n                  }\n                }\n              };\n            }\n          }\n        }\n      }\n    }\n  }, [chainId, blockNumber, debouncedState, fetchBalance, update]); // get a state ref for batch updates\n\n  const stateRef = useRef(state);\n  useEffect(() => {\n    stateRef.current = state;\n  }, [state]);\n  const allTokenDetails = useAllTokenDetails(); // ensure that we have the user balances for all tokens\n\n  const allTokens = useMemo(() => Object.keys(allTokenDetails), [allTokenDetails]);\n  useEffect(() => {\n    if (typeof chainId === 'number' && typeof account === 'string' && typeof blockNumber === 'number') {\n      Promise.all(allTokens.filter(tokenAddress => {\n        var _stateRef$current, _stateRef$current$cha, _stateRef$current$cha2, _stateRef$current$cha3, _fetchedAsOfCache$cur7, _fetchedAsOfCache$cur8, _fetchedAsOfCache$cur9, _stateRef$current$cha4, _stateRef$current2, _stateRef$current2$ch, _stateRef$current2$ch2, _stateRef$current2$ch3;\n\n        const hasValue = !!((_stateRef$current = stateRef.current) === null || _stateRef$current === void 0 ? void 0 : (_stateRef$current$cha = _stateRef$current[chainId]) === null || _stateRef$current$cha === void 0 ? void 0 : (_stateRef$current$cha2 = _stateRef$current$cha[account]) === null || _stateRef$current$cha2 === void 0 ? void 0 : (_stateRef$current$cha3 = _stateRef$current$cha2[tokenAddress]) === null || _stateRef$current$cha3 === void 0 ? void 0 : _stateRef$current$cha3.value);\n        const cachedFetchedAsOf = (_fetchedAsOfCache$cur7 = fetchedAsOfCache.current) === null || _fetchedAsOfCache$cur7 === void 0 ? void 0 : (_fetchedAsOfCache$cur8 = _fetchedAsOfCache$cur7[chainId]) === null || _fetchedAsOfCache$cur8 === void 0 ? void 0 : (_fetchedAsOfCache$cur9 = _fetchedAsOfCache$cur8[account]) === null || _fetchedAsOfCache$cur9 === void 0 ? void 0 : _fetchedAsOfCache$cur9[tokenAddress];\n        const fetchedAsOf = (_stateRef$current$cha4 = (_stateRef$current2 = stateRef.current) === null || _stateRef$current2 === void 0 ? void 0 : (_stateRef$current2$ch = _stateRef$current2[chainId]) === null || _stateRef$current2$ch === void 0 ? void 0 : (_stateRef$current2$ch2 = _stateRef$current2$ch[account]) === null || _stateRef$current2$ch2 === void 0 ? void 0 : (_stateRef$current2$ch3 = _stateRef$current2$ch2[tokenAddress]) === null || _stateRef$current2$ch3 === void 0 ? void 0 : _stateRef$current2$ch3.blockNumber) !== null && _stateRef$current$cha4 !== void 0 ? _stateRef$current$cha4 : cachedFetchedAsOf; // if there's no value, and it's not being fetched, we need to fetch!\n\n        if (!hasValue && typeof cachedFetchedAsOf !== 'number') {\n          return true; // else, if there's a value, check if it's stale\n        } else if (hasValue) {\n          const blocksElapsedSinceLastCheck = blockNumber - fetchedAsOf;\n          const stale = blocksElapsedSinceLastCheck >= (stateRef.current[chainId][account][tokenAddress].value === '0' ? LONG_BLOCK_TIMEOUT : SHORT_BLOCK_TIMEOUT);\n          return stale;\n        } else {\n          return false;\n        }\n      }).map(async tokenAddress => {\n        var _fetchedAsOfCache$cur10, _fetchedAsOfCache$cur11, _fetchedAsOfCache$cur12;\n\n        fetchedAsOfCache.current = { ...fetchedAsOfCache.current,\n          [chainId]: { ...((_fetchedAsOfCache$cur10 = fetchedAsOfCache.current) === null || _fetchedAsOfCache$cur10 === void 0 ? void 0 : _fetchedAsOfCache$cur10[chainId]),\n            [account]: { ...((_fetchedAsOfCache$cur11 = fetchedAsOfCache.current) === null || _fetchedAsOfCache$cur11 === void 0 ? void 0 : (_fetchedAsOfCache$cur12 = _fetchedAsOfCache$cur11[chainId]) === null || _fetchedAsOfCache$cur12 === void 0 ? void 0 : _fetchedAsOfCache$cur12[account]),\n              [tokenAddress]: blockNumber\n            }\n          }\n        };\n        return fetchBalance(account, tokenAddress).then(value => ({\n          tokenAddress,\n          value\n        }));\n      })).then(results => {\n        batchUpdateAccount(chainId, account, results.map(result => result.tokenAddress), results.map(result => result.value), blockNumber);\n      });\n    }\n  }, [chainId, account, blockNumber, allTokens, fetchBalance, batchUpdateAccount]); // ensure that we have the eth and token balances for all exchanges\n\n  const allExchanges = useMemo(() => Object.keys(allTokenDetails).filter(tokenAddress => tokenAddress !== 'ETH').map(tokenAddress => ({\n    tokenAddress,\n    exchangeAddress: allTokenDetails[tokenAddress].exchangeAddress\n  })), [allTokenDetails]);\n  useEffect(() => {\n    if (typeof chainId === 'number' && typeof blockNumber === 'number') {\n      Promise.all(allExchanges.filter(({\n        exchangeAddress,\n        tokenAddress\n      }) => {\n        var _stateRef$current3, _stateRef$current3$ch, _stateRef$current3$ch2, _stateRef$current3$ch3, _stateRef$current4, _stateRef$current4$ch, _stateRef$current4$ch2, _stateRef$current4$ch3, _fetchedAsOfCache$cur13, _fetchedAsOfCache$cur14, _fetchedAsOfCache$cur15, _fetchedAsOfCache$cur16, _fetchedAsOfCache$cur17, _fetchedAsOfCache$cur18, _stateRef$current$cha5, _stateRef$current5, _stateRef$current5$ch, _stateRef$current5$ch2, _stateRef$current5$ch3, _stateRef$current$cha6, _stateRef$current6, _stateRef$current6$ch, _stateRef$current6$ch2, _stateRef$current6$ch3;\n\n        const hasValueToken = !!((_stateRef$current3 = stateRef.current) === null || _stateRef$current3 === void 0 ? void 0 : (_stateRef$current3$ch = _stateRef$current3[chainId]) === null || _stateRef$current3$ch === void 0 ? void 0 : (_stateRef$current3$ch2 = _stateRef$current3$ch[exchangeAddress]) === null || _stateRef$current3$ch2 === void 0 ? void 0 : (_stateRef$current3$ch3 = _stateRef$current3$ch2[tokenAddress]) === null || _stateRef$current3$ch3 === void 0 ? void 0 : _stateRef$current3$ch3.value);\n        const hasValueETH = !!((_stateRef$current4 = stateRef.current) === null || _stateRef$current4 === void 0 ? void 0 : (_stateRef$current4$ch = _stateRef$current4[chainId]) === null || _stateRef$current4$ch === void 0 ? void 0 : (_stateRef$current4$ch2 = _stateRef$current4$ch[exchangeAddress]) === null || _stateRef$current4$ch2 === void 0 ? void 0 : (_stateRef$current4$ch3 = _stateRef$current4$ch2['ETH']) === null || _stateRef$current4$ch3 === void 0 ? void 0 : _stateRef$current4$ch3.value);\n        const cachedFetchedAsOfToken = (_fetchedAsOfCache$cur13 = fetchedAsOfCache.current) === null || _fetchedAsOfCache$cur13 === void 0 ? void 0 : (_fetchedAsOfCache$cur14 = _fetchedAsOfCache$cur13[chainId]) === null || _fetchedAsOfCache$cur14 === void 0 ? void 0 : (_fetchedAsOfCache$cur15 = _fetchedAsOfCache$cur14[exchangeAddress]) === null || _fetchedAsOfCache$cur15 === void 0 ? void 0 : _fetchedAsOfCache$cur15[tokenAddress];\n        const cachedFetchedAsOfETH = (_fetchedAsOfCache$cur16 = fetchedAsOfCache.current) === null || _fetchedAsOfCache$cur16 === void 0 ? void 0 : (_fetchedAsOfCache$cur17 = _fetchedAsOfCache$cur16[chainId]) === null || _fetchedAsOfCache$cur17 === void 0 ? void 0 : (_fetchedAsOfCache$cur18 = _fetchedAsOfCache$cur17[exchangeAddress]) === null || _fetchedAsOfCache$cur18 === void 0 ? void 0 : _fetchedAsOfCache$cur18['ETH'];\n        const fetchedAsOfToken = (_stateRef$current$cha5 = (_stateRef$current5 = stateRef.current) === null || _stateRef$current5 === void 0 ? void 0 : (_stateRef$current5$ch = _stateRef$current5[chainId]) === null || _stateRef$current5$ch === void 0 ? void 0 : (_stateRef$current5$ch2 = _stateRef$current5$ch[exchangeAddress]) === null || _stateRef$current5$ch2 === void 0 ? void 0 : (_stateRef$current5$ch3 = _stateRef$current5$ch2[tokenAddress]) === null || _stateRef$current5$ch3 === void 0 ? void 0 : _stateRef$current5$ch3.blockNumber) !== null && _stateRef$current$cha5 !== void 0 ? _stateRef$current$cha5 : cachedFetchedAsOfToken;\n        const fetchedAsOfETH = (_stateRef$current$cha6 = (_stateRef$current6 = stateRef.current) === null || _stateRef$current6 === void 0 ? void 0 : (_stateRef$current6$ch = _stateRef$current6[chainId]) === null || _stateRef$current6$ch === void 0 ? void 0 : (_stateRef$current6$ch2 = _stateRef$current6$ch[exchangeAddress]) === null || _stateRef$current6$ch2 === void 0 ? void 0 : (_stateRef$current6$ch3 = _stateRef$current6$ch2['ETH']) === null || _stateRef$current6$ch3 === void 0 ? void 0 : _stateRef$current6$ch3.blockNumber) !== null && _stateRef$current$cha6 !== void 0 ? _stateRef$current$cha6 : cachedFetchedAsOfETH; // if there's no values, and they're not being fetched, we need to fetch!\n\n        if ((!hasValueToken || !hasValueETH) && (typeof cachedFetchedAsOfToken !== 'number' || typeof cachedFetchedAsOfETH !== 'number')) {\n          return true; // else, if there are values, check if they's stale\n        } else if (hasValueToken && hasValueETH) {\n          const blocksElapsedSinceLastCheckToken = blockNumber - fetchedAsOfToken;\n          const blocksElapsedSinceLastCheckETH = blockNumber - fetchedAsOfETH;\n          const stale = fetchedAsOfToken !== fetchedAsOfETH || blocksElapsedSinceLastCheckToken >= EXCHANGES_BLOCK_TIMEOUT || blocksElapsedSinceLastCheckETH >= EXCHANGES_BLOCK_TIMEOUT;\n          return stale;\n        } else {\n          return false;\n        }\n      }).map(async ({\n        exchangeAddress,\n        tokenAddress\n      }) => {\n        var _fetchedAsOfCache$cur19, _fetchedAsOfCache$cur20, _fetchedAsOfCache$cur21;\n\n        fetchedAsOfCache.current = { ...fetchedAsOfCache.current,\n          [chainId]: { ...((_fetchedAsOfCache$cur19 = fetchedAsOfCache.current) === null || _fetchedAsOfCache$cur19 === void 0 ? void 0 : _fetchedAsOfCache$cur19[chainId]),\n            [exchangeAddress]: { ...((_fetchedAsOfCache$cur20 = fetchedAsOfCache.current) === null || _fetchedAsOfCache$cur20 === void 0 ? void 0 : (_fetchedAsOfCache$cur21 = _fetchedAsOfCache$cur20[chainId]) === null || _fetchedAsOfCache$cur21 === void 0 ? void 0 : _fetchedAsOfCache$cur21[exchangeAddress]),\n              [tokenAddress]: blockNumber,\n              ETH: blockNumber\n            }\n          }\n        };\n        return Promise.all([fetchBalance(exchangeAddress, tokenAddress), fetchBalance(exchangeAddress, 'ETH')]).then(([valueToken, valueETH]) => ({\n          exchangeAddress,\n          tokenAddress,\n          valueToken,\n          valueETH\n        }));\n      })).then(results => {\n        batchUpdateExchanges(chainId, results.flatMap(result => [result.exchangeAddress, result.exchangeAddress]), results.flatMap(result => [result.tokenAddress, 'ETH']), results.flatMap(result => [result.valueToken, result.valueETH]), blockNumber);\n      });\n    }\n  }, [chainId, account, blockNumber, allExchanges, fetchBalance, batchUpdateExchanges]);\n  return null;\n}\nexport function useAllBalances() {\n  const {\n    chainId\n  } = useWeb3React();\n  const [state] = useBalancesContext();\n  return useMemo(() => {\n    var _state$chainId11;\n\n    return typeof chainId === 'number' ? (_state$chainId11 = state === null || state === void 0 ? void 0 : state[chainId]) !== null && _state$chainId11 !== void 0 ? _state$chainId11 : {} : {};\n  }, [chainId, state]);\n}\nexport function useAddressBalance(address, tokenAddress) {\n  var _state$chainId12, _state$chainId12$addr, _state$chainId12$addr2;\n\n  const {\n    chainId\n  } = useWeb3React();\n  const [state, {\n    startListening,\n    stopListening\n  }] = useBalancesContext();\n  useEffect(() => {\n    if (typeof chainId === 'number' && isAddress(address) && isAddress(tokenAddress)) {\n      startListening(chainId, address, tokenAddress);\n      return () => {\n        stopListening(chainId, address, tokenAddress);\n      };\n    }\n  }, [chainId, address, tokenAddress, startListening, stopListening]);\n  const value = typeof chainId === 'number' ? state === null || state === void 0 ? void 0 : (_state$chainId12 = state[chainId]) === null || _state$chainId12 === void 0 ? void 0 : (_state$chainId12$addr = _state$chainId12[address]) === null || _state$chainId12$addr === void 0 ? void 0 : (_state$chainId12$addr2 = _state$chainId12$addr[tokenAddress]) === null || _state$chainId12$addr2 === void 0 ? void 0 : _state$chainId12$addr2.value : undefined;\n  return useMemo(() => typeof value === 'string' ? ethers.utils.bigNumberify(value) : value, [value]);\n}\nexport function useExchangeReserves(tokenAddress) {\n  const {\n    exchangeAddress\n  } = useTokenDetails(tokenAddress);\n  const reserveETH = useAddressBalance(exchangeAddress, 'ETH');\n  const reserveToken = useAddressBalance(exchangeAddress, tokenAddress);\n  return {\n    reserveETH,\n    reserveToken\n  };\n}\n\nconst buildReserveObject = (chainId, tokenAddress, ethReserveAmount, tokenReserveAmount, decimals) => ({\n  token: {\n    chainId,\n    address: tokenAddress,\n    decimals\n  },\n  ethReserve: {\n    token: {\n      chainId,\n      decimals: 18\n    },\n    amount: ethReserveAmount\n  },\n  tokenReserve: {\n    token: {\n      chainId,\n      address: tokenAddress,\n      decimals\n    },\n    amount: tokenReserveAmount\n  }\n});\n\nconst daiTokenAddress = '0x6B175474E89094C44Da98b954EedeAC495271d0F';\nconst daiExchangeAddress = '0x2a1530C4C41db0B0b2bB646CB5Eb1A67b7158667';\nconst usdcTokenAddress = '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48';\nconst usdcExchangeAddress = '0x97deC872013f6B5fB443861090ad931542878126';\nconst tusdTokenAddress = '0x0000000000085d4780B73119b644AE5ecd22b376';\nconst tusdExchangeAddress = '0x5048b9d01097498Fd72F3F14bC9Bc74A5aAc8fA7';\nexport function useETHPriceInUSD() {\n  const {\n    chainId\n  } = useWeb3React();\n  let daiReserveETH = useAddressBalance(daiExchangeAddress, 'ETH');\n  let daiReserveToken = useAddressBalance(daiExchangeAddress, daiTokenAddress);\n  let usdcReserveETH = useAddressBalance(usdcExchangeAddress, 'ETH');\n  let usdcReserveToken = useAddressBalance(usdcExchangeAddress, usdcTokenAddress);\n  let tusdReserveETH = useAddressBalance(tusdExchangeAddress, 'ETH');\n  let tusdReserveToken = useAddressBalance(tusdExchangeAddress, tusdTokenAddress);\n  const [price, setPrice] = useState();\n  useEffect(() => {\n    if (chainId && daiReserveETH && daiReserveToken && usdcReserveETH && usdcReserveToken && tusdReserveETH && tusdReserveToken) {\n      const daiReservesObject = buildReserveObject(chainId, daiTokenAddress, new BigNumber(daiReserveETH.toString()), new BigNumber(daiReserveToken.toString()), 18);\n      const tusdReservesObject = buildReserveObject(chainId, tusdTokenAddress, new BigNumber(tusdReserveETH.toString()), new BigNumber(tusdReserveToken.toString()), 18);\n      const usdcReservesObject = buildReserveObject(chainId, usdcTokenAddress, new BigNumber(usdcReserveETH.toString()), new BigNumber(usdcReserveToken.toString()), 6);\n      const stablecoinReserves = [daiReservesObject, usdcReservesObject, tusdReservesObject];\n\n      try {\n        setPrice(getUSDPrice(stablecoinReserves));\n      } catch {\n        setPrice(null);\n      }\n    }\n  }, [daiReserveETH, daiReserveToken, usdcReserveETH, usdcReserveToken, tusdReserveETH, tusdReserveToken, chainId]);\n  return price;\n}","map":{"version":3,"sources":["/Users/kerp/Documents/GitHub/landing-page/src/contexts/Balances.tsx"],"names":["React","createContext","useContext","useReducer","useState","useRef","useMemo","useCallback","useEffect","BigNumber","ethers","useWeb3React","useDebounce","getEtherBalance","getTokenBalance","isAddress","useBlockNumber","useTokenDetails","useAllTokenDetails","getUSDPrice","LOCAL_STORAGE_KEY","SHORT_BLOCK_TIMEOUT","LONG_BLOCK_TIMEOUT","EXCHANGES_BLOCK_TIMEOUT","initialize","JSON","parse","window","localStorage","getItem","Action","reducer","state","type","payload","START_LISTENING","chainId","address","tokenAddress","uninitialized","listenerCount","STOP_LISTENING","UPDATE","value","blockNumber","BATCH_UPDATE_ACCOUNT","tokenAddresses","values","reduce","accumulator","i","BATCH_UPDATE_EXCHANGES","exchangeAddresses","exchangeAddress","Error","BalancesContext","useBalancesContext","Provider","children","dispatch","undefined","startListening","stopListening","update","batchUpdateAccount","batchUpdateExchanges","Updater","account","library","debouncedState","setItem","stringify","fetchedAsOfCache","fetchBalance","then","toString","catch","Object","keys","active","cachedFetchedAsOf","current","fetchedAsOf","stateRef","allTokenDetails","allTokens","Promise","all","filter","hasValue","blocksElapsedSinceLastCheck","stale","map","results","result","allExchanges","hasValueToken","hasValueETH","cachedFetchedAsOfToken","cachedFetchedAsOfETH","fetchedAsOfToken","fetchedAsOfETH","blocksElapsedSinceLastCheckToken","blocksElapsedSinceLastCheckETH","ETH","valueToken","valueETH","flatMap","useAllBalances","useAddressBalance","utils","bigNumberify","useExchangeReserves","reserveETH","reserveToken","buildReserveObject","ethReserveAmount","tokenReserveAmount","decimals","token","ethReserve","amount","tokenReserve","daiTokenAddress","daiExchangeAddress","usdcTokenAddress","usdcExchangeAddress","tusdTokenAddress","tusdExchangeAddress","useETHPriceInUSD","daiReserveETH","daiReserveToken","usdcReserveETH","usdcReserveToken","tusdReserveETH","tusdReserveToken","price","setPrice","daiReservesObject","tusdReservesObject","usdcReservesObject","stablecoinReserves"],"mappings":"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","sourcesContent":["import React, {\n  createContext,\n  useContext,\n  useReducer,\n  useState,\n  useRef,\n  useMemo,\n  useCallback,\n  useEffect,\n  ReactNode\n} from 'react'\nimport { BigNumber } from '@uniswap/sdk'\nimport { ethers } from 'ethers'\n\nimport { useWeb3React, useDebounce } from '../hooks'\nimport { getEtherBalance, getTokenBalance, isAddress } from '../utils'\nimport { useBlockNumber } from './Application'\nimport { useTokenDetails, useAllTokenDetails } from './Tokens'\nimport { getUSDPrice } from '../utils/price'\n\nconst LOCAL_STORAGE_KEY = 'BALANCES'\nconst SHORT_BLOCK_TIMEOUT = (60 * 2) / 15 // in seconds, represented as a block number delta\nconst LONG_BLOCK_TIMEOUT = (60 * 15) / 15 // in seconds, represented as a block number delta\n\nconst EXCHANGES_BLOCK_TIMEOUT = (60 * 5) / 15 // in seconds, represented as a block number delta\n\ninterface BalancesState {\n  [chainId: number]: {\n    [address: string]: {\n      [tokenAddress: string]: {\n        value?: string | null\n        blockNumber?: number\n        listenerCount: number\n      }\n    }\n  }\n}\n\nfunction initialize(): BalancesState {\n  try {\n    return JSON.parse(window.localStorage.getItem(LOCAL_STORAGE_KEY) as string)\n  } catch {\n    return {}\n  }\n}\n\nenum Action {\n  START_LISTENING,\n  STOP_LISTENING,\n  UPDATE,\n  BATCH_UPDATE_ACCOUNT,\n  BATCH_UPDATE_EXCHANGES\n}\n\nfunction reducer(state: BalancesState, { type, payload }: { type: Action; payload: any }) {\n  switch (type) {\n    case Action.START_LISTENING: {\n      const { chainId, address, tokenAddress } = payload\n      const uninitialized = !!!state?.[chainId]?.[address]?.[tokenAddress]\n      return {\n        ...state,\n        [chainId]: {\n          ...state?.[chainId],\n          [address]: {\n            ...state?.[chainId]?.[address],\n            [tokenAddress]: uninitialized\n              ? {\n                  listenerCount: 1\n                }\n              : {\n                  ...state[chainId][address][tokenAddress],\n                  listenerCount: state[chainId][address][tokenAddress].listenerCount + 1\n                }\n          }\n        }\n      }\n    }\n    case Action.STOP_LISTENING: {\n      const { chainId, address, tokenAddress } = payload\n      return {\n        ...state,\n        [chainId]: {\n          ...state?.[chainId],\n          [address]: {\n            ...state?.[chainId]?.[address],\n            [tokenAddress]: {\n              ...state?.[chainId]?.[address]?.[tokenAddress],\n              listenerCount: state[chainId][address][tokenAddress].listenerCount - 1\n            }\n          }\n        }\n      }\n    }\n    case Action.UPDATE: {\n      const { chainId, address, tokenAddress, value, blockNumber } = payload\n      return {\n        ...state,\n        [chainId]: {\n          ...state?.[chainId],\n          [address]: {\n            ...state?.[chainId]?.[address],\n            [tokenAddress]: {\n              ...state?.[chainId]?.[address]?.[tokenAddress],\n              value,\n              blockNumber\n            }\n          }\n        }\n      }\n    }\n    case Action.BATCH_UPDATE_ACCOUNT: {\n      const { chainId, address, tokenAddresses, values, blockNumber } = payload\n      return {\n        ...state,\n        [chainId]: {\n          ...state?.[chainId],\n          [address]: {\n            ...state?.[chainId]?.[address],\n            ...tokenAddresses.reduce((accumulator: any, tokenAddress: string, i: number) => {\n              const value = values[i]\n              accumulator[tokenAddress] = {\n                ...state?.[chainId]?.[address]?.[tokenAddress],\n                value,\n                blockNumber\n              }\n              return accumulator\n            }, {})\n          }\n        }\n      }\n    }\n    case Action.BATCH_UPDATE_EXCHANGES: {\n      const { chainId, exchangeAddresses, tokenAddresses, values, blockNumber } = payload\n\n      return {\n        ...state,\n        [chainId]: {\n          ...state?.[chainId],\n          ...exchangeAddresses.reduce((accumulator: any, exchangeAddress: string, i: number) => {\n            const tokenAddress = tokenAddresses[i]\n            const value = values[i]\n            accumulator[exchangeAddress] = {\n              ...state?.[chainId]?.[exchangeAddress],\n              ...accumulator?.[exchangeAddress],\n              [tokenAddress]: {\n                ...state?.[chainId]?.[exchangeAddress]?.[tokenAddress],\n                value,\n                blockNumber\n              }\n            }\n            return accumulator\n          }, {})\n        }\n      }\n    }\n    default: {\n      throw Error(`Unexpected action type in BalancesContext reducer: '${type}'.`)\n    }\n  }\n}\n\nconst BalancesContext = createContext<[BalancesState, { [k: string]: (...args: any) => void }]>([{}, {}])\n\nfunction useBalancesContext() {\n  return useContext(BalancesContext)\n}\n\nexport default function Provider({ children }: { children: ReactNode }) {\n  const [state, dispatch] = useReducer(reducer, undefined, initialize)\n\n  const startListening = useCallback((chainId, address, tokenAddress) => {\n    dispatch({ type: Action.START_LISTENING, payload: { chainId, address, tokenAddress } })\n  }, [])\n\n  const stopListening = useCallback((chainId, address, tokenAddress) => {\n    dispatch({ type: Action.STOP_LISTENING, payload: { chainId, address, tokenAddress } })\n  }, [])\n\n  const update = useCallback((chainId, address, tokenAddress, value, blockNumber) => {\n    dispatch({ type: Action.UPDATE, payload: { chainId, address, tokenAddress, value, blockNumber } })\n  }, [])\n\n  const batchUpdateAccount = useCallback((chainId, address, tokenAddresses, values, blockNumber) => {\n    dispatch({ type: Action.BATCH_UPDATE_ACCOUNT, payload: { chainId, address, tokenAddresses, values, blockNumber } })\n  }, [])\n\n  const batchUpdateExchanges = useCallback((chainId, exchangeAddresses, tokenAddresses, values, blockNumber) => {\n    dispatch({\n      type: Action.BATCH_UPDATE_EXCHANGES,\n      payload: { chainId, exchangeAddresses, tokenAddresses, values, blockNumber }\n    })\n  }, [])\n\n  return (\n    <BalancesContext.Provider\n      value={useMemo(\n        () => [state, { startListening, stopListening, update, batchUpdateAccount, batchUpdateExchanges }],\n        [state, startListening, stopListening, update, batchUpdateAccount, batchUpdateExchanges]\n      )}\n    >\n      {children}\n    </BalancesContext.Provider>\n  )\n}\n\nexport function Updater() {\n  const { chainId, account, library } = useWeb3React()\n  const blockNumber = useBlockNumber()\n  const [state, { update, batchUpdateAccount, batchUpdateExchanges }] = useBalancesContext()\n\n  // debounce state a little bit to prevent useEffect craziness\n  const debouncedState = useDebounce(state, 1000)\n  // cache this debounced state in localstorage\n  useEffect(() => {\n    window.localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(debouncedState))\n  }, [debouncedState])\n\n  // (slightly janky) balances-wide cache to prevent double/triple/etc. fetching\n  const fetchedAsOfCache = useRef<{\n    [chainId: number]: {\n      [address: string]: {\n        [tokenAddress: string]: number\n      }\n    }\n  }>({})\n\n  // generic balances fetcher abstracting away difference between fetching ETH + token balances\n  const fetchBalance = useCallback(\n    (address: string, tokenAddress: string) =>\n      (tokenAddress === 'ETH' ? getEtherBalance(address, library) : getTokenBalance(tokenAddress, address, library))\n        .then(value => {\n          return value.toString()\n        })\n        .catch(() => {\n          return null\n        }),\n    [library]\n  )\n\n  // ensure that all balances with >=1 listeners are updated every block\n  useEffect(() => {\n    if (typeof chainId === 'number' && typeof blockNumber === 'number') {\n      for (const address of Object.keys(debouncedState?.[chainId] ?? {})) {\n        for (const tokenAddress of Object.keys(debouncedState?.[chainId][address])) {\n          const active = debouncedState[chainId][address][tokenAddress].listenerCount > 0\n          if (active) {\n            const cachedFetchedAsOf = fetchedAsOfCache.current?.[chainId]?.[address]?.[tokenAddress]\n            const fetchedAsOf = debouncedState[chainId][address][tokenAddress]?.blockNumber ?? cachedFetchedAsOf\n            if (fetchedAsOf !== blockNumber) {\n              // fetch the balance...\n              fetchBalance(address, tokenAddress).then(value => {\n                update(chainId, address, tokenAddress, value, blockNumber)\n              })\n              // ...and cache the fetch\n              fetchedAsOfCache.current = {\n                ...fetchedAsOfCache.current,\n                [chainId]: {\n                  ...fetchedAsOfCache.current?.[chainId],\n                  [address]: {\n                    ...fetchedAsOfCache.current?.[chainId]?.[address],\n                    [tokenAddress]: blockNumber\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }, [chainId, blockNumber, debouncedState, fetchBalance, update])\n\n  // get a state ref for batch updates\n  const stateRef = useRef(state)\n  useEffect(() => {\n    stateRef.current = state\n  }, [state])\n  const allTokenDetails = useAllTokenDetails()\n\n  // ensure that we have the user balances for all tokens\n  const allTokens = useMemo(() => Object.keys(allTokenDetails), [allTokenDetails])\n  useEffect(() => {\n    if (typeof chainId === 'number' && typeof account === 'string' && typeof blockNumber === 'number') {\n      Promise.all(\n        allTokens\n          .filter(tokenAddress => {\n            const hasValue = !!stateRef.current?.[chainId]?.[account]?.[tokenAddress]?.value\n            const cachedFetchedAsOf = fetchedAsOfCache.current?.[chainId]?.[account]?.[tokenAddress]\n            const fetchedAsOf = stateRef.current?.[chainId]?.[account]?.[tokenAddress]?.blockNumber ?? cachedFetchedAsOf\n\n            // if there's no value, and it's not being fetched, we need to fetch!\n            if (!hasValue && typeof cachedFetchedAsOf !== 'number') {\n              return true\n              // else, if there's a value, check if it's stale\n            } else if (hasValue) {\n              const blocksElapsedSinceLastCheck = blockNumber - fetchedAsOf\n              const stale =\n                blocksElapsedSinceLastCheck >=\n                (stateRef.current[chainId][account][tokenAddress].value === '0'\n                  ? LONG_BLOCK_TIMEOUT\n                  : SHORT_BLOCK_TIMEOUT)\n              return stale\n            } else {\n              return false\n            }\n          })\n          .map(async tokenAddress => {\n            fetchedAsOfCache.current = {\n              ...fetchedAsOfCache.current,\n              [chainId]: {\n                ...fetchedAsOfCache.current?.[chainId],\n                [account]: {\n                  ...fetchedAsOfCache.current?.[chainId]?.[account],\n                  [tokenAddress]: blockNumber\n                }\n              }\n            }\n            return fetchBalance(account, tokenAddress).then(value => ({ tokenAddress, value }))\n          })\n      ).then(results => {\n        batchUpdateAccount(\n          chainId,\n          account,\n          results.map(result => result.tokenAddress),\n          results.map(result => result.value),\n          blockNumber\n        )\n      })\n    }\n  }, [chainId, account, blockNumber, allTokens, fetchBalance, batchUpdateAccount])\n\n  // ensure that we have the eth and token balances for all exchanges\n  const allExchanges = useMemo(\n    () =>\n      Object.keys(allTokenDetails)\n        .filter(tokenAddress => tokenAddress !== 'ETH')\n        .map(tokenAddress => ({\n          tokenAddress,\n          exchangeAddress: allTokenDetails[tokenAddress].exchangeAddress\n        })),\n    [allTokenDetails]\n  )\n  useEffect(() => {\n    if (typeof chainId === 'number' && typeof blockNumber === 'number') {\n      Promise.all(\n        allExchanges\n          .filter(({ exchangeAddress, tokenAddress }) => {\n            const hasValueToken = !!stateRef.current?.[chainId]?.[exchangeAddress]?.[tokenAddress]?.value\n            const hasValueETH = !!stateRef.current?.[chainId]?.[exchangeAddress]?.['ETH']?.value\n\n            const cachedFetchedAsOfToken = fetchedAsOfCache.current?.[chainId]?.[exchangeAddress]?.[tokenAddress]\n            const cachedFetchedAsOfETH = fetchedAsOfCache.current?.[chainId]?.[exchangeAddress]?.['ETH']\n\n            const fetchedAsOfToken =\n              stateRef.current?.[chainId]?.[exchangeAddress]?.[tokenAddress]?.blockNumber ?? cachedFetchedAsOfToken\n            const fetchedAsOfETH =\n              stateRef.current?.[chainId]?.[exchangeAddress]?.['ETH']?.blockNumber ?? cachedFetchedAsOfETH\n\n            // if there's no values, and they're not being fetched, we need to fetch!\n            if (\n              (!hasValueToken || !hasValueETH) &&\n              (typeof cachedFetchedAsOfToken !== 'number' || typeof cachedFetchedAsOfETH !== 'number')\n            ) {\n              return true\n              // else, if there are values, check if they's stale\n            } else if (hasValueToken && hasValueETH) {\n              const blocksElapsedSinceLastCheckToken = blockNumber - fetchedAsOfToken\n              const blocksElapsedSinceLastCheckETH = blockNumber - fetchedAsOfETH\n\n              const stale =\n                fetchedAsOfToken !== fetchedAsOfETH ||\n                blocksElapsedSinceLastCheckToken >= EXCHANGES_BLOCK_TIMEOUT ||\n                blocksElapsedSinceLastCheckETH >= EXCHANGES_BLOCK_TIMEOUT\n              return stale\n            } else {\n              return false\n            }\n          })\n          .map(async ({ exchangeAddress, tokenAddress }) => {\n            fetchedAsOfCache.current = {\n              ...fetchedAsOfCache.current,\n              [chainId]: {\n                ...fetchedAsOfCache.current?.[chainId],\n                [exchangeAddress]: {\n                  ...fetchedAsOfCache.current?.[chainId]?.[exchangeAddress],\n                  [tokenAddress]: blockNumber,\n                  ETH: blockNumber\n                }\n              }\n            }\n            return Promise.all([\n              fetchBalance(exchangeAddress, tokenAddress),\n              fetchBalance(exchangeAddress, 'ETH')\n            ]).then(([valueToken, valueETH]) => ({ exchangeAddress, tokenAddress, valueToken, valueETH }))\n          })\n      ).then(results => {\n        batchUpdateExchanges(\n          chainId,\n          results.flatMap(result => [result.exchangeAddress, result.exchangeAddress]),\n          results.flatMap(result => [result.tokenAddress, 'ETH']),\n          results.flatMap(result => [result.valueToken, result.valueETH]),\n          blockNumber\n        )\n      })\n    }\n  }, [chainId, account, blockNumber, allExchanges, fetchBalance, batchUpdateExchanges])\n\n  return null\n}\n\nexport function useAllBalances() {\n  const { chainId } = useWeb3React()\n  const [state] = useBalancesContext()\n  return useMemo(() => (typeof chainId === 'number' ? state?.[chainId] ?? {} : {}), [chainId, state])\n}\n\nexport function useAddressBalance(address: string, tokenAddress: string): ethers.utils.BigNumber | undefined | null {\n  const { chainId } = useWeb3React()\n  const [state, { startListening, stopListening }] = useBalancesContext()\n\n  useEffect(() => {\n    if (typeof chainId === 'number' && isAddress(address) && isAddress(tokenAddress)) {\n      startListening(chainId, address, tokenAddress)\n      return () => {\n        stopListening(chainId, address, tokenAddress)\n      }\n    }\n  }, [chainId, address, tokenAddress, startListening, stopListening])\n\n  const value = typeof chainId === 'number' ? state?.[chainId]?.[address]?.[tokenAddress]?.value : undefined\n\n  return useMemo(() => (typeof value === 'string' ? ethers.utils.bigNumberify(value) : value), [value])\n}\n\nexport function useExchangeReserves(tokenAddress: string) {\n  const { exchangeAddress } = useTokenDetails(tokenAddress)\n\n  const reserveETH = useAddressBalance(exchangeAddress, 'ETH')\n  const reserveToken = useAddressBalance(exchangeAddress, tokenAddress)\n\n  return { reserveETH, reserveToken }\n}\n\nconst buildReserveObject = (\n  chainId: number,\n  tokenAddress: string,\n  ethReserveAmount: any,\n  tokenReserveAmount: any,\n  decimals: number\n) => ({\n  token: {\n    chainId,\n    address: tokenAddress,\n    decimals\n  },\n  ethReserve: {\n    token: {\n      chainId,\n      decimals: 18\n    },\n    amount: ethReserveAmount\n  },\n  tokenReserve: {\n    token: {\n      chainId,\n      address: tokenAddress,\n      decimals\n    },\n    amount: tokenReserveAmount\n  }\n})\nconst daiTokenAddress = '0x6B175474E89094C44Da98b954EedeAC495271d0F'\nconst daiExchangeAddress = '0x2a1530C4C41db0B0b2bB646CB5Eb1A67b7158667'\nconst usdcTokenAddress = '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'\nconst usdcExchangeAddress = '0x97deC872013f6B5fB443861090ad931542878126'\nconst tusdTokenAddress = '0x0000000000085d4780B73119b644AE5ecd22b376'\nconst tusdExchangeAddress = '0x5048b9d01097498Fd72F3F14bC9Bc74A5aAc8fA7'\nexport function useETHPriceInUSD() {\n  const { chainId } = useWeb3React()\n\n  let daiReserveETH = useAddressBalance(daiExchangeAddress, 'ETH')\n  let daiReserveToken = useAddressBalance(daiExchangeAddress, daiTokenAddress)\n  let usdcReserveETH = useAddressBalance(usdcExchangeAddress, 'ETH')\n  let usdcReserveToken = useAddressBalance(usdcExchangeAddress, usdcTokenAddress)\n  let tusdReserveETH = useAddressBalance(tusdExchangeAddress, 'ETH')\n  let tusdReserveToken = useAddressBalance(tusdExchangeAddress, tusdTokenAddress)\n\n  const [price, setPrice] = useState<undefined | null>()\n  useEffect(() => {\n    if (\n      chainId &&\n      daiReserveETH &&\n      daiReserveToken &&\n      usdcReserveETH &&\n      usdcReserveToken &&\n      tusdReserveETH &&\n      tusdReserveToken\n    ) {\n      const daiReservesObject = buildReserveObject(\n        chainId,\n        daiTokenAddress,\n        new BigNumber(daiReserveETH.toString()),\n        new BigNumber(daiReserveToken.toString()),\n        18\n      )\n      const tusdReservesObject = buildReserveObject(\n        chainId,\n        tusdTokenAddress,\n        new BigNumber(tusdReserveETH.toString()),\n        new BigNumber(tusdReserveToken.toString()),\n        18\n      )\n      const usdcReservesObject = buildReserveObject(\n        chainId,\n        usdcTokenAddress,\n        new BigNumber(usdcReserveETH.toString()),\n        new BigNumber(usdcReserveToken.toString()),\n        6\n      )\n\n      const stablecoinReserves = [daiReservesObject, usdcReservesObject, tusdReservesObject]\n\n      try {\n        setPrice(getUSDPrice(stablecoinReserves))\n      } catch {\n        setPrice(null)\n      }\n    }\n  }, [daiReserveETH, daiReserveToken, usdcReserveETH, usdcReserveToken, tusdReserveETH, tusdReserveToken, chainId])\n\n  return price\n}\n"]},"metadata":{},"sourceType":"module"}