{"ast":null,"code":"'use strict';\n\nexports.__esModule = true; // istanbul ignore next\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nvar _exception = require('../exception');\n\nvar _exception2 = _interopRequireDefault(_exception);\n\nfunction Visitor() {\n  this.parents = [];\n}\n\nVisitor.prototype = {\n  constructor: Visitor,\n  mutating: false,\n  // Visits a given value. If mutating, will replace the value if necessary.\n  acceptKey: function acceptKey(node, name) {\n    var value = this.accept(node[name]);\n\n    if (this.mutating) {\n      // Hacky sanity check: This may have a few false positives for type for the helper\n      // methods but will generally do the right thing without a lot of overhead.\n      if (value && !Visitor.prototype[value.type]) {\n        throw new _exception2['default']('Unexpected node type \"' + value.type + '\" found when accepting ' + name + ' on ' + node.type);\n      }\n\n      node[name] = value;\n    }\n  },\n  // Performs an accept operation with added sanity check to ensure\n  // required keys are not removed.\n  acceptRequired: function acceptRequired(node, name) {\n    this.acceptKey(node, name);\n\n    if (!node[name]) {\n      throw new _exception2['default'](node.type + ' requires ' + name);\n    }\n  },\n  // Traverses a given array. If mutating, empty respnses will be removed\n  // for child elements.\n  acceptArray: function acceptArray(array) {\n    for (var i = 0, l = array.length; i < l; i++) {\n      this.acceptKey(array, i);\n\n      if (!array[i]) {\n        array.splice(i, 1);\n        i--;\n        l--;\n      }\n    }\n  },\n  accept: function accept(object) {\n    if (!object) {\n      return;\n    }\n    /* istanbul ignore next: Sanity code */\n\n\n    if (!this[object.type]) {\n      throw new _exception2['default']('Unknown type: ' + object.type, object);\n    }\n\n    if (this.current) {\n      this.parents.unshift(this.current);\n    }\n\n    this.current = object;\n    var ret = this[object.type](object);\n    this.current = this.parents.shift();\n\n    if (!this.mutating || ret) {\n      return ret;\n    } else if (ret !== false) {\n      return object;\n    }\n  },\n  Program: function Program(program) {\n    this.acceptArray(program.body);\n  },\n  MustacheStatement: visitSubExpression,\n  Decorator: visitSubExpression,\n  BlockStatement: visitBlock,\n  DecoratorBlock: visitBlock,\n  PartialStatement: visitPartial,\n  PartialBlockStatement: function PartialBlockStatement(partial) {\n    visitPartial.call(this, partial);\n    this.acceptKey(partial, 'program');\n  },\n  ContentStatement: function ContentStatement()\n  /* content */\n  {},\n  CommentStatement: function CommentStatement()\n  /* comment */\n  {},\n  SubExpression: visitSubExpression,\n  PathExpression: function PathExpression()\n  /* path */\n  {},\n  StringLiteral: function StringLiteral()\n  /* string */\n  {},\n  NumberLiteral: function NumberLiteral()\n  /* number */\n  {},\n  BooleanLiteral: function BooleanLiteral()\n  /* bool */\n  {},\n  UndefinedLiteral: function UndefinedLiteral()\n  /* literal */\n  {},\n  NullLiteral: function NullLiteral()\n  /* literal */\n  {},\n  Hash: function Hash(hash) {\n    this.acceptArray(hash.pairs);\n  },\n  HashPair: function HashPair(pair) {\n    this.acceptRequired(pair, 'value');\n  }\n};\n\nfunction visitSubExpression(mustache) {\n  this.acceptRequired(mustache, 'path');\n  this.acceptArray(mustache.params);\n  this.acceptKey(mustache, 'hash');\n}\n\nfunction visitBlock(block) {\n  visitSubExpression.call(this, block);\n  this.acceptKey(block, 'program');\n  this.acceptKey(block, 'inverse');\n}\n\nfunction visitPartial(partial) {\n  this.acceptRequired(partial, 'name');\n  this.acceptArray(partial.params);\n  this.acceptKey(partial, 'hash');\n}\n\nexports['default'] = Visitor;\nmodule.exports = exports['default'];","map":{"version":3,"sources":["../../../../lib/handlebars/compiler/visitor.js"],"names":[],"mappings":"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","sourcesContent":["import Exception from '../exception';\n\nfunction Visitor() {\n  this.parents = [];\n}\n\nVisitor.prototype = {\n  constructor: Visitor,\n  mutating: false,\n\n  // Visits a given value. If mutating, will replace the value if necessary.\n  acceptKey: function(node, name) {\n    let value = this.accept(node[name]);\n    if (this.mutating) {\n      // Hacky sanity check: This may have a few false positives for type for the helper\n      // methods but will generally do the right thing without a lot of overhead.\n      if (value && !Visitor.prototype[value.type]) {\n        throw new Exception(\n          'Unexpected node type \"' +\n            value.type +\n            '\" found when accepting ' +\n            name +\n            ' on ' +\n            node.type\n        );\n      }\n      node[name] = value;\n    }\n  },\n\n  // Performs an accept operation with added sanity check to ensure\n  // required keys are not removed.\n  acceptRequired: function(node, name) {\n    this.acceptKey(node, name);\n\n    if (!node[name]) {\n      throw new Exception(node.type + ' requires ' + name);\n    }\n  },\n\n  // Traverses a given array. If mutating, empty respnses will be removed\n  // for child elements.\n  acceptArray: function(array) {\n    for (let i = 0, l = array.length; i < l; i++) {\n      this.acceptKey(array, i);\n\n      if (!array[i]) {\n        array.splice(i, 1);\n        i--;\n        l--;\n      }\n    }\n  },\n\n  accept: function(object) {\n    if (!object) {\n      return;\n    }\n\n    /* istanbul ignore next: Sanity code */\n    if (!this[object.type]) {\n      throw new Exception('Unknown type: ' + object.type, object);\n    }\n\n    if (this.current) {\n      this.parents.unshift(this.current);\n    }\n    this.current = object;\n\n    let ret = this[object.type](object);\n\n    this.current = this.parents.shift();\n\n    if (!this.mutating || ret) {\n      return ret;\n    } else if (ret !== false) {\n      return object;\n    }\n  },\n\n  Program: function(program) {\n    this.acceptArray(program.body);\n  },\n\n  MustacheStatement: visitSubExpression,\n  Decorator: visitSubExpression,\n\n  BlockStatement: visitBlock,\n  DecoratorBlock: visitBlock,\n\n  PartialStatement: visitPartial,\n  PartialBlockStatement: function(partial) {\n    visitPartial.call(this, partial);\n\n    this.acceptKey(partial, 'program');\n  },\n\n  ContentStatement: function(/* content */) {},\n  CommentStatement: function(/* comment */) {},\n\n  SubExpression: visitSubExpression,\n\n  PathExpression: function(/* path */) {},\n\n  StringLiteral: function(/* string */) {},\n  NumberLiteral: function(/* number */) {},\n  BooleanLiteral: function(/* bool */) {},\n  UndefinedLiteral: function(/* literal */) {},\n  NullLiteral: function(/* literal */) {},\n\n  Hash: function(hash) {\n    this.acceptArray(hash.pairs);\n  },\n  HashPair: function(pair) {\n    this.acceptRequired(pair, 'value');\n  }\n};\n\nfunction visitSubExpression(mustache) {\n  this.acceptRequired(mustache, 'path');\n  this.acceptArray(mustache.params);\n  this.acceptKey(mustache, 'hash');\n}\nfunction visitBlock(block) {\n  visitSubExpression.call(this, block);\n\n  this.acceptKey(block, 'program');\n  this.acceptKey(block, 'inverse');\n}\nfunction visitPartial(partial) {\n  this.acceptRequired(partial, 'name');\n  this.acceptArray(partial.params);\n  this.acceptKey(partial, 'hash');\n}\n\nexport default Visitor;\n"]},"metadata":{},"sourceType":"script"}