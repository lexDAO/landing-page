{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function next() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ethereum_types_1 = require(\"ethereum-types\");\n\nvar _ = require(\"lodash\");\n\nvar configured_bignumber_1 = require(\"./configured_bignumber\"); // Note(albrow): This function is unexported in ethers.js. Copying it here for\n// now.\n// Source: https://github.com/ethers-io/ethers.js/blob/884593ab76004a808bf8097e9753fb5f8dcc3067/contracts/interface.js#L30\n\n\nfunction parseEthersParams(params) {\n  var names = [];\n  var types = [];\n  params.forEach(function (param) {\n    if (param.components != null) {\n      var suffix = '';\n      var arrayBracket = param.type.indexOf('[');\n\n      if (arrayBracket >= 0) {\n        suffix = param.type.substring(arrayBracket);\n      }\n\n      var result = parseEthersParams(param.components);\n      names.push({\n        name: param.name || null,\n        names: result.names\n      });\n      types.push(\"tuple(\" + result.types.join(',') + \")\" + suffix);\n    } else {\n      names.push(param.name || null);\n      types.push(param.type);\n    }\n  });\n  return {\n    names: names,\n    types: types\n  };\n} // returns true if x is equal to y and false otherwise. Performs some minimal\n// type conversion and data massaging for x and y, depending on type. name and\n// type should typically be derived from parseEthersParams.\n\n\nfunction isAbiDataEqual(name, type, x, y) {\n  if (x === undefined && y === undefined) {\n    return true;\n  } else if (x === undefined && y !== undefined) {\n    return false;\n  } else if (x !== undefined && y === undefined) {\n    return false;\n  }\n\n  if (_.endsWith(type, '[]')) {\n    // For array types, we iterate through the elements and check each one\n    // individually. Strangely, name does not need to be changed in this\n    // case.\n    if (x.length !== y.length) {\n      return false;\n    }\n\n    var newType = _.trimEnd(type, '[]');\n\n    for (var i = 0; i < x.length; i++) {\n      if (!isAbiDataEqual(name, newType, x[i], y[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  if (_.startsWith(type, 'tuple(')) {\n    if (_.isString(name)) {\n      throw new Error('Internal error: type was tuple but names was a string');\n    } else if (name === null) {\n      throw new Error('Internal error: type was tuple but names was null');\n    } // For tuples, we iterate through the underlying values and check each\n    // one individually.\n\n\n    var types = splitTupleTypes(type);\n\n    if (types.length !== name.names.length) {\n      throw new Error(\"Internal error: parameter types/names length mismatch (\" + types.length + \" != \" + name.names.length + \")\");\n    }\n\n    for (var i = 0; i < types.length; i++) {\n      // For tuples, name is an object with a names property that is an\n      // array. As an example, for orders, name looks like:\n      //\n      //  {\n      //      name: 'orders',\n      //      names: [\n      //          'makerAddress',\n      //          // ...\n      //          'takerAssetData'\n      //      ]\n      //  }\n      //\n      var nestedName = _.isString(name.names[i]) ? name.names[i] : name.names[i].name;\n\n      if (!isAbiDataEqual(name.names[i], types[i], x[nestedName], y[nestedName])) {\n        return false;\n      }\n    }\n\n    return true;\n  } else if (type === 'address' || type === 'bytes') {\n    // HACK(albrow): ethers.js returns the checksummed address even when\n    // initially passed in a non-checksummed address. To account for that,\n    // we convert to lowercase before comparing.\n    return _.isEqual(_.toLower(x), _.toLower(y));\n  } else if (_.startsWith(type, 'uint') || _.startsWith(type, 'int')) {\n    return new configured_bignumber_1.BigNumber(x).eq(new configured_bignumber_1.BigNumber(y));\n  }\n\n  return _.isEqual(x, y);\n} // splitTupleTypes splits a tuple type string (of the form `tuple(X)` where X is\n// any other type or list of types) into its component types. It works with\n// nested tuples, so, e.g., `tuple(tuple(uint256,address),bytes32)` will yield:\n// `['tuple(uint256,address)', 'bytes32']`. It expects exactly one tuple type as\n// an argument (not an array).\n\n\nfunction splitTupleTypes(type) {\n  var e_1, _a;\n\n  if (_.endsWith(type, '[]')) {\n    throw new Error('Internal error: array types are not supported');\n  } else if (!_.startsWith(type, 'tuple(')) {\n    throw new Error(\"Internal error: expected tuple type but got non-tuple type: \" + type);\n  } // Trim the outtermost tuple().\n\n\n  var trimmedType = type.substring('tuple('.length, type.length - 1);\n  var types = [];\n  var currToken = '';\n  var parenCount = 0;\n\n  try {\n    // Tokenize the type string while keeping track of parentheses.\n    for (var trimmedType_1 = __values(trimmedType), trimmedType_1_1 = trimmedType_1.next(); !trimmedType_1_1.done; trimmedType_1_1 = trimmedType_1.next()) {\n      var char = trimmedType_1_1.value;\n\n      switch (char) {\n        case '(':\n          parenCount += 1;\n          currToken += char;\n          break;\n\n        case ')':\n          parenCount -= 1;\n          currToken += char;\n          break;\n\n        case ',':\n          if (parenCount === 0) {\n            types.push(currToken);\n            currToken = '';\n            break;\n          } else {\n            currToken += char;\n            break;\n          }\n\n        default:\n          currToken += char;\n          break;\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (trimmedType_1_1 && !trimmedType_1_1.done && (_a = trimmedType_1.return)) _a.call(trimmedType_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  types.push(currToken);\n  return types;\n}\n\nexports.abiUtils = {\n  parseEthersParams: parseEthersParams,\n  isAbiDataEqual: isAbiDataEqual,\n  splitTupleTypes: splitTupleTypes,\n  parseFunctionParam: function parseFunctionParam(param) {\n    if (param.type === 'tuple') {\n      // Parse out tuple types into {type_1, type_2, ..., type_N}\n      var tupleComponents = param.components;\n\n      var paramString = _.map(tupleComponents, function (component) {\n        return exports.abiUtils.parseFunctionParam(component);\n      });\n\n      var tupleParamString = \"{\" + paramString + \"}\";\n      return tupleParamString;\n    }\n\n    return param.type;\n  },\n  getFunctionSignature: function getFunctionSignature(methodAbi) {\n    var functionName = methodAbi.name;\n\n    var parameterTypeList = _.map(methodAbi.inputs, function (param) {\n      return exports.abiUtils.parseFunctionParam(param);\n    });\n\n    var functionSignature = functionName + \"(\" + parameterTypeList + \")\";\n    return functionSignature;\n  },\n\n  /**\n   * Solidity supports function overloading whereas TypeScript does not.\n   * See: https://solidity.readthedocs.io/en/v0.4.21/contracts.html?highlight=overload#function-overloading\n   * In order to support overloaded functions, we suffix overloaded function names with an index.\n   * This index should be deterministic, regardless of function ordering within the smart contract. To do so,\n   * we assign indexes based on the alphabetical order of function signatures.\n   *\n   * E.g\n   * ['f(uint)', 'f(uint,byte32)']\n   * Should always be renamed to:\n   * ['f1(uint)', 'f2(uint,byte32)']\n   * Regardless of the order in which these these overloaded functions are declared within the contract ABI.\n   */\n  renameOverloadedMethods: function renameOverloadedMethods(inputContractAbi) {\n    var contractAbi = _.cloneDeep(inputContractAbi);\n\n    var methodAbis = contractAbi.filter(function (abi) {\n      return abi.type === ethereum_types_1.AbiType.Function;\n    }); // Sort method Abis into alphabetical order, by function signature\n\n    var methodAbisOrdered = _.sortBy(methodAbis, [function (methodAbi) {\n      var functionSignature = exports.abiUtils.getFunctionSignature(methodAbi);\n      return functionSignature;\n    }]); // Group method Abis by name (overloaded methods will be grouped together, in alphabetical order)\n\n\n    var methodAbisByName = {};\n\n    _.each(methodAbisOrdered, function (methodAbi) {\n      (methodAbisByName[methodAbi.name] || (methodAbisByName[methodAbi.name] = [])).push(methodAbi);\n    }); // Rename overloaded methods to overloadedMethodName1, overloadedMethodName2, ...\n\n\n    _.each(methodAbisByName, function (methodAbisWithSameName) {\n      _.each(methodAbisWithSameName, function (methodAbi, i) {\n        if (methodAbisWithSameName.length > 1) {\n          var overloadedMethodId = i + 1;\n          var sanitizedMethodName_1 = \"\" + methodAbi.name + overloadedMethodId;\n\n          var indexOfExistingAbiWithSanitizedMethodNameIfExists = _.findIndex(methodAbis, function (currentMethodAbi) {\n            return currentMethodAbi.name === sanitizedMethodName_1;\n          });\n\n          if (indexOfExistingAbiWithSanitizedMethodNameIfExists >= 0) {\n            var methodName = methodAbi.name;\n            throw new Error(\"Failed to rename overloaded method '\" + methodName + \"' to '\" + sanitizedMethodName_1 + \"'. A method with this name already exists.\");\n          }\n\n          methodAbi.name = sanitizedMethodName_1;\n        }\n      });\n    });\n\n    return contractAbi;\n  }\n};","map":{"version":3,"sources":["../../src/abi_utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ethereum_types_1 = require(\"ethereum-types\");\nvar _ = require(\"lodash\");\nvar configured_bignumber_1 = require(\"./configured_bignumber\");\n// Note(albrow): This function is unexported in ethers.js. Copying it here for\n// now.\n// Source: https://github.com/ethers-io/ethers.js/blob/884593ab76004a808bf8097e9753fb5f8dcc3067/contracts/interface.js#L30\nfunction parseEthersParams(params) {\n    var names = [];\n    var types = [];\n    params.forEach(function (param) {\n        if (param.components != null) {\n            var suffix = '';\n            var arrayBracket = param.type.indexOf('[');\n            if (arrayBracket >= 0) {\n                suffix = param.type.substring(arrayBracket);\n            }\n            var result = parseEthersParams(param.components);\n            names.push({ name: param.name || null, names: result.names });\n            types.push(\"tuple(\" + result.types.join(',') + \")\" + suffix);\n        }\n        else {\n            names.push(param.name || null);\n            types.push(param.type);\n        }\n    });\n    return {\n        names: names,\n        types: types,\n    };\n}\n// returns true if x is equal to y and false otherwise. Performs some minimal\n// type conversion and data massaging for x and y, depending on type. name and\n// type should typically be derived from parseEthersParams.\nfunction isAbiDataEqual(name, type, x, y) {\n    if (x === undefined && y === undefined) {\n        return true;\n    }\n    else if (x === undefined && y !== undefined) {\n        return false;\n    }\n    else if (x !== undefined && y === undefined) {\n        return false;\n    }\n    if (_.endsWith(type, '[]')) {\n        // For array types, we iterate through the elements and check each one\n        // individually. Strangely, name does not need to be changed in this\n        // case.\n        if (x.length !== y.length) {\n            return false;\n        }\n        var newType = _.trimEnd(type, '[]');\n        for (var i = 0; i < x.length; i++) {\n            if (!isAbiDataEqual(name, newType, x[i], y[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    if (_.startsWith(type, 'tuple(')) {\n        if (_.isString(name)) {\n            throw new Error('Internal error: type was tuple but names was a string');\n        }\n        else if (name === null) {\n            throw new Error('Internal error: type was tuple but names was null');\n        }\n        // For tuples, we iterate through the underlying values and check each\n        // one individually.\n        var types = splitTupleTypes(type);\n        if (types.length !== name.names.length) {\n            throw new Error(\"Internal error: parameter types/names length mismatch (\" + types.length + \" != \" + name.names.length + \")\");\n        }\n        for (var i = 0; i < types.length; i++) {\n            // For tuples, name is an object with a names property that is an\n            // array. As an example, for orders, name looks like:\n            //\n            //  {\n            //      name: 'orders',\n            //      names: [\n            //          'makerAddress',\n            //          // ...\n            //          'takerAssetData'\n            //      ]\n            //  }\n            //\n            var nestedName = _.isString(name.names[i])\n                ? name.names[i]\n                : name.names[i].name;\n            if (!isAbiDataEqual(name.names[i], types[i], x[nestedName], y[nestedName])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    else if (type === 'address' || type === 'bytes') {\n        // HACK(albrow): ethers.js returns the checksummed address even when\n        // initially passed in a non-checksummed address. To account for that,\n        // we convert to lowercase before comparing.\n        return _.isEqual(_.toLower(x), _.toLower(y));\n    }\n    else if (_.startsWith(type, 'uint') || _.startsWith(type, 'int')) {\n        return new configured_bignumber_1.BigNumber(x).eq(new configured_bignumber_1.BigNumber(y));\n    }\n    return _.isEqual(x, y);\n}\n// splitTupleTypes splits a tuple type string (of the form `tuple(X)` where X is\n// any other type or list of types) into its component types. It works with\n// nested tuples, so, e.g., `tuple(tuple(uint256,address),bytes32)` will yield:\n// `['tuple(uint256,address)', 'bytes32']`. It expects exactly one tuple type as\n// an argument (not an array).\nfunction splitTupleTypes(type) {\n    var e_1, _a;\n    if (_.endsWith(type, '[]')) {\n        throw new Error('Internal error: array types are not supported');\n    }\n    else if (!_.startsWith(type, 'tuple(')) {\n        throw new Error(\"Internal error: expected tuple type but got non-tuple type: \" + type);\n    }\n    // Trim the outtermost tuple().\n    var trimmedType = type.substring('tuple('.length, type.length - 1);\n    var types = [];\n    var currToken = '';\n    var parenCount = 0;\n    try {\n        // Tokenize the type string while keeping track of parentheses.\n        for (var trimmedType_1 = __values(trimmedType), trimmedType_1_1 = trimmedType_1.next(); !trimmedType_1_1.done; trimmedType_1_1 = trimmedType_1.next()) {\n            var char = trimmedType_1_1.value;\n            switch (char) {\n                case '(':\n                    parenCount += 1;\n                    currToken += char;\n                    break;\n                case ')':\n                    parenCount -= 1;\n                    currToken += char;\n                    break;\n                case ',':\n                    if (parenCount === 0) {\n                        types.push(currToken);\n                        currToken = '';\n                        break;\n                    }\n                    else {\n                        currToken += char;\n                        break;\n                    }\n                default:\n                    currToken += char;\n                    break;\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (trimmedType_1_1 && !trimmedType_1_1.done && (_a = trimmedType_1.return)) _a.call(trimmedType_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    types.push(currToken);\n    return types;\n}\nexports.abiUtils = {\n    parseEthersParams: parseEthersParams,\n    isAbiDataEqual: isAbiDataEqual,\n    splitTupleTypes: splitTupleTypes,\n    parseFunctionParam: function (param) {\n        if (param.type === 'tuple') {\n            // Parse out tuple types into {type_1, type_2, ..., type_N}\n            var tupleComponents = param.components;\n            var paramString = _.map(tupleComponents, function (component) { return exports.abiUtils.parseFunctionParam(component); });\n            var tupleParamString = \"{\" + paramString + \"}\";\n            return tupleParamString;\n        }\n        return param.type;\n    },\n    getFunctionSignature: function (methodAbi) {\n        var functionName = methodAbi.name;\n        var parameterTypeList = _.map(methodAbi.inputs, function (param) { return exports.abiUtils.parseFunctionParam(param); });\n        var functionSignature = functionName + \"(\" + parameterTypeList + \")\";\n        return functionSignature;\n    },\n    /**\n     * Solidity supports function overloading whereas TypeScript does not.\n     * See: https://solidity.readthedocs.io/en/v0.4.21/contracts.html?highlight=overload#function-overloading\n     * In order to support overloaded functions, we suffix overloaded function names with an index.\n     * This index should be deterministic, regardless of function ordering within the smart contract. To do so,\n     * we assign indexes based on the alphabetical order of function signatures.\n     *\n     * E.g\n     * ['f(uint)', 'f(uint,byte32)']\n     * Should always be renamed to:\n     * ['f1(uint)', 'f2(uint,byte32)']\n     * Regardless of the order in which these these overloaded functions are declared within the contract ABI.\n     */\n    renameOverloadedMethods: function (inputContractAbi) {\n        var contractAbi = _.cloneDeep(inputContractAbi);\n        var methodAbis = contractAbi.filter(function (abi) { return abi.type === ethereum_types_1.AbiType.Function; });\n        // Sort method Abis into alphabetical order, by function signature\n        var methodAbisOrdered = _.sortBy(methodAbis, [\n            function (methodAbi) {\n                var functionSignature = exports.abiUtils.getFunctionSignature(methodAbi);\n                return functionSignature;\n            },\n        ]);\n        // Group method Abis by name (overloaded methods will be grouped together, in alphabetical order)\n        var methodAbisByName = {};\n        _.each(methodAbisOrdered, function (methodAbi) {\n            (methodAbisByName[methodAbi.name] || (methodAbisByName[methodAbi.name] = [])).push(methodAbi);\n        });\n        // Rename overloaded methods to overloadedMethodName1, overloadedMethodName2, ...\n        _.each(methodAbisByName, function (methodAbisWithSameName) {\n            _.each(methodAbisWithSameName, function (methodAbi, i) {\n                if (methodAbisWithSameName.length > 1) {\n                    var overloadedMethodId = i + 1;\n                    var sanitizedMethodName_1 = \"\" + methodAbi.name + overloadedMethodId;\n                    var indexOfExistingAbiWithSanitizedMethodNameIfExists = _.findIndex(methodAbis, function (currentMethodAbi) { return currentMethodAbi.name === sanitizedMethodName_1; });\n                    if (indexOfExistingAbiWithSanitizedMethodNameIfExists >= 0) {\n                        var methodName = methodAbi.name;\n                        throw new Error(\"Failed to rename overloaded method '\" + methodName + \"' to '\" + sanitizedMethodName_1 + \"'. A method with this name already exists.\");\n                    }\n                    methodAbi.name = sanitizedMethodName_1;\n                }\n            });\n        });\n        return contractAbi;\n    },\n};\n//# sourceMappingURL=abi_utils.js.map"]},"metadata":{},"sourceType":"script"}