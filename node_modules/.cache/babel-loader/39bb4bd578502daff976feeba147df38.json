{"ast":null,"code":"'use strict';\n\nvar helpers = require('./helpers');\n/** @type ValidatorResult */\n\n\nvar ValidatorResult = helpers.ValidatorResult;\n/** @type SchemaError */\n\nvar SchemaError = helpers.SchemaError;\nvar attribute = {};\nattribute.ignoreProperties = {\n  // informative properties\n  'id': true,\n  'default': true,\n  'description': true,\n  'title': true,\n  // arguments to other properties\n  'exclusiveMinimum': true,\n  'exclusiveMaximum': true,\n  'additionalItems': true,\n  // special-handled properties\n  '$schema': true,\n  '$ref': true,\n  'extends': true\n};\n/**\n * @name validators\n */\n\nvar validators = attribute.validators = {};\n/**\n * Validates whether the instance if of a certain type\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {ValidatorResult|null}\n */\n\nvalidators.type = function validateType(instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var types = Array.isArray(schema.type) ? schema.type : [schema.type];\n\n  if (!types.some(this.testType.bind(this, instance, schema, options, ctx))) {\n    var list = types.map(function (v) {\n      return v.id && '<' + v.id + '>' || v + '';\n    });\n    result.addError({\n      name: 'type',\n      argument: list,\n      message: \"is not of a type(s) \" + list\n    });\n  }\n\n  return result;\n};\n\nfunction testSchemaNoThrow(instance, options, ctx, callback, schema) {\n  var throwError = options.throwError;\n  options.throwError = false;\n  var res = this.validateSchema(instance, schema, options, ctx);\n  options.throwError = throwError;\n\n  if (!res.valid && callback instanceof Function) {\n    callback(res);\n  }\n\n  return res.valid;\n}\n/**\n * Validates whether the instance matches some of the given schemas\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {ValidatorResult|null}\n */\n\n\nvalidators.anyOf = function validateAnyOf(instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var inner = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!Array.isArray(schema.anyOf)) {\n    throw new SchemaError(\"anyOf must be an array\");\n  }\n\n  if (!schema.anyOf.some(testSchemaNoThrow.bind(this, instance, options, ctx, function (res) {\n    inner.importErrors(res);\n  }))) {\n    var list = schema.anyOf.map(function (v, i) {\n      return v.id && '<' + v.id + '>' || v.title && JSON.stringify(v.title) || v['$ref'] && '<' + v['$ref'] + '>' || '[subschema ' + i + ']';\n    });\n\n    if (options.nestedErrors) {\n      result.importErrors(inner);\n    }\n\n    result.addError({\n      name: 'anyOf',\n      argument: list,\n      message: \"is not any of \" + list.join(',')\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance matches every given schema\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\n\n\nvalidators.allOf = function validateAllOf(instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n\n  if (!Array.isArray(schema.allOf)) {\n    throw new SchemaError(\"allOf must be an array\");\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var self = this;\n  schema.allOf.forEach(function (v, i) {\n    var valid = self.validateSchema(instance, v, options, ctx);\n\n    if (!valid.valid) {\n      var msg = v.id && '<' + v.id + '>' || v.title && JSON.stringify(v.title) || v['$ref'] && '<' + v['$ref'] + '>' || '[subschema ' + i + ']';\n      result.addError({\n        name: 'allOf',\n        argument: {\n          id: msg,\n          length: valid.errors.length,\n          valid: valid\n        },\n        message: 'does not match allOf schema ' + msg + ' with ' + valid.errors.length + ' error[s]:'\n      });\n      result.importErrors(valid);\n    }\n  });\n  return result;\n};\n/**\n * Validates whether the instance matches exactly one of the given schemas\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\n\n\nvalidators.oneOf = function validateOneOf(instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n\n  if (!Array.isArray(schema.oneOf)) {\n    throw new SchemaError(\"oneOf must be an array\");\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var inner = new ValidatorResult(instance, schema, options, ctx);\n  var count = schema.oneOf.filter(testSchemaNoThrow.bind(this, instance, options, ctx, function (res) {\n    inner.importErrors(res);\n  })).length;\n  var list = schema.oneOf.map(function (v, i) {\n    return v.id && '<' + v.id + '>' || v.title && JSON.stringify(v.title) || v['$ref'] && '<' + v['$ref'] + '>' || '[subschema ' + i + ']';\n  });\n\n  if (count !== 1) {\n    if (options.nestedErrors) {\n      result.importErrors(inner);\n    }\n\n    result.addError({\n      name: 'oneOf',\n      argument: list,\n      message: \"is not exactly one from \" + list.join(',')\n    });\n  }\n\n  return result;\n};\n/**\n * Validates properties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\n\n\nvalidators.properties = function validateProperties(instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var properties = schema.properties || {};\n\n  for (var property in properties) {\n    if (typeof options.preValidateProperty == 'function') {\n      options.preValidateProperty(instance, property, properties[property], options, ctx);\n    }\n\n    var prop = Object.hasOwnProperty.call(instance, property) ? instance[property] : undefined;\n    var res = this.validateSchema(prop, properties[property], options, ctx.makeChild(properties[property], property));\n    if (res.instance !== result.instance[property]) result.instance[property] = res.instance;\n    result.importErrors(res);\n  }\n\n  return result;\n};\n/**\n * Test a specific property within in instance against the additionalProperties schema attribute\n * This ignores properties with definitions in the properties schema attribute, but no other attributes.\n * If too many more types of property-existance tests pop up they may need their own class of tests (like `type` has)\n * @private\n * @return {boolean}\n */\n\n\nfunction testAdditionalProperty(instance, schema, options, ctx, property, result) {\n  if (!this.types.object(instance)) return;\n\n  if (schema.properties && schema.properties[property] !== undefined) {\n    return;\n  }\n\n  if (schema.additionalProperties === false) {\n    result.addError({\n      name: 'additionalProperties',\n      argument: property,\n      message: \"additionalProperty \" + JSON.stringify(property) + \" exists in instance when not allowed\"\n    });\n  } else {\n    var additionalProperties = schema.additionalProperties || {};\n\n    if (typeof options.preValidateProperty == 'function') {\n      options.preValidateProperty(instance, property, additionalProperties, options, ctx);\n    }\n\n    var res = this.validateSchema(instance[property], additionalProperties, options, ctx.makeChild(additionalProperties, property));\n    if (res.instance !== result.instance[property]) result.instance[property] = res.instance;\n    result.importErrors(res);\n  }\n}\n/**\n * Validates patternProperties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\n\n\nvalidators.patternProperties = function validatePatternProperties(instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var patternProperties = schema.patternProperties || {};\n\n  for (var property in instance) {\n    var test = true;\n\n    for (var pattern in patternProperties) {\n      var expr = new RegExp(pattern);\n\n      if (!expr.test(property)) {\n        continue;\n      }\n\n      test = false;\n\n      if (typeof options.preValidateProperty == 'function') {\n        options.preValidateProperty(instance, property, patternProperties[pattern], options, ctx);\n      }\n\n      var res = this.validateSchema(instance[property], patternProperties[pattern], options, ctx.makeChild(patternProperties[pattern], property));\n      if (res.instance !== result.instance[property]) result.instance[property] = res.instance;\n      result.importErrors(res);\n    }\n\n    if (test) {\n      testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n    }\n  }\n\n  return result;\n};\n/**\n * Validates additionalProperties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\n\n\nvalidators.additionalProperties = function validateAdditionalProperties(instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return; // if patternProperties is defined then we'll test when that one is called instead\n\n  if (schema.patternProperties) {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  for (var property in instance) {\n    testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.minProperties = function validateMinProperties(instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var keys = Object.keys(instance);\n\n  if (!(keys.length >= schema.minProperties)) {\n    result.addError({\n      name: 'minProperties',\n      argument: schema.minProperties,\n      message: \"does not meet minimum property length of \" + schema.minProperties\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.maxProperties = function validateMaxProperties(instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var keys = Object.keys(instance);\n\n  if (!(keys.length <= schema.maxProperties)) {\n    result.addError({\n      name: 'maxProperties',\n      argument: schema.maxProperties,\n      message: \"does not meet maximum property length of \" + schema.maxProperties\n    });\n  }\n\n  return result;\n};\n/**\n * Validates items when instance is an array\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\n\n\nvalidators.items = function validateItems(instance, schema, options, ctx) {\n  var self = this;\n  if (!this.types.array(instance)) return;\n  if (!schema.items) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  instance.every(function (value, i) {\n    var items = Array.isArray(schema.items) ? schema.items[i] || schema.additionalItems : schema.items;\n\n    if (items === undefined) {\n      return true;\n    }\n\n    if (items === false) {\n      result.addError({\n        name: 'items',\n        message: \"additionalItems not permitted\"\n      });\n      return false;\n    }\n\n    var res = self.validateSchema(value, items, options, ctx.makeChild(items, i));\n    if (res.instance !== result.instance[i]) result.instance[i] = res.instance;\n    result.importErrors(res);\n    return true;\n  });\n  return result;\n};\n/**\n * Validates minimum and exclusiveMinimum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.minimum = function validateMinimum(instance, schema, options, ctx) {\n  if (!this.types.number(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var valid = true;\n\n  if (schema.exclusiveMinimum && schema.exclusiveMinimum === true) {\n    valid = instance > schema.minimum;\n  } else {\n    valid = instance >= schema.minimum;\n  }\n\n  if (!valid) {\n    result.addError({\n      name: 'minimum',\n      argument: schema.minimum,\n      message: \"must have a minimum value of \" + schema.minimum\n    });\n  }\n\n  return result;\n};\n/**\n * Validates maximum and exclusiveMaximum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.maximum = function validateMaximum(instance, schema, options, ctx) {\n  if (!this.types.number(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var valid;\n\n  if (schema.exclusiveMaximum && schema.exclusiveMaximum === true) {\n    valid = instance < schema.maximum;\n  } else {\n    valid = instance <= schema.maximum;\n  }\n\n  if (!valid) {\n    result.addError({\n      name: 'maximum',\n      argument: schema.maximum,\n      message: \"must have a maximum value of \" + schema.maximum\n    });\n  }\n\n  return result;\n};\n/**\n * Perform validation for multipleOf and divisibleBy, which are essentially the same.\n * @param instance\n * @param schema\n * @param validationType\n * @param errorMessage\n * @returns {String|null}\n */\n\n\nvar validateMultipleOfOrDivisbleBy = function validateMultipleOfOrDivisbleBy(instance, schema, options, ctx, validationType, errorMessage) {\n  if (!this.types.number(instance)) return;\n  var validationArgument = schema[validationType];\n\n  if (validationArgument == 0) {\n    throw new SchemaError(validationType + \" cannot be zero\");\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var instanceDecimals = helpers.getDecimalPlaces(instance);\n  var divisorDecimals = helpers.getDecimalPlaces(validationArgument);\n  var maxDecimals = Math.max(instanceDecimals, divisorDecimals);\n  var multiplier = Math.pow(10, maxDecimals);\n\n  if (Math.round(instance * multiplier) % Math.round(validationArgument * multiplier) !== 0) {\n    result.addError({\n      name: validationType,\n      argument: validationArgument,\n      message: errorMessage + JSON.stringify(validationArgument)\n    });\n  }\n\n  return result;\n};\n/**\n * Validates divisibleBy when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.multipleOf = function validateMultipleOf(instance, schema, options, ctx) {\n  return validateMultipleOfOrDivisbleBy.call(this, instance, schema, options, ctx, \"multipleOf\", \"is not a multiple of (divisible by) \");\n};\n/**\n * Validates multipleOf when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.divisibleBy = function validateDivisibleBy(instance, schema, options, ctx) {\n  return validateMultipleOfOrDivisbleBy.call(this, instance, schema, options, ctx, \"divisibleBy\", \"is not divisible by (multiple of) \");\n};\n/**\n * Validates whether the instance value is present.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.required = function validateRequired(instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (instance === undefined && schema.required === true) {\n    // A boolean form is implemented for reverse-compatability with schemas written against older drafts\n    result.addError({\n      name: 'required',\n      message: \"is required\"\n    });\n  } else if (this.types.object(instance) && Array.isArray(schema.required)) {\n    schema.required.forEach(function (n) {\n      if (instance[n] === undefined) {\n        result.addError({\n          name: 'required',\n          argument: n,\n          message: \"requires property \" + JSON.stringify(n)\n        });\n      }\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance value matches the regular expression, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.pattern = function validatePattern(instance, schema, options, ctx) {\n  if (!this.types.string(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!instance.match(schema.pattern)) {\n    result.addError({\n      name: 'pattern',\n      argument: schema.pattern,\n      message: \"does not match pattern \" + JSON.stringify(schema.pattern.toString())\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance value is of a certain defined format or a custom\n * format.\n * The following formats are supported for string types:\n *   - date-time\n *   - date\n *   - time\n *   - ip-address\n *   - ipv6\n *   - uri\n *   - color\n *   - host-name\n *   - alpha\n *   - alpha-numeric\n *   - utc-millisec\n * @param instance\n * @param schema\n * @param [options]\n * @param [ctx]\n * @return {String|null}\n */\n\n\nvalidators.format = function validateFormat(instance, schema, options, ctx) {\n  if (instance === undefined) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!result.disableFormat && !helpers.isFormat(instance, schema.format, this)) {\n    result.addError({\n      name: 'format',\n      argument: schema.format,\n      message: \"does not conform to the \" + JSON.stringify(schema.format) + \" format\"\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.minLength = function validateMinLength(instance, schema, options, ctx) {\n  if (!this.types.string(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var hsp = instance.match(/[\\uDC00-\\uDFFF]/g);\n  var length = instance.length - (hsp ? hsp.length : 0);\n\n  if (!(length >= schema.minLength)) {\n    result.addError({\n      name: 'minLength',\n      argument: schema.minLength,\n      message: \"does not meet minimum length of \" + schema.minLength\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.maxLength = function validateMaxLength(instance, schema, options, ctx) {\n  if (!this.types.string(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx); // TODO if this was already computed in \"minLength\", use that value instead of re-computing\n\n  var hsp = instance.match(/[\\uDC00-\\uDFFF]/g);\n  var length = instance.length - (hsp ? hsp.length : 0);\n\n  if (!(length <= schema.maxLength)) {\n    result.addError({\n      name: 'maxLength',\n      argument: schema.maxLength,\n      message: \"does not meet maximum length of \" + schema.maxLength\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether instance contains at least a minimum number of items, when the instance is an Array.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.minItems = function validateMinItems(instance, schema, options, ctx) {\n  if (!this.types.array(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!(instance.length >= schema.minItems)) {\n    result.addError({\n      name: 'minItems',\n      argument: schema.minItems,\n      message: \"does not meet minimum length of \" + schema.minItems\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether instance contains no more than a maximum number of items, when the instance is an Array.\n * @param instance\n * @param schema\n * @return {String|null}\n */\n\n\nvalidators.maxItems = function validateMaxItems(instance, schema, options, ctx) {\n  if (!this.types.array(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!(instance.length <= schema.maxItems)) {\n    result.addError({\n      name: 'maxItems',\n      argument: schema.maxItems,\n      message: \"does not meet maximum length of \" + schema.maxItems\n    });\n  }\n\n  return result;\n};\n/**\n * Validates that every item in an instance array is unique, when instance is an array\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\n\n\nvalidators.uniqueItems = function validateUniqueItems(instance, schema, options, ctx) {\n  if (!this.types.array(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  function testArrays(v, i, a) {\n    for (var j = i + 1; j < a.length; j++) if (helpers.deepCompareStrict(v, a[j])) {\n      return false;\n    }\n\n    return true;\n  }\n\n  if (!instance.every(testArrays)) {\n    result.addError({\n      name: 'uniqueItems',\n      message: \"contains duplicate item\"\n    });\n  }\n\n  return result;\n};\n/**\n * Deep compares arrays for duplicates\n * @param v\n * @param i\n * @param a\n * @private\n * @return {boolean}\n */\n\n\nfunction testArrays(v, i, a) {\n  var j,\n      len = a.length;\n\n  for (j = i + 1, len; j < len; j++) {\n    if (helpers.deepCompareStrict(v, a[j])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Validates whether there are no duplicates, when the instance is an Array.\n * @param instance\n * @return {String|null}\n */\n\n\nvalidators.uniqueItems = function validateUniqueItems(instance, schema, options, ctx) {\n  if (!this.types.array(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!instance.every(testArrays)) {\n    result.addError({\n      name: 'uniqueItems',\n      message: \"contains duplicate item\"\n    });\n  }\n\n  return result;\n};\n/**\n * Validate for the presence of dependency properties, if the instance is an object.\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {null|ValidatorResult}\n */\n\n\nvalidators.dependencies = function validateDependencies(instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  for (var property in schema.dependencies) {\n    if (instance[property] === undefined) {\n      continue;\n    }\n\n    var dep = schema.dependencies[property];\n    var childContext = ctx.makeChild(dep, property);\n\n    if (typeof dep == 'string') {\n      dep = [dep];\n    }\n\n    if (Array.isArray(dep)) {\n      dep.forEach(function (prop) {\n        if (instance[prop] === undefined) {\n          result.addError({\n            // FIXME there's two different \"dependencies\" errors here with slightly different outputs\n            // Can we make these the same? Or should we create different error types?\n            name: 'dependencies',\n            argument: childContext.propertyPath,\n            message: \"property \" + prop + \" not found, required by \" + childContext.propertyPath\n          });\n        }\n      });\n    } else {\n      var res = this.validateSchema(instance, dep, options, childContext);\n      if (result.instance !== res.instance) result.instance = res.instance;\n\n      if (res && res.errors.length) {\n        result.addError({\n          name: 'dependencies',\n          argument: childContext.propertyPath,\n          message: \"does not meet dependency required by \" + childContext.propertyPath\n        });\n        result.importErrors(res);\n      }\n    }\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance value is one of the enumerated values.\n *\n * @param instance\n * @param schema\n * @return {ValidatorResult|null}\n */\n\n\nvalidators['enum'] = function validateEnum(instance, schema, options, ctx) {\n  if (instance === undefined) {\n    return null;\n  }\n\n  if (!Array.isArray(schema['enum'])) {\n    throw new SchemaError(\"enum expects an array\", schema);\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!schema['enum'].some(helpers.deepCompareStrict.bind(null, instance))) {\n    result.addError({\n      name: 'enum',\n      argument: schema['enum'],\n      message: \"is not one of enum values: \" + schema['enum'].map(String).join(',')\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance exactly matches a given value\n *\n * @param instance\n * @param schema\n * @return {ValidatorResult|null}\n */\n\n\nvalidators['const'] = function validateEnum(instance, schema, options, ctx) {\n  if (instance === undefined) {\n    return null;\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  if (!helpers.deepCompareStrict(schema['const'], instance)) {\n    result.addError({\n      name: 'const',\n      argument: schema['const'],\n      message: \"does not exactly match expected constant: \" + schema['const']\n    });\n  }\n\n  return result;\n};\n/**\n * Validates whether the instance if of a prohibited type.\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {null|ValidatorResult}\n */\n\n\nvalidators.not = validators.disallow = function validateNot(instance, schema, options, ctx) {\n  var self = this;\n  if (instance === undefined) return null;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var notTypes = schema.not || schema.disallow;\n  if (!notTypes) return null;\n  if (!Array.isArray(notTypes)) notTypes = [notTypes];\n  notTypes.forEach(function (type) {\n    if (self.testType(instance, schema, options, ctx, type)) {\n      var schemaId = type && type.id && '<' + type.id + '>' || type;\n      result.addError({\n        name: 'not',\n        argument: schemaId,\n        message: \"is of prohibited type \" + schemaId\n      });\n    }\n  });\n  return result;\n};\n\nmodule.exports = attribute;","map":{"version":3,"sources":["/Users/kerp/Documents/GitHub/landing-page/node_modules/jsonschema/lib/attribute.js"],"names":["helpers","require","ValidatorResult","SchemaError","attribute","ignoreProperties","validators","type","validateType","instance","schema","options","ctx","undefined","result","types","Array","isArray","some","testType","bind","list","map","v","id","addError","name","argument","message","testSchemaNoThrow","callback","throwError","res","validateSchema","valid","Function","anyOf","validateAnyOf","inner","importErrors","i","title","JSON","stringify","nestedErrors","join","allOf","validateAllOf","self","forEach","msg","length","errors","oneOf","validateOneOf","count","filter","properties","validateProperties","object","property","preValidateProperty","prop","Object","hasOwnProperty","call","makeChild","testAdditionalProperty","additionalProperties","patternProperties","validatePatternProperties","test","pattern","expr","RegExp","validateAdditionalProperties","minProperties","validateMinProperties","keys","maxProperties","validateMaxProperties","items","validateItems","array","every","value","additionalItems","minimum","validateMinimum","number","exclusiveMinimum","maximum","validateMaximum","exclusiveMaximum","validateMultipleOfOrDivisbleBy","validationType","errorMessage","validationArgument","instanceDecimals","getDecimalPlaces","divisorDecimals","maxDecimals","Math","max","multiplier","pow","round","multipleOf","validateMultipleOf","divisibleBy","validateDivisibleBy","required","validateRequired","n","validatePattern","string","match","toString","format","validateFormat","disableFormat","isFormat","minLength","validateMinLength","hsp","maxLength","validateMaxLength","minItems","validateMinItems","maxItems","validateMaxItems","uniqueItems","validateUniqueItems","testArrays","a","j","deepCompareStrict","len","dependencies","validateDependencies","dep","childContext","propertyPath","validateEnum","String","not","disallow","validateNot","notTypes","schemaId","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar helpers = require('./helpers');\n\n/** @type ValidatorResult */\nvar ValidatorResult = helpers.ValidatorResult;\n/** @type SchemaError */\nvar SchemaError = helpers.SchemaError;\n\nvar attribute = {};\n\nattribute.ignoreProperties = {\n  // informative properties\n  'id': true,\n  'default': true,\n  'description': true,\n  'title': true,\n  // arguments to other properties\n  'exclusiveMinimum': true,\n  'exclusiveMaximum': true,\n  'additionalItems': true,\n  // special-handled properties\n  '$schema': true,\n  '$ref': true,\n  'extends': true\n};\n\n/**\n * @name validators\n */\nvar validators = attribute.validators = {};\n\n/**\n * Validates whether the instance if of a certain type\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {ValidatorResult|null}\n */\nvalidators.type = function validateType (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var types = Array.isArray(schema.type) ? schema.type : [schema.type];\n  if (!types.some(this.testType.bind(this, instance, schema, options, ctx))) {\n    var list = types.map(function (v) {\n      return v.id && ('<' + v.id + '>') || (v+'');\n    });\n    result.addError({\n      name: 'type',\n      argument: list,\n      message: \"is not of a type(s) \" + list,\n    });\n  }\n  return result;\n};\n\nfunction testSchemaNoThrow(instance, options, ctx, callback, schema){\n  var throwError = options.throwError;\n  options.throwError = false;\n  var res = this.validateSchema(instance, schema, options, ctx);\n  options.throwError = throwError;\n\n  if (!res.valid && callback instanceof Function) {\n    callback(res);\n  }\n  return res.valid;\n}\n\n/**\n * Validates whether the instance matches some of the given schemas\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {ValidatorResult|null}\n */\nvalidators.anyOf = function validateAnyOf (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var inner = new ValidatorResult(instance, schema, options, ctx);\n  if (!Array.isArray(schema.anyOf)){\n    throw new SchemaError(\"anyOf must be an array\");\n  }\n  if (!schema.anyOf.some(\n    testSchemaNoThrow.bind(\n      this, instance, options, ctx, function(res){inner.importErrors(res);}\n      ))) {\n    var list = schema.anyOf.map(function (v, i) {\n      return (v.id && ('<' + v.id + '>')) || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';\n    });\n    if (options.nestedErrors) {\n      result.importErrors(inner);\n    }\n    result.addError({\n      name: 'anyOf',\n      argument: list,\n      message: \"is not any of \" + list.join(','),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance matches every given schema\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\nvalidators.allOf = function validateAllOf (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  if (!Array.isArray(schema.allOf)){\n    throw new SchemaError(\"allOf must be an array\");\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var self = this;\n  schema.allOf.forEach(function(v, i){\n    var valid = self.validateSchema(instance, v, options, ctx);\n    if(!valid.valid){\n      var msg = (v.id && ('<' + v.id + '>')) || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';\n      result.addError({\n        name: 'allOf',\n        argument: { id: msg, length: valid.errors.length, valid: valid },\n        message: 'does not match allOf schema ' + msg + ' with ' + valid.errors.length + ' error[s]:',\n      });\n      result.importErrors(valid);\n    }\n  });\n  return result;\n};\n\n/**\n * Validates whether the instance matches exactly one of the given schemas\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\nvalidators.oneOf = function validateOneOf (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  if (!Array.isArray(schema.oneOf)){\n    throw new SchemaError(\"oneOf must be an array\");\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var inner = new ValidatorResult(instance, schema, options, ctx);\n  var count = schema.oneOf.filter(\n    testSchemaNoThrow.bind(\n      this, instance, options, ctx, function(res) {inner.importErrors(res);}\n      ) ).length;\n  var list = schema.oneOf.map(function (v, i) {\n    return (v.id && ('<' + v.id + '>')) || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';\n  });\n  if (count!==1) {\n    if (options.nestedErrors) {\n      result.importErrors(inner);\n    }\n    result.addError({\n      name: 'oneOf',\n      argument: list,\n      message: \"is not exactly one from \" + list.join(','),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates properties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.properties = function validateProperties (instance, schema, options, ctx) {\n  if(!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var properties = schema.properties || {};\n  for (var property in properties) {\n    if (typeof options.preValidateProperty == 'function') {\n      options.preValidateProperty(instance, property, properties[property], options, ctx);\n    }\n\n    var prop = Object.hasOwnProperty.call(instance, property) ? instance[property] : undefined;\n    var res = this.validateSchema(prop, properties[property], options, ctx.makeChild(properties[property], property));\n    if(res.instance !== result.instance[property]) result.instance[property] = res.instance;\n    result.importErrors(res);\n  }\n  return result;\n};\n\n/**\n * Test a specific property within in instance against the additionalProperties schema attribute\n * This ignores properties with definitions in the properties schema attribute, but no other attributes.\n * If too many more types of property-existance tests pop up they may need their own class of tests (like `type` has)\n * @private\n * @return {boolean}\n */\nfunction testAdditionalProperty (instance, schema, options, ctx, property, result) {\n  if(!this.types.object(instance)) return;\n  if (schema.properties && schema.properties[property] !== undefined) {\n    return;\n  }\n  if (schema.additionalProperties === false) {\n    result.addError({\n      name: 'additionalProperties',\n      argument: property,\n      message: \"additionalProperty \" + JSON.stringify(property) + \" exists in instance when not allowed\",\n    });\n  } else {\n    var additionalProperties = schema.additionalProperties || {};\n\n    if (typeof options.preValidateProperty == 'function') {\n      options.preValidateProperty(instance, property, additionalProperties, options, ctx);\n    }\n\n    var res = this.validateSchema(instance[property], additionalProperties, options, ctx.makeChild(additionalProperties, property));\n    if(res.instance !== result.instance[property]) result.instance[property] = res.instance;\n    result.importErrors(res);\n  }\n}\n\n/**\n * Validates patternProperties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.patternProperties = function validatePatternProperties (instance, schema, options, ctx) {\n  if(!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var patternProperties = schema.patternProperties || {};\n\n  for (var property in instance) {\n    var test = true;\n    for (var pattern in patternProperties) {\n      var expr = new RegExp(pattern);\n      if (!expr.test(property)) {\n        continue;\n      }\n      test = false;\n\n      if (typeof options.preValidateProperty == 'function') {\n        options.preValidateProperty(instance, property, patternProperties[pattern], options, ctx);\n      }\n\n      var res = this.validateSchema(instance[property], patternProperties[pattern], options, ctx.makeChild(patternProperties[pattern], property));\n      if(res.instance !== result.instance[property]) result.instance[property] = res.instance;\n      result.importErrors(res);\n    }\n    if (test) {\n      testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n    }\n  }\n\n  return result;\n};\n\n/**\n * Validates additionalProperties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.additionalProperties = function validateAdditionalProperties (instance, schema, options, ctx) {\n  if(!this.types.object(instance)) return;\n  // if patternProperties is defined then we'll test when that one is called instead\n  if (schema.patternProperties) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  for (var property in instance) {\n    testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minProperties = function validateMinProperties (instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var keys = Object.keys(instance);\n  if (!(keys.length >= schema.minProperties)) {\n    result.addError({\n      name: 'minProperties',\n      argument: schema.minProperties,\n      message: \"does not meet minimum property length of \" + schema.minProperties,\n    })\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maxProperties = function validateMaxProperties (instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var keys = Object.keys(instance);\n  if (!(keys.length <= schema.maxProperties)) {\n    result.addError({\n      name: 'maxProperties',\n      argument: schema.maxProperties,\n      message: \"does not meet maximum property length of \" + schema.maxProperties,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates items when instance is an array\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.items = function validateItems (instance, schema, options, ctx) {\n  var self = this;\n  if (!this.types.array(instance)) return;\n  if (!schema.items) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  instance.every(function (value, i) {\n    var items = Array.isArray(schema.items) ? (schema.items[i] || schema.additionalItems) : schema.items;\n    if (items === undefined) {\n      return true;\n    }\n    if (items === false) {\n      result.addError({\n        name: 'items',\n        message: \"additionalItems not permitted\",\n      });\n      return false;\n    }\n    var res = self.validateSchema(value, items, options, ctx.makeChild(items, i));\n    if(res.instance !== result.instance[i]) result.instance[i] = res.instance;\n    result.importErrors(res);\n    return true;\n  });\n  return result;\n};\n\n/**\n * Validates minimum and exclusiveMinimum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minimum = function validateMinimum (instance, schema, options, ctx) {\n  if (!this.types.number(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var valid = true;\n  if (schema.exclusiveMinimum && schema.exclusiveMinimum === true) {\n    valid = instance > schema.minimum;\n  } else {\n    valid = instance >= schema.minimum;\n  }\n  if (!valid) {\n    result.addError({\n      name: 'minimum',\n      argument: schema.minimum,\n      message: \"must have a minimum value of \" + schema.minimum,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates maximum and exclusiveMaximum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maximum = function validateMaximum (instance, schema, options, ctx) {\n  if (!this.types.number(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var valid;\n  if (schema.exclusiveMaximum && schema.exclusiveMaximum === true) {\n    valid = instance < schema.maximum;\n  } else {\n    valid = instance <= schema.maximum;\n  }\n  if (!valid) {\n    result.addError({\n      name: 'maximum',\n      argument: schema.maximum,\n      message: \"must have a maximum value of \" + schema.maximum,\n    });\n  }\n  return result;\n};\n\n/**\n * Perform validation for multipleOf and divisibleBy, which are essentially the same.\n * @param instance\n * @param schema\n * @param validationType\n * @param errorMessage\n * @returns {String|null}\n */\nvar validateMultipleOfOrDivisbleBy = function validateMultipleOfOrDivisbleBy (instance, schema, options, ctx, validationType, errorMessage) {\n  if (!this.types.number(instance)) return;\n\n  var validationArgument = schema[validationType];\n  if (validationArgument == 0) {\n    throw new SchemaError(validationType + \" cannot be zero\");\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  var instanceDecimals = helpers.getDecimalPlaces(instance);\n  var divisorDecimals = helpers.getDecimalPlaces(validationArgument);\n\n  var maxDecimals = Math.max(instanceDecimals , divisorDecimals);\n  var multiplier = Math.pow(10, maxDecimals);\n\n  if (Math.round(instance * multiplier) % Math.round(validationArgument * multiplier) !== 0) {\n    result.addError({\n      name: validationType,\n      argument:  validationArgument,\n      message: errorMessage + JSON.stringify(validationArgument)\n    });\n  }\n\n  return result;\n};\n\n/**\n * Validates divisibleBy when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.multipleOf = function validateMultipleOf (instance, schema, options, ctx) {\n return validateMultipleOfOrDivisbleBy.call(this, instance, schema, options, ctx, \"multipleOf\", \"is not a multiple of (divisible by) \");\n};\n\n/**\n * Validates multipleOf when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.divisibleBy = function validateDivisibleBy (instance, schema, options, ctx) {\n  return validateMultipleOfOrDivisbleBy.call(this, instance, schema, options, ctx, \"divisibleBy\", \"is not divisible by (multiple of) \");\n};\n\n/**\n * Validates whether the instance value is present.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.required = function validateRequired (instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (instance === undefined && schema.required === true) {\n    // A boolean form is implemented for reverse-compatability with schemas written against older drafts\n    result.addError({\n      name: 'required',\n      message: \"is required\"\n    });\n  } else if (this.types.object(instance) && Array.isArray(schema.required)) {\n    schema.required.forEach(function(n){\n      if(instance[n]===undefined){\n        result.addError({\n          name: 'required',\n          argument: n,\n          message: \"requires property \" + JSON.stringify(n),\n        });\n      }\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value matches the regular expression, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.pattern = function validatePattern (instance, schema, options, ctx) {\n  if (!this.types.string(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!instance.match(schema.pattern)) {\n    result.addError({\n      name: 'pattern',\n      argument: schema.pattern,\n      message: \"does not match pattern \" + JSON.stringify(schema.pattern.toString()),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is of a certain defined format or a custom\n * format.\n * The following formats are supported for string types:\n *   - date-time\n *   - date\n *   - time\n *   - ip-address\n *   - ipv6\n *   - uri\n *   - color\n *   - host-name\n *   - alpha\n *   - alpha-numeric\n *   - utc-millisec\n * @param instance\n * @param schema\n * @param [options]\n * @param [ctx]\n * @return {String|null}\n */\nvalidators.format = function validateFormat (instance, schema, options, ctx) {\n  if (instance===undefined) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!result.disableFormat && !helpers.isFormat(instance, schema.format, this)) {\n    result.addError({\n      name: 'format',\n      argument: schema.format,\n      message: \"does not conform to the \" + JSON.stringify(schema.format) + \" format\",\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minLength = function validateMinLength (instance, schema, options, ctx) {\n  if (!this.types.string(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var hsp = instance.match(/[\\uDC00-\\uDFFF]/g);\n  var length = instance.length - (hsp ? hsp.length : 0);\n  if (!(length >= schema.minLength)) {\n    result.addError({\n      name: 'minLength',\n      argument: schema.minLength,\n      message: \"does not meet minimum length of \" + schema.minLength,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maxLength = function validateMaxLength (instance, schema, options, ctx) {\n  if (!this.types.string(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  // TODO if this was already computed in \"minLength\", use that value instead of re-computing\n  var hsp = instance.match(/[\\uDC00-\\uDFFF]/g);\n  var length = instance.length - (hsp ? hsp.length : 0);\n  if (!(length <= schema.maxLength)) {\n    result.addError({\n      name: 'maxLength',\n      argument: schema.maxLength,\n      message: \"does not meet maximum length of \" + schema.maxLength,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether instance contains at least a minimum number of items, when the instance is an Array.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minItems = function validateMinItems (instance, schema, options, ctx) {\n  if (!this.types.array(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!(instance.length >= schema.minItems)) {\n    result.addError({\n      name: 'minItems',\n      argument: schema.minItems,\n      message: \"does not meet minimum length of \" + schema.minItems,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether instance contains no more than a maximum number of items, when the instance is an Array.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maxItems = function validateMaxItems (instance, schema, options, ctx) {\n  if (!this.types.array(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!(instance.length <= schema.maxItems)) {\n    result.addError({\n      name: 'maxItems',\n      argument: schema.maxItems,\n      message: \"does not meet maximum length of \" + schema.maxItems,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates that every item in an instance array is unique, when instance is an array\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.uniqueItems = function validateUniqueItems (instance, schema, options, ctx) {\n  if (!this.types.array(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  function testArrays (v, i, a) {\n    for (var j = i + 1; j < a.length; j++) if (helpers.deepCompareStrict(v, a[j])) {\n      return false;\n    }\n    return true;\n  }\n  if (!instance.every(testArrays)) {\n    result.addError({\n      name: 'uniqueItems',\n      message: \"contains duplicate item\",\n    });\n  }\n  return result;\n};\n\n/**\n * Deep compares arrays for duplicates\n * @param v\n * @param i\n * @param a\n * @private\n * @return {boolean}\n */\nfunction testArrays (v, i, a) {\n  var j, len = a.length;\n  for (j = i + 1, len; j < len; j++) {\n    if (helpers.deepCompareStrict(v, a[j])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Validates whether there are no duplicates, when the instance is an Array.\n * @param instance\n * @return {String|null}\n */\nvalidators.uniqueItems = function validateUniqueItems (instance, schema, options, ctx) {\n  if (!this.types.array(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!instance.every(testArrays)) {\n    result.addError({\n      name: 'uniqueItems',\n      message: \"contains duplicate item\",\n    });\n  }\n  return result;\n};\n\n/**\n * Validate for the presence of dependency properties, if the instance is an object.\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {null|ValidatorResult}\n */\nvalidators.dependencies = function validateDependencies (instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  for (var property in schema.dependencies) {\n    if (instance[property] === undefined) {\n      continue;\n    }\n    var dep = schema.dependencies[property];\n    var childContext = ctx.makeChild(dep, property);\n    if (typeof dep == 'string') {\n      dep = [dep];\n    }\n    if (Array.isArray(dep)) {\n      dep.forEach(function (prop) {\n        if (instance[prop] === undefined) {\n          result.addError({\n            // FIXME there's two different \"dependencies\" errors here with slightly different outputs\n            // Can we make these the same? Or should we create different error types?\n            name: 'dependencies',\n            argument: childContext.propertyPath,\n            message: \"property \" + prop + \" not found, required by \" + childContext.propertyPath,\n          });\n        }\n      });\n    } else {\n      var res = this.validateSchema(instance, dep, options, childContext);\n      if(result.instance !== res.instance) result.instance = res.instance;\n      if (res && res.errors.length) {\n        result.addError({\n          name: 'dependencies',\n          argument: childContext.propertyPath,\n          message: \"does not meet dependency required by \" + childContext.propertyPath,\n        });\n        result.importErrors(res);\n      }\n    }\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is one of the enumerated values.\n *\n * @param instance\n * @param schema\n * @return {ValidatorResult|null}\n */\nvalidators['enum'] = function validateEnum (instance, schema, options, ctx) {\n  if (instance === undefined) {\n    return null;\n  }\n  if (!Array.isArray(schema['enum'])) {\n    throw new SchemaError(\"enum expects an array\", schema);\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!schema['enum'].some(helpers.deepCompareStrict.bind(null, instance))) {\n    result.addError({\n      name: 'enum',\n      argument: schema['enum'],\n      message: \"is not one of enum values: \" + schema['enum'].map(String).join(','),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance exactly matches a given value\n *\n * @param instance\n * @param schema\n * @return {ValidatorResult|null}\n */\nvalidators['const'] = function validateEnum (instance, schema, options, ctx) {\n  if (instance === undefined) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!helpers.deepCompareStrict(schema['const'], instance)) {\n    result.addError({\n      name: 'const',\n      argument: schema['const'],\n      message: \"does not exactly match expected constant: \" + schema['const'],\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance if of a prohibited type.\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {null|ValidatorResult}\n */\nvalidators.not = validators.disallow = function validateNot (instance, schema, options, ctx) {\n  var self = this;\n  if(instance===undefined) return null;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var notTypes = schema.not || schema.disallow;\n  if(!notTypes) return null;\n  if(!Array.isArray(notTypes)) notTypes=[notTypes];\n  notTypes.forEach(function (type) {\n    if (self.testType(instance, schema, options, ctx, type)) {\n      var schemaId = type && type.id && ('<' + type.id + '>') || type;\n      result.addError({\n        name: 'not',\n        argument: schemaId,\n        message: \"is of prohibited type \" + schemaId,\n      });\n    }\n  });\n  return result;\n};\n\nmodule.exports = attribute;\n"]},"metadata":{},"sourceType":"script"}