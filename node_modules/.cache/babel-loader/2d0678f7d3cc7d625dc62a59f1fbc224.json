{"ast":null,"code":"import { useState, useMemo, useCallback, useEffect, useRef } from 'react';\nimport { useWeb3React as useWeb3ReactCore } from '@web3-react/core';\nimport copy from 'copy-to-clipboard';\nimport { isMobile } from 'react-device-detect';\nimport { NetworkContextName } from '../constants';\nimport ERC20_ABI from '../constants/abis/erc20';\nimport { getContract, getFactoryContract, getExchangeContract, isAddress } from '../utils';\nimport { injected } from '../connectors';\nexport function useWeb3React() {\n  const context = useWeb3ReactCore();\n  const contextNetwork = useWeb3ReactCore(NetworkContextName);\n  return context.active ? context : contextNetwork;\n}\nexport function useEagerConnect() {\n  const {\n    activate,\n    active\n  } = useWeb3ReactCore(); // specifically using useWeb3ReactCore because of what this hook does\n\n  const [tried, setTried] = useState(false);\n  useEffect(() => {\n    injected.isAuthorized().then(isAuthorized => {\n      if (isAuthorized) {\n        activate(injected, undefined, true).catch(() => {\n          setTried(true);\n        });\n      } else {\n        if (isMobile && window.ethereum) {\n          activate(injected, undefined, true).catch(() => {\n            setTried(true);\n          });\n        } else {\n          setTried(true);\n        }\n      }\n    });\n  }, [activate]); // intentionally only running on mount (make sure it's only mounted once :))\n  // if the connection worked, wait until we get confirmation of that to flip the flag\n\n  useEffect(() => {\n    if (active) {\n      setTried(true);\n    }\n  }, [active]);\n  return tried;\n}\n/**\n * Use for network and injected - logs user in\n * and out after checking what network theyre on\n */\n\nexport function useInactiveListener(suppress = false) {\n  const {\n    active,\n    error,\n    activate\n  } = useWeb3ReactCore(); // specifically using useWeb3React because of what this hook does\n\n  useEffect(() => {\n    const {\n      ethereum\n    } = window;\n\n    if (ethereum && ethereum.on && !active && !error && !suppress) {\n      const handleChainChanged = () => {\n        // eat errors\n        activate(injected, undefined, true).catch(() => {});\n      };\n\n      const handleAccountsChanged = accounts => {\n        if (accounts.length > 0) {\n          // eat errors\n          activate(injected, undefined, true).catch(() => {});\n        }\n      };\n\n      const handleNetworkChanged = () => {\n        // eat errors\n        activate(injected, undefined, true).catch(() => {});\n      };\n\n      ethereum.on('chainChanged', handleChainChanged);\n      ethereum.on('networkChanged', handleNetworkChanged);\n      ethereum.on('accountsChanged', handleAccountsChanged);\n      return () => {\n        if (ethereum.removeListener) {\n          ethereum.removeListener('chainChanged', handleChainChanged);\n          ethereum.removeListener('networkChanged', handleNetworkChanged);\n          ethereum.removeListener('accountsChanged', handleAccountsChanged);\n        }\n      };\n    }\n\n    return () => {};\n  }, [active, error, suppress, activate]);\n} // modified from https://usehooks.com/useDebounce/\n\nexport function useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  useEffect(() => {\n    // Update debounced value after delay\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay); // Cancel the timeout if value changes (also on delay change or unmount)\n    // This is how we prevent debounced value from updating if value is changed ...\n    // .. within the delay period. Timeout gets cleared and restarted.\n\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n  return debouncedValue;\n} // modified from https://usehooks.com/useKeyPress/\n\nexport function useBodyKeyDown(targetKey, onKeyDown, suppressOnKeyDown = false) {\n  const downHandler = useCallback(event => {\n    const {\n      target: {\n        tagName\n      },\n      key\n    } = event;\n\n    if (key === targetKey && tagName === 'BODY' && !suppressOnKeyDown) {\n      event.preventDefault();\n      onKeyDown();\n    }\n  }, [targetKey, onKeyDown, suppressOnKeyDown]);\n  useEffect(() => {\n    window.addEventListener('keydown', downHandler);\n    return () => {\n      window.removeEventListener('keydown', downHandler);\n    };\n  }, [downHandler]);\n}\nexport function useENSName(address) {\n  const {\n    library\n  } = useWeb3React();\n  const [ENSName, setENSName] = useState();\n  useEffect(() => {\n    if (isAddress(address)) {\n      let stale = false;\n      library.lookupAddress(address).then(name => {\n        if (!stale) {\n          if (name) {\n            setENSName(name);\n          } else {\n            setENSName(null);\n          }\n        }\n      }).catch(() => {\n        if (!stale) {\n          setENSName(null);\n        }\n      });\n      return () => {\n        stale = true;\n        setENSName();\n      };\n    }\n  }, [library, address]);\n  return ENSName;\n} // returns null on errors\n\nexport function useContract(address, ABI, withSignerIfPossible = true) {\n  const {\n    library,\n    account\n  } = useWeb3React();\n  return useMemo(() => {\n    try {\n      return getContract(address, ABI, library, withSignerIfPossible ? account : undefined);\n    } catch {\n      return null;\n    }\n  }, [address, ABI, library, withSignerIfPossible, account]);\n} // returns null on errors\n\nexport function useTokenContract(tokenAddress, withSignerIfPossible = true) {\n  const {\n    library,\n    account\n  } = useWeb3React();\n  return useMemo(() => {\n    try {\n      return getContract(tokenAddress, ERC20_ABI, library, withSignerIfPossible ? account : undefined);\n    } catch {\n      return null;\n    }\n  }, [tokenAddress, library, withSignerIfPossible, account]);\n} // returns null on errors\n\nexport function useFactoryContract(withSignerIfPossible = true) {\n  const {\n    chainId,\n    library,\n    account\n  } = useWeb3React();\n  return useMemo(() => {\n    try {\n      return getFactoryContract(chainId, library, withSignerIfPossible ? account : undefined);\n    } catch {\n      return null;\n    }\n  }, [chainId, library, withSignerIfPossible, account]);\n}\nexport function useExchangeContract(exchangeAddress, withSignerIfPossible = true) {\n  const {\n    library,\n    account\n  } = useWeb3React();\n  return useMemo(() => {\n    try {\n      return getExchangeContract(exchangeAddress, library, withSignerIfPossible ? account : undefined);\n    } catch {\n      return null;\n    }\n  }, [exchangeAddress, library, withSignerIfPossible, account]);\n}\nexport function useCopyClipboard(timeout = 500) {\n  const [isCopied, setIsCopied] = useState(false);\n  const staticCopy = useCallback(text => {\n    const didCopy = copy(text);\n    setIsCopied(didCopy);\n  }, []);\n  useEffect(() => {\n    if (isCopied) {\n      const hide = setTimeout(() => {\n        setIsCopied(false);\n      }, timeout);\n      return () => {\n        clearTimeout(hide);\n      };\n    }\n  }, [isCopied, setIsCopied, timeout]);\n  return [isCopied, staticCopy];\n} // modified from https://usehooks.com/usePrevious/\n\nexport function usePrevious(value) {\n  // The ref object is a generic container whose current property is mutable ...\n  // ... and can hold any value, similar to an instance property on a class\n  const ref = useRef(); // Store current value in ref\n\n  useEffect(() => {\n    ref.current = value;\n  }, [value]); // Only re-run if value changes\n  // Return previous value (happens before update in useEffect above)\n\n  return ref.current;\n}","map":{"version":3,"sources":["/Users/kerp/Documents/GitHub/landing-page/src/hooks/index.js"],"names":["useState","useMemo","useCallback","useEffect","useRef","useWeb3React","useWeb3ReactCore","copy","isMobile","NetworkContextName","ERC20_ABI","getContract","getFactoryContract","getExchangeContract","isAddress","injected","context","contextNetwork","active","useEagerConnect","activate","tried","setTried","isAuthorized","then","undefined","catch","window","ethereum","useInactiveListener","suppress","error","on","handleChainChanged","handleAccountsChanged","accounts","length","handleNetworkChanged","removeListener","useDebounce","value","delay","debouncedValue","setDebouncedValue","handler","setTimeout","clearTimeout","useBodyKeyDown","targetKey","onKeyDown","suppressOnKeyDown","downHandler","event","target","tagName","key","preventDefault","addEventListener","removeEventListener","useENSName","address","library","ENSName","setENSName","stale","lookupAddress","name","useContract","ABI","withSignerIfPossible","account","useTokenContract","tokenAddress","useFactoryContract","chainId","useExchangeContract","exchangeAddress","useCopyClipboard","timeout","isCopied","setIsCopied","staticCopy","text","didCopy","hide","usePrevious","ref","current"],"mappings":"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","sourcesContent":["import { useState, useMemo, useCallback, useEffect, useRef } from 'react'\nimport { useWeb3React as useWeb3ReactCore } from '@web3-react/core'\nimport copy from 'copy-to-clipboard'\nimport { isMobile } from 'react-device-detect'\n\nimport { NetworkContextName } from '../constants'\nimport ERC20_ABI from '../constants/abis/erc20'\nimport { getContract, getFactoryContract, getExchangeContract, isAddress } from '../utils'\nimport { injected } from '../connectors'\n\nexport function useWeb3React() {\n  const context = useWeb3ReactCore()\n  const contextNetwork = useWeb3ReactCore(NetworkContextName)\n\n  return context.active ? context : contextNetwork\n}\n\nexport function useEagerConnect() {\n  const { activate, active } = useWeb3ReactCore() // specifically using useWeb3ReactCore because of what this hook does\n\n  const [tried, setTried] = useState(false)\n\n  useEffect(() => {\n    injected.isAuthorized().then(isAuthorized => {\n      if (isAuthorized) {\n        activate(injected, undefined, true).catch(() => {\n          setTried(true)\n        })\n      } else {\n        if (isMobile && window.ethereum) {\n          activate(injected, undefined, true).catch(() => {\n            setTried(true)\n          })\n        } else {\n          setTried(true)\n        }\n      }\n    })\n  }, [activate]) // intentionally only running on mount (make sure it's only mounted once :))\n\n  // if the connection worked, wait until we get confirmation of that to flip the flag\n  useEffect(() => {\n    if (active) {\n      setTried(true)\n    }\n  }, [active])\n\n  return tried\n}\n\n/**\n * Use for network and injected - logs user in\n * and out after checking what network theyre on\n */\nexport function useInactiveListener(suppress = false) {\n  const { active, error, activate } = useWeb3ReactCore() // specifically using useWeb3React because of what this hook does\n\n  useEffect(() => {\n    const { ethereum } = window\n\n    if (ethereum && ethereum.on && !active && !error && !suppress) {\n      const handleChainChanged = () => {\n        // eat errors\n        activate(injected, undefined, true).catch(() => {})\n      }\n\n      const handleAccountsChanged = accounts => {\n        if (accounts.length > 0) {\n          // eat errors\n          activate(injected, undefined, true).catch(() => {})\n        }\n      }\n\n      const handleNetworkChanged = () => {\n        // eat errors\n        activate(injected, undefined, true).catch(() => {})\n      }\n\n      ethereum.on('chainChanged', handleChainChanged)\n      ethereum.on('networkChanged', handleNetworkChanged)\n      ethereum.on('accountsChanged', handleAccountsChanged)\n\n      return () => {\n        if (ethereum.removeListener) {\n          ethereum.removeListener('chainChanged', handleChainChanged)\n          ethereum.removeListener('networkChanged', handleNetworkChanged)\n          ethereum.removeListener('accountsChanged', handleAccountsChanged)\n        }\n      }\n    }\n\n    return () => {}\n  }, [active, error, suppress, activate])\n}\n\n// modified from https://usehooks.com/useDebounce/\nexport function useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value)\n\n  useEffect(() => {\n    // Update debounced value after delay\n    const handler = setTimeout(() => {\n      setDebouncedValue(value)\n    }, delay)\n\n    // Cancel the timeout if value changes (also on delay change or unmount)\n    // This is how we prevent debounced value from updating if value is changed ...\n    // .. within the delay period. Timeout gets cleared and restarted.\n    return () => {\n      clearTimeout(handler)\n    }\n  }, [value, delay])\n\n  return debouncedValue\n}\n\n// modified from https://usehooks.com/useKeyPress/\nexport function useBodyKeyDown(targetKey, onKeyDown, suppressOnKeyDown = false) {\n  const downHandler = useCallback(\n    event => {\n      const {\n        target: { tagName },\n        key\n      } = event\n      if (key === targetKey && tagName === 'BODY' && !suppressOnKeyDown) {\n        event.preventDefault()\n        onKeyDown()\n      }\n    },\n    [targetKey, onKeyDown, suppressOnKeyDown]\n  )\n\n  useEffect(() => {\n    window.addEventListener('keydown', downHandler)\n    return () => {\n      window.removeEventListener('keydown', downHandler)\n    }\n  }, [downHandler])\n}\n\nexport function useENSName(address) {\n  const { library } = useWeb3React()\n\n  const [ENSName, setENSName] = useState()\n\n  useEffect(() => {\n    if (isAddress(address)) {\n      let stale = false\n      library\n        .lookupAddress(address)\n        .then(name => {\n          if (!stale) {\n            if (name) {\n              setENSName(name)\n            } else {\n              setENSName(null)\n            }\n          }\n        })\n        .catch(() => {\n          if (!stale) {\n            setENSName(null)\n          }\n        })\n\n      return () => {\n        stale = true\n        setENSName()\n      }\n    }\n  }, [library, address])\n\n  return ENSName\n}\n\n// returns null on errors\nexport function useContract(address, ABI, withSignerIfPossible = true) {\n  const { library, account } = useWeb3React()\n\n  return useMemo(() => {\n    try {\n      return getContract(address, ABI, library, withSignerIfPossible ? account : undefined)\n    } catch {\n      return null\n    }\n  }, [address, ABI, library, withSignerIfPossible, account])\n}\n\n// returns null on errors\nexport function useTokenContract(tokenAddress, withSignerIfPossible = true) {\n  const { library, account } = useWeb3React()\n\n  return useMemo(() => {\n    try {\n      return getContract(tokenAddress, ERC20_ABI, library, withSignerIfPossible ? account : undefined)\n    } catch {\n      return null\n    }\n  }, [tokenAddress, library, withSignerIfPossible, account])\n}\n\n// returns null on errors\nexport function useFactoryContract(withSignerIfPossible = true) {\n  const { chainId, library, account } = useWeb3React()\n\n  return useMemo(() => {\n    try {\n      return getFactoryContract(chainId, library, withSignerIfPossible ? account : undefined)\n    } catch {\n      return null\n    }\n  }, [chainId, library, withSignerIfPossible, account])\n}\n\nexport function useExchangeContract(exchangeAddress, withSignerIfPossible = true) {\n  const { library, account } = useWeb3React()\n\n  return useMemo(() => {\n    try {\n      return getExchangeContract(exchangeAddress, library, withSignerIfPossible ? account : undefined)\n    } catch {\n      return null\n    }\n  }, [exchangeAddress, library, withSignerIfPossible, account])\n}\n\nexport function useCopyClipboard(timeout = 500) {\n  const [isCopied, setIsCopied] = useState(false)\n\n  const staticCopy = useCallback(text => {\n    const didCopy = copy(text)\n    setIsCopied(didCopy)\n  }, [])\n\n  useEffect(() => {\n    if (isCopied) {\n      const hide = setTimeout(() => {\n        setIsCopied(false)\n      }, timeout)\n\n      return () => {\n        clearTimeout(hide)\n      }\n    }\n  }, [isCopied, setIsCopied, timeout])\n\n  return [isCopied, staticCopy]\n}\n\n// modified from https://usehooks.com/usePrevious/\nexport function usePrevious(value) {\n  // The ref object is a generic container whose current property is mutable ...\n  // ... and can hold any value, similar to an instance property on a class\n  const ref = useRef()\n\n  // Store current value in ref\n  useEffect(() => {\n    ref.current = value\n  }, [value]) // Only re-run if value changes\n\n  // Return previous value (happens before update in useEffect above)\n  return ref.current\n}\n"]},"metadata":{},"sourceType":"module"}