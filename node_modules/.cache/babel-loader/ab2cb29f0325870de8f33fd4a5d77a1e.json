{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _ = require(\"lodash\");\n\nfunction parseNode(node) {\n  var components = [];\n\n  _.each(node.children, function (child) {\n    var component = parseNode(child);\n    components.push(component);\n  });\n\n  var dataItem = {\n    name: node.name,\n    type: node.value\n  };\n\n  if (!_.isEmpty(components)) {\n    dataItem.components = components;\n  }\n\n  return dataItem;\n}\n/**\n * Returns a DataItem corresponding to the input signature.\n * A signature can be in two forms: `type` or `(type_1,type_2,...,type_n)`\n * An example of the first form would be 'address' or 'uint256[]' or 'bytes[5][]'\n * An example of the second form would be '(address,uint256)' or '(address,uint256)[]'\n * @param signature of input DataItem.\n * @return DataItem derived from input signature.\n */\n\n\nfunction generateDataItemFromSignature(signature) {\n  var e_1, _a; // No data item corresponds to an empty signature\n\n\n  if (_.isEmpty(signature)) {\n    throw new Error(\"Cannot parse data item from empty signature, ''\");\n  } // Create a parse tree for data item\n\n\n  var node = {\n    name: '',\n    value: '',\n    children: []\n  };\n\n  try {\n    for (var signature_1 = __values(signature), signature_1_1 = signature_1.next(); !signature_1_1.done; signature_1_1 = signature_1.next()) {\n      var char = signature_1_1.value;\n\n      switch (char) {\n        case '(':\n          var child = {\n            name: '',\n            value: '',\n            children: [],\n            parent: node\n          };\n          node.value = 'tuple';\n          node.children.push(child);\n          node = child;\n          break;\n\n        case ')':\n          node = node.parent;\n          break;\n\n        case ',':\n          var sibling = {\n            name: '',\n            value: '',\n            children: [],\n            parent: node.parent\n          };\n          node.parent.children.push(sibling);\n          node = sibling;\n          break;\n\n        case ' ':\n          node.name = node.value;\n          node.value = '';\n          break;\n\n        default:\n          node.value += char;\n          break;\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (signature_1_1 && !signature_1_1.done && (_a = signature_1.return)) _a.call(signature_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  } // Interpret data item from parse tree\n\n\n  var dataItem = parseNode(node);\n  return dataItem;\n}\n\nexports.generateDataItemFromSignature = generateDataItemFromSignature;","map":{"version":3,"sources":["../../../../src/abi_encoder/utils/signature_parser.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AACA,IAAA,CAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AASA,SAAS,SAAT,CAAmB,IAAnB,EAA6B;AACzB,MAAM,UAAU,GAAe,EAA/B;;AACA,EAAA,CAAC,CAAC,IAAF,CAAO,IAAI,CAAC,QAAZ,EAAsB,UAAC,KAAD,EAAY;AAC9B,QAAM,SAAS,GAAG,SAAS,CAAC,KAAD,CAA3B;AACA,IAAA,UAAU,CAAC,IAAX,CAAgB,SAAhB;AACH,GAHD;;AAIA,MAAM,QAAQ,GAAa;AACvB,IAAA,IAAI,EAAE,IAAI,CAAC,IADY;AAEvB,IAAA,IAAI,EAAE,IAAI,CAAC;AAFY,GAA3B;;AAIA,MAAI,CAAC,CAAC,CAAC,OAAF,CAAU,UAAV,CAAL,EAA4B;AACxB,IAAA,QAAQ,CAAC,UAAT,GAAsB,UAAtB;AACH;;AACD,SAAO,QAAP;AACH;AAED;;;;;;;;;;AAQA,SAAgB,6BAAhB,CAA8C,SAA9C,EAA+D;cAAA,CAC3D;;;AACA,MAAI,CAAC,CAAC,OAAF,CAAU,SAAV,CAAJ,EAA0B;AACtB,UAAM,IAAI,KAAJ,CAAU,iDAAV,CAAN;AACH,GAJ0D,CAK3D;;;AACA,MAAI,IAAI,GAAS;AACb,IAAA,IAAI,EAAE,EADO;AAEb,IAAA,KAAK,EAAE,EAFM;AAGb,IAAA,QAAQ,EAAE;AAHG,GAAjB;;;AAKA,SAAmB,IAAA,WAAA,GAAA,QAAA,CAAA,SAAA,CAAA,EAAS,aAAA,GAAA,WAAA,CAAA,IAAA,EAA5B,EAA4B,CAAA,aAAA,CAAA,IAA5B,EAA4B,aAAA,GAAA,WAAA,CAAA,IAAA,EAA5B,EAA8B;AAAzB,UAAM,IAAI,GAAA,aAAA,CAAA,KAAV;;AACD,cAAQ,IAAR;AACI,aAAK,GAAL;AACI,cAAM,KAAK,GAAG;AACV,YAAA,IAAI,EAAE,EADI;AAEV,YAAA,KAAK,EAAE,EAFG;AAGV,YAAA,QAAQ,EAAE,EAHA;AAIV,YAAA,MAAM,EAAE;AAJE,WAAd;AAMA,UAAA,IAAI,CAAC,KAAL,GAAa,OAAb;AACA,UAAA,IAAI,CAAC,QAAL,CAAc,IAAd,CAAmB,KAAnB;AACA,UAAA,IAAI,GAAG,KAAP;AACA;;AAEJ,aAAK,GAAL;AACI,UAAA,IAAI,GAAG,IAAI,CAAC,MAAZ;AACA;;AAEJ,aAAK,GAAL;AACI,cAAM,OAAO,GAAG;AACZ,YAAA,IAAI,EAAE,EADM;AAEZ,YAAA,KAAK,EAAE,EAFK;AAGZ,YAAA,QAAQ,EAAE,EAHE;AAIZ,YAAA,MAAM,EAAE,IAAI,CAAC;AAJD,WAAhB;AAMC,UAAA,IAAI,CAAC,MAAL,CAAqB,QAArB,CAA8B,IAA9B,CAAmC,OAAnC;AACD,UAAA,IAAI,GAAG,OAAP;AACA;;AAEJ,aAAK,GAAL;AACI,UAAA,IAAI,CAAC,IAAL,GAAY,IAAI,CAAC,KAAjB;AACA,UAAA,IAAI,CAAC,KAAL,GAAa,EAAb;AACA;;AAEJ;AACI,UAAA,IAAI,CAAC,KAAL,IAAc,IAAd;AACA;AAnCR;AAqCH;;;;;;;;;;;GAjD0D,CAkD3D;;;AACA,MAAM,QAAQ,GAAG,SAAS,CAAC,IAAD,CAA1B;AACA,SAAO,QAAP;AACH;;AArDD,OAAA,CAAA,6BAAA,GAAA,6BAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _ = require(\"lodash\");\nfunction parseNode(node) {\n    var components = [];\n    _.each(node.children, function (child) {\n        var component = parseNode(child);\n        components.push(component);\n    });\n    var dataItem = {\n        name: node.name,\n        type: node.value,\n    };\n    if (!_.isEmpty(components)) {\n        dataItem.components = components;\n    }\n    return dataItem;\n}\n/**\n * Returns a DataItem corresponding to the input signature.\n * A signature can be in two forms: `type` or `(type_1,type_2,...,type_n)`\n * An example of the first form would be 'address' or 'uint256[]' or 'bytes[5][]'\n * An example of the second form would be '(address,uint256)' or '(address,uint256)[]'\n * @param signature of input DataItem.\n * @return DataItem derived from input signature.\n */\nfunction generateDataItemFromSignature(signature) {\n    var e_1, _a;\n    // No data item corresponds to an empty signature\n    if (_.isEmpty(signature)) {\n        throw new Error(\"Cannot parse data item from empty signature, ''\");\n    }\n    // Create a parse tree for data item\n    var node = {\n        name: '',\n        value: '',\n        children: [],\n    };\n    try {\n        for (var signature_1 = __values(signature), signature_1_1 = signature_1.next(); !signature_1_1.done; signature_1_1 = signature_1.next()) {\n            var char = signature_1_1.value;\n            switch (char) {\n                case '(':\n                    var child = {\n                        name: '',\n                        value: '',\n                        children: [],\n                        parent: node,\n                    };\n                    node.value = 'tuple';\n                    node.children.push(child);\n                    node = child;\n                    break;\n                case ')':\n                    node = node.parent;\n                    break;\n                case ',':\n                    var sibling = {\n                        name: '',\n                        value: '',\n                        children: [],\n                        parent: node.parent,\n                    };\n                    node.parent.children.push(sibling);\n                    node = sibling;\n                    break;\n                case ' ':\n                    node.name = node.value;\n                    node.value = '';\n                    break;\n                default:\n                    node.value += char;\n                    break;\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (signature_1_1 && !signature_1_1.done && (_a = signature_1.return)) _a.call(signature_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    // Interpret data item from parse tree\n    var dataItem = parseNode(node);\n    return dataItem;\n}\nexports.generateDataItemFromSignature = generateDataItemFromSignature;\n//# sourceMappingURL=signature_parser.js.map"]},"metadata":{},"sourceType":"script"}