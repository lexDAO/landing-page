{"ast":null,"code":"'use strict';\n\nexports.__esModule = true; // istanbul ignore next\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nvar _base = require('../base');\n\nvar _exception = require('../exception');\n\nvar _exception2 = _interopRequireDefault(_exception);\n\nvar _utils = require('../utils');\n\nvar _codeGen = require('./code-gen');\n\nvar _codeGen2 = _interopRequireDefault(_codeGen);\n\nfunction Literal(value) {\n  this.value = value;\n}\n\nfunction JavaScriptCompiler() {}\n\nJavaScriptCompiler.prototype = {\n  // PUBLIC API: You can override these methods in a subclass to provide\n  // alternative compiled forms for name lookup and buffering semantics\n  nameLookup: function nameLookup(parent, name\n  /*,  type */\n  ) {\n    return this.internalNameLookup(parent, name);\n  },\n  depthedLookup: function depthedLookup(name) {\n    return [this.aliasable('container.lookup'), '(depths, \"', name, '\")'];\n  },\n  compilerInfo: function compilerInfo() {\n    var revision = _base.COMPILER_REVISION,\n        versions = _base.REVISION_CHANGES[revision];\n    return [revision, versions];\n  },\n  appendToBuffer: function appendToBuffer(source, location, explicit) {\n    // Force a source as this simplifies the merge logic.\n    if (!_utils.isArray(source)) {\n      source = [source];\n    }\n\n    source = this.source.wrap(source, location);\n\n    if (this.environment.isSimple) {\n      return ['return ', source, ';'];\n    } else if (explicit) {\n      // This is a case where the buffer operation occurs as a child of another\n      // construct, generally braces. We have to explicitly output these buffer\n      // operations to ensure that the emitted code goes in the correct location.\n      return ['buffer += ', source, ';'];\n    } else {\n      source.appendToBuffer = true;\n      return source;\n    }\n  },\n  initializeBuffer: function initializeBuffer() {\n    return this.quotedString('');\n  },\n  // END PUBLIC API\n  internalNameLookup: function internalNameLookup(parent, name) {\n    this.lookupPropertyFunctionIsUsed = true;\n    return ['lookupProperty(', parent, ',', JSON.stringify(name), ')'];\n  },\n  lookupPropertyFunctionIsUsed: false,\n  compile: function compile(environment, options, context, asObject) {\n    this.environment = environment;\n    this.options = options;\n    this.stringParams = this.options.stringParams;\n    this.trackIds = this.options.trackIds;\n    this.precompile = !asObject;\n    this.name = this.environment.name;\n    this.isChild = !!context;\n    this.context = context || {\n      decorators: [],\n      programs: [],\n      environments: []\n    };\n    this.preamble();\n    this.stackSlot = 0;\n    this.stackVars = [];\n    this.aliases = {};\n    this.registers = {\n      list: []\n    };\n    this.hashes = [];\n    this.compileStack = [];\n    this.inlineStack = [];\n    this.blockParams = [];\n    this.compileChildren(environment, options);\n    this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;\n    this.useBlockParams = this.useBlockParams || environment.useBlockParams;\n    var opcodes = environment.opcodes,\n        opcode = undefined,\n        firstLoc = undefined,\n        i = undefined,\n        l = undefined;\n\n    for (i = 0, l = opcodes.length; i < l; i++) {\n      opcode = opcodes[i];\n      this.source.currentLocation = opcode.loc;\n      firstLoc = firstLoc || opcode.loc;\n      this[opcode.opcode].apply(this, opcode.args);\n    } // Flush any trailing content that might be pending.\n\n\n    this.source.currentLocation = firstLoc;\n    this.pushSource('');\n    /* istanbul ignore next */\n\n    if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {\n      throw new _exception2['default']('Compile completed with content left on stack');\n    }\n\n    if (!this.decorators.isEmpty()) {\n      this.useDecorators = true;\n      this.decorators.prepend(['var decorators = container.decorators, ', this.lookupPropertyFunctionVarDeclaration(), ';\\n']);\n      this.decorators.push('return fn;');\n\n      if (asObject) {\n        this.decorators = Function.apply(this, ['fn', 'props', 'container', 'depth0', 'data', 'blockParams', 'depths', this.decorators.merge()]);\n      } else {\n        this.decorators.prepend('function(fn, props, container, depth0, data, blockParams, depths) {\\n');\n        this.decorators.push('}\\n');\n        this.decorators = this.decorators.merge();\n      }\n    } else {\n      this.decorators = undefined;\n    }\n\n    var fn = this.createFunctionContext(asObject);\n\n    if (!this.isChild) {\n      var ret = {\n        compiler: this.compilerInfo(),\n        main: fn\n      };\n\n      if (this.decorators) {\n        ret.main_d = this.decorators; // eslint-disable-line camelcase\n\n        ret.useDecorators = true;\n      }\n\n      var _context = this.context;\n      var programs = _context.programs;\n      var decorators = _context.decorators;\n\n      for (i = 0, l = programs.length; i < l; i++) {\n        if (programs[i]) {\n          ret[i] = programs[i];\n\n          if (decorators[i]) {\n            ret[i + '_d'] = decorators[i];\n            ret.useDecorators = true;\n          }\n        }\n      }\n\n      if (this.environment.usePartial) {\n        ret.usePartial = true;\n      }\n\n      if (this.options.data) {\n        ret.useData = true;\n      }\n\n      if (this.useDepths) {\n        ret.useDepths = true;\n      }\n\n      if (this.useBlockParams) {\n        ret.useBlockParams = true;\n      }\n\n      if (this.options.compat) {\n        ret.compat = true;\n      }\n\n      if (!asObject) {\n        ret.compiler = JSON.stringify(ret.compiler);\n        this.source.currentLocation = {\n          start: {\n            line: 1,\n            column: 0\n          }\n        };\n        ret = this.objectLiteral(ret);\n\n        if (options.srcName) {\n          ret = ret.toStringWithSourceMap({\n            file: options.destName\n          });\n          ret.map = ret.map && ret.map.toString();\n        } else {\n          ret = ret.toString();\n        }\n      } else {\n        ret.compilerOptions = this.options;\n      }\n\n      return ret;\n    } else {\n      return fn;\n    }\n  },\n  preamble: function preamble() {\n    // track the last context pushed into place to allow skipping the\n    // getContext opcode when it would be a noop\n    this.lastContext = 0;\n    this.source = new _codeGen2['default'](this.options.srcName);\n    this.decorators = new _codeGen2['default'](this.options.srcName);\n  },\n  createFunctionContext: function createFunctionContext(asObject) {\n    // istanbul ignore next\n    var _this = this;\n\n    var varDeclarations = '';\n    var locals = this.stackVars.concat(this.registers.list);\n\n    if (locals.length > 0) {\n      varDeclarations += ', ' + locals.join(', ');\n    } // Generate minimizer alias mappings\n    //\n    // When using true SourceNodes, this will update all references to the given alias\n    // as the source nodes are reused in situ. For the non-source node compilation mode,\n    // aliases will not be used, but this case is already being run on the client and\n    // we aren't concern about minimizing the template size.\n\n\n    var aliasCount = 0;\n    Object.keys(this.aliases).forEach(function (alias) {\n      var node = _this.aliases[alias];\n\n      if (node.children && node.referenceCount > 1) {\n        varDeclarations += ', alias' + ++aliasCount + '=' + alias;\n        node.children[0] = 'alias' + aliasCount;\n      }\n    });\n\n    if (this.lookupPropertyFunctionIsUsed) {\n      varDeclarations += ', ' + this.lookupPropertyFunctionVarDeclaration();\n    }\n\n    var params = ['container', 'depth0', 'helpers', 'partials', 'data'];\n\n    if (this.useBlockParams || this.useDepths) {\n      params.push('blockParams');\n    }\n\n    if (this.useDepths) {\n      params.push('depths');\n    } // Perform a second pass over the output to merge content when possible\n\n\n    var source = this.mergeSource(varDeclarations);\n\n    if (asObject) {\n      params.push(source);\n      return Function.apply(this, params);\n    } else {\n      return this.source.wrap(['function(', params.join(','), ') {\\n  ', source, '}']);\n    }\n  },\n  mergeSource: function mergeSource(varDeclarations) {\n    var isSimple = this.environment.isSimple,\n        appendOnly = !this.forceBuffer,\n        appendFirst = undefined,\n        sourceSeen = undefined,\n        bufferStart = undefined,\n        bufferEnd = undefined;\n    this.source.each(function (line) {\n      if (line.appendToBuffer) {\n        if (bufferStart) {\n          line.prepend('  + ');\n        } else {\n          bufferStart = line;\n        }\n\n        bufferEnd = line;\n      } else {\n        if (bufferStart) {\n          if (!sourceSeen) {\n            appendFirst = true;\n          } else {\n            bufferStart.prepend('buffer += ');\n          }\n\n          bufferEnd.add(';');\n          bufferStart = bufferEnd = undefined;\n        }\n\n        sourceSeen = true;\n\n        if (!isSimple) {\n          appendOnly = false;\n        }\n      }\n    });\n\n    if (appendOnly) {\n      if (bufferStart) {\n        bufferStart.prepend('return ');\n        bufferEnd.add(';');\n      } else if (!sourceSeen) {\n        this.source.push('return \"\";');\n      }\n    } else {\n      varDeclarations += ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());\n\n      if (bufferStart) {\n        bufferStart.prepend('return buffer + ');\n        bufferEnd.add(';');\n      } else {\n        this.source.push('return buffer;');\n      }\n    }\n\n    if (varDeclarations) {\n      this.source.prepend('var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\\n'));\n    }\n\n    return this.source.merge();\n  },\n  lookupPropertyFunctionVarDeclaration: function lookupPropertyFunctionVarDeclaration() {\n    return '\\n      lookupProperty = container.lookupProperty || function(parent, propertyName) {\\n        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\\n          return parent[propertyName];\\n        }\\n        return undefined\\n    }\\n    '.trim();\n  },\n  // [blockValue]\n  //\n  // On stack, before: hash, inverse, program, value\n  // On stack, after: return value of blockHelperMissing\n  //\n  // The purpose of this opcode is to take a block of the form\n  // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and\n  // replace it on the stack with the result of properly\n  // invoking blockHelperMissing.\n  blockValue: function blockValue(name) {\n    var blockHelperMissing = this.aliasable('container.hooks.blockHelperMissing'),\n        params = [this.contextName(0)];\n    this.setupHelperArgs(name, 0, params);\n    var blockName = this.popStack();\n    params.splice(1, 0, blockName);\n    this.push(this.source.functionCall(blockHelperMissing, 'call', params));\n  },\n  // [ambiguousBlockValue]\n  //\n  // On stack, before: hash, inverse, program, value\n  // Compiler value, before: lastHelper=value of last found helper, if any\n  // On stack, after, if no lastHelper: same as [blockValue]\n  // On stack, after, if lastHelper: value\n  ambiguousBlockValue: function ambiguousBlockValue() {\n    // We're being a bit cheeky and reusing the options value from the prior exec\n    var blockHelperMissing = this.aliasable('container.hooks.blockHelperMissing'),\n        params = [this.contextName(0)];\n    this.setupHelperArgs('', 0, params, true);\n    this.flushInline();\n    var current = this.topStack();\n    params.splice(1, 0, current);\n    this.pushSource(['if (!', this.lastHelper, ') { ', current, ' = ', this.source.functionCall(blockHelperMissing, 'call', params), '}']);\n  },\n  // [appendContent]\n  //\n  // On stack, before: ...\n  // On stack, after: ...\n  //\n  // Appends the string value of `content` to the current buffer\n  appendContent: function appendContent(content) {\n    if (this.pendingContent) {\n      content = this.pendingContent + content;\n    } else {\n      this.pendingLocation = this.source.currentLocation;\n    }\n\n    this.pendingContent = content;\n  },\n  // [append]\n  //\n  // On stack, before: value, ...\n  // On stack, after: ...\n  //\n  // Coerces `value` to a String and appends it to the current buffer.\n  //\n  // If `value` is truthy, or 0, it is coerced into a string and appended\n  // Otherwise, the empty string is appended\n  append: function append() {\n    if (this.isInline()) {\n      this.replaceStack(function (current) {\n        return [' != null ? ', current, ' : \"\"'];\n      });\n      this.pushSource(this.appendToBuffer(this.popStack()));\n    } else {\n      var local = this.popStack();\n      this.pushSource(['if (', local, ' != null) { ', this.appendToBuffer(local, undefined, true), ' }']);\n\n      if (this.environment.isSimple) {\n        this.pushSource(['else { ', this.appendToBuffer(\"''\", undefined, true), ' }']);\n      }\n    }\n  },\n  // [appendEscaped]\n  //\n  // On stack, before: value, ...\n  // On stack, after: ...\n  //\n  // Escape `value` and append it to the buffer\n  appendEscaped: function appendEscaped() {\n    this.pushSource(this.appendToBuffer([this.aliasable('container.escapeExpression'), '(', this.popStack(), ')']));\n  },\n  // [getContext]\n  //\n  // On stack, before: ...\n  // On stack, after: ...\n  // Compiler value, after: lastContext=depth\n  //\n  // Set the value of the `lastContext` compiler value to the depth\n  getContext: function getContext(depth) {\n    this.lastContext = depth;\n  },\n  // [pushContext]\n  //\n  // On stack, before: ...\n  // On stack, after: currentContext, ...\n  //\n  // Pushes the value of the current context onto the stack.\n  pushContext: function pushContext() {\n    this.pushStackLiteral(this.contextName(this.lastContext));\n  },\n  // [lookupOnContext]\n  //\n  // On stack, before: ...\n  // On stack, after: currentContext[name], ...\n  //\n  // Looks up the value of `name` on the current context and pushes\n  // it onto the stack.\n  lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {\n    var i = 0;\n\n    if (!scoped && this.options.compat && !this.lastContext) {\n      // The depthed query is expected to handle the undefined logic for the root level that\n      // is implemented below, so we evaluate that directly in compat mode\n      this.push(this.depthedLookup(parts[i++]));\n    } else {\n      this.pushContext();\n    }\n\n    this.resolvePath('context', parts, i, falsy, strict);\n  },\n  // [lookupBlockParam]\n  //\n  // On stack, before: ...\n  // On stack, after: blockParam[name], ...\n  //\n  // Looks up the value of `parts` on the given block param and pushes\n  // it onto the stack.\n  lookupBlockParam: function lookupBlockParam(blockParamId, parts) {\n    this.useBlockParams = true;\n    this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);\n    this.resolvePath('context', parts, 1);\n  },\n  // [lookupData]\n  //\n  // On stack, before: ...\n  // On stack, after: data, ...\n  //\n  // Push the data lookup operator\n  lookupData: function lookupData(depth, parts, strict) {\n    if (!depth) {\n      this.pushStackLiteral('data');\n    } else {\n      this.pushStackLiteral('container.data(data, ' + depth + ')');\n    }\n\n    this.resolvePath('data', parts, 0, true, strict);\n  },\n  resolvePath: function resolvePath(type, parts, i, falsy, strict) {\n    // istanbul ignore next\n    var _this2 = this;\n\n    if (this.options.strict || this.options.assumeObjects) {\n      this.push(strictLookup(this.options.strict && strict, this, parts, type));\n      return;\n    }\n\n    var len = parts.length;\n\n    for (; i < len; i++) {\n      /* eslint-disable no-loop-func */\n      this.replaceStack(function (current) {\n        var lookup = _this2.nameLookup(current, parts[i], type); // We want to ensure that zero and false are handled properly if the context (falsy flag)\n        // needs to have the special handling for these values.\n\n\n        if (!falsy) {\n          return [' != null ? ', lookup, ' : ', current];\n        } else {\n          // Otherwise we can use generic falsy handling\n          return [' && ', lookup];\n        }\n      });\n      /* eslint-enable no-loop-func */\n    }\n  },\n  // [resolvePossibleLambda]\n  //\n  // On stack, before: value, ...\n  // On stack, after: resolved value, ...\n  //\n  // If the `value` is a lambda, replace it on the stack by\n  // the return value of the lambda\n  resolvePossibleLambda: function resolvePossibleLambda() {\n    this.push([this.aliasable('container.lambda'), '(', this.popStack(), ', ', this.contextName(0), ')']);\n  },\n  // [pushStringParam]\n  //\n  // On stack, before: ...\n  // On stack, after: string, currentContext, ...\n  //\n  // This opcode is designed for use in string mode, which\n  // provides the string value of a parameter along with its\n  // depth rather than resolving it immediately.\n  pushStringParam: function pushStringParam(string, type) {\n    this.pushContext();\n    this.pushString(type); // If it's a subexpression, the string result\n    // will be pushed after this opcode.\n\n    if (type !== 'SubExpression') {\n      if (typeof string === 'string') {\n        this.pushString(string);\n      } else {\n        this.pushStackLiteral(string);\n      }\n    }\n  },\n  emptyHash: function emptyHash(omitEmpty) {\n    if (this.trackIds) {\n      this.push('{}'); // hashIds\n    }\n\n    if (this.stringParams) {\n      this.push('{}'); // hashContexts\n\n      this.push('{}'); // hashTypes\n    }\n\n    this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');\n  },\n  pushHash: function pushHash() {\n    if (this.hash) {\n      this.hashes.push(this.hash);\n    }\n\n    this.hash = {\n      values: {},\n      types: [],\n      contexts: [],\n      ids: []\n    };\n  },\n  popHash: function popHash() {\n    var hash = this.hash;\n    this.hash = this.hashes.pop();\n\n    if (this.trackIds) {\n      this.push(this.objectLiteral(hash.ids));\n    }\n\n    if (this.stringParams) {\n      this.push(this.objectLiteral(hash.contexts));\n      this.push(this.objectLiteral(hash.types));\n    }\n\n    this.push(this.objectLiteral(hash.values));\n  },\n  // [pushString]\n  //\n  // On stack, before: ...\n  // On stack, after: quotedString(string), ...\n  //\n  // Push a quoted version of `string` onto the stack\n  pushString: function pushString(string) {\n    this.pushStackLiteral(this.quotedString(string));\n  },\n  // [pushLiteral]\n  //\n  // On stack, before: ...\n  // On stack, after: value, ...\n  //\n  // Pushes a value onto the stack. This operation prevents\n  // the compiler from creating a temporary variable to hold\n  // it.\n  pushLiteral: function pushLiteral(value) {\n    this.pushStackLiteral(value);\n  },\n  // [pushProgram]\n  //\n  // On stack, before: ...\n  // On stack, after: program(guid), ...\n  //\n  // Push a program expression onto the stack. This takes\n  // a compile-time guid and converts it into a runtime-accessible\n  // expression.\n  pushProgram: function pushProgram(guid) {\n    if (guid != null) {\n      this.pushStackLiteral(this.programExpression(guid));\n    } else {\n      this.pushStackLiteral(null);\n    }\n  },\n  // [registerDecorator]\n  //\n  // On stack, before: hash, program, params..., ...\n  // On stack, after: ...\n  //\n  // Pops off the decorator's parameters, invokes the decorator,\n  // and inserts the decorator into the decorators list.\n  registerDecorator: function registerDecorator(paramSize, name) {\n    var foundDecorator = this.nameLookup('decorators', name, 'decorator'),\n        options = this.setupHelperArgs(name, paramSize);\n    this.decorators.push(['fn = ', this.decorators.functionCall(foundDecorator, '', ['fn', 'props', 'container', options]), ' || fn;']);\n  },\n  // [invokeHelper]\n  //\n  // On stack, before: hash, inverse, program, params..., ...\n  // On stack, after: result of helper invocation\n  //\n  // Pops off the helper's parameters, invokes the helper,\n  // and pushes the helper's return value onto the stack.\n  //\n  // If the helper is not found, `helperMissing` is called.\n  invokeHelper: function invokeHelper(paramSize, name, isSimple) {\n    var nonHelper = this.popStack(),\n        helper = this.setupHelper(paramSize, name);\n    var possibleFunctionCalls = [];\n\n    if (isSimple) {\n      // direct call to helper\n      possibleFunctionCalls.push(helper.name);\n    } // call a function from the input object\n\n\n    possibleFunctionCalls.push(nonHelper);\n\n    if (!this.options.strict) {\n      possibleFunctionCalls.push(this.aliasable('container.hooks.helperMissing'));\n    }\n\n    var functionLookupCode = ['(', this.itemsSeparatedBy(possibleFunctionCalls, '||'), ')'];\n    var functionCall = this.source.functionCall(functionLookupCode, 'call', helper.callParams);\n    this.push(functionCall);\n  },\n  itemsSeparatedBy: function itemsSeparatedBy(items, separator) {\n    var result = [];\n    result.push(items[0]);\n\n    for (var i = 1; i < items.length; i++) {\n      result.push(separator, items[i]);\n    }\n\n    return result;\n  },\n  // [invokeKnownHelper]\n  //\n  // On stack, before: hash, inverse, program, params..., ...\n  // On stack, after: result of helper invocation\n  //\n  // This operation is used when the helper is known to exist,\n  // so a `helperMissing` fallback is not required.\n  invokeKnownHelper: function invokeKnownHelper(paramSize, name) {\n    var helper = this.setupHelper(paramSize, name);\n    this.push(this.source.functionCall(helper.name, 'call', helper.callParams));\n  },\n  // [invokeAmbiguous]\n  //\n  // On stack, before: hash, inverse, program, params..., ...\n  // On stack, after: result of disambiguation\n  //\n  // This operation is used when an expression like `{{foo}}`\n  // is provided, but we don't know at compile-time whether it\n  // is a helper or a path.\n  //\n  // This operation emits more code than the other options,\n  // and can be avoided by passing the `knownHelpers` and\n  // `knownHelpersOnly` flags at compile-time.\n  invokeAmbiguous: function invokeAmbiguous(name, helperCall) {\n    this.useRegister('helper');\n    var nonHelper = this.popStack();\n    this.emptyHash();\n    var helper = this.setupHelper(0, name, helperCall);\n    var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');\n    var lookup = ['(', '(helper = ', helperName, ' || ', nonHelper, ')'];\n\n    if (!this.options.strict) {\n      lookup[0] = '(helper = ';\n      lookup.push(' != null ? helper : ', this.aliasable('container.hooks.helperMissing'));\n    }\n\n    this.push(['(', lookup, helper.paramsInit ? ['),(', helper.paramsInit] : [], '),', '(typeof helper === ', this.aliasable('\"function\"'), ' ? ', this.source.functionCall('helper', 'call', helper.callParams), ' : helper))']);\n  },\n  // [invokePartial]\n  //\n  // On stack, before: context, ...\n  // On stack after: result of partial invocation\n  //\n  // This operation pops off a context, invokes a partial with that context,\n  // and pushes the result of the invocation back.\n  invokePartial: function invokePartial(isDynamic, name, indent) {\n    var params = [],\n        options = this.setupParams(name, 1, params);\n\n    if (isDynamic) {\n      name = this.popStack();\n      delete options.name;\n    }\n\n    if (indent) {\n      options.indent = JSON.stringify(indent);\n    }\n\n    options.helpers = 'helpers';\n    options.partials = 'partials';\n    options.decorators = 'container.decorators';\n\n    if (!isDynamic) {\n      params.unshift(this.nameLookup('partials', name, 'partial'));\n    } else {\n      params.unshift(name);\n    }\n\n    if (this.options.compat) {\n      options.depths = 'depths';\n    }\n\n    options = this.objectLiteral(options);\n    params.push(options);\n    this.push(this.source.functionCall('container.invokePartial', '', params));\n  },\n  // [assignToHash]\n  //\n  // On stack, before: value, ..., hash, ...\n  // On stack, after: ..., hash, ...\n  //\n  // Pops a value off the stack and assigns it to the current hash\n  assignToHash: function assignToHash(key) {\n    var value = this.popStack(),\n        context = undefined,\n        type = undefined,\n        id = undefined;\n\n    if (this.trackIds) {\n      id = this.popStack();\n    }\n\n    if (this.stringParams) {\n      type = this.popStack();\n      context = this.popStack();\n    }\n\n    var hash = this.hash;\n\n    if (context) {\n      hash.contexts[key] = context;\n    }\n\n    if (type) {\n      hash.types[key] = type;\n    }\n\n    if (id) {\n      hash.ids[key] = id;\n    }\n\n    hash.values[key] = value;\n  },\n  pushId: function pushId(type, name, child) {\n    if (type === 'BlockParam') {\n      this.pushStackLiteral('blockParams[' + name[0] + '].path[' + name[1] + ']' + (child ? ' + ' + JSON.stringify('.' + child) : ''));\n    } else if (type === 'PathExpression') {\n      this.pushString(name);\n    } else if (type === 'SubExpression') {\n      this.pushStackLiteral('true');\n    } else {\n      this.pushStackLiteral('null');\n    }\n  },\n  // HELPERS\n  compiler: JavaScriptCompiler,\n  compileChildren: function compileChildren(environment, options) {\n    var children = environment.children,\n        child = undefined,\n        compiler = undefined;\n\n    for (var i = 0, l = children.length; i < l; i++) {\n      child = children[i];\n      compiler = new this.compiler(); // eslint-disable-line new-cap\n\n      var existing = this.matchExistingProgram(child);\n\n      if (existing == null) {\n        this.context.programs.push(''); // Placeholder to prevent name conflicts for nested children\n\n        var index = this.context.programs.length;\n        child.index = index;\n        child.name = 'program' + index;\n        this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);\n        this.context.decorators[index] = compiler.decorators;\n        this.context.environments[index] = child;\n        this.useDepths = this.useDepths || compiler.useDepths;\n        this.useBlockParams = this.useBlockParams || compiler.useBlockParams;\n        child.useDepths = this.useDepths;\n        child.useBlockParams = this.useBlockParams;\n      } else {\n        child.index = existing.index;\n        child.name = 'program' + existing.index;\n        this.useDepths = this.useDepths || existing.useDepths;\n        this.useBlockParams = this.useBlockParams || existing.useBlockParams;\n      }\n    }\n  },\n  matchExistingProgram: function matchExistingProgram(child) {\n    for (var i = 0, len = this.context.environments.length; i < len; i++) {\n      var environment = this.context.environments[i];\n\n      if (environment && environment.equals(child)) {\n        return environment;\n      }\n    }\n  },\n  programExpression: function programExpression(guid) {\n    var child = this.environment.children[guid],\n        programParams = [child.index, 'data', child.blockParams];\n\n    if (this.useBlockParams || this.useDepths) {\n      programParams.push('blockParams');\n    }\n\n    if (this.useDepths) {\n      programParams.push('depths');\n    }\n\n    return 'container.program(' + programParams.join(', ') + ')';\n  },\n  useRegister: function useRegister(name) {\n    if (!this.registers[name]) {\n      this.registers[name] = true;\n      this.registers.list.push(name);\n    }\n  },\n  push: function push(expr) {\n    if (!(expr instanceof Literal)) {\n      expr = this.source.wrap(expr);\n    }\n\n    this.inlineStack.push(expr);\n    return expr;\n  },\n  pushStackLiteral: function pushStackLiteral(item) {\n    this.push(new Literal(item));\n  },\n  pushSource: function pushSource(source) {\n    if (this.pendingContent) {\n      this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));\n      this.pendingContent = undefined;\n    }\n\n    if (source) {\n      this.source.push(source);\n    }\n  },\n  replaceStack: function replaceStack(callback) {\n    var prefix = ['('],\n        stack = undefined,\n        createdStack = undefined,\n        usedLiteral = undefined;\n    /* istanbul ignore next */\n\n    if (!this.isInline()) {\n      throw new _exception2['default']('replaceStack on non-inline');\n    } // We want to merge the inline statement into the replacement statement via ','\n\n\n    var top = this.popStack(true);\n\n    if (top instanceof Literal) {\n      // Literals do not need to be inlined\n      stack = [top.value];\n      prefix = ['(', stack];\n      usedLiteral = true;\n    } else {\n      // Get or create the current stack name for use by the inline\n      createdStack = true;\n\n      var _name = this.incrStack();\n\n      prefix = ['((', this.push(_name), ' = ', top, ')'];\n      stack = this.topStack();\n    }\n\n    var item = callback.call(this, stack);\n\n    if (!usedLiteral) {\n      this.popStack();\n    }\n\n    if (createdStack) {\n      this.stackSlot--;\n    }\n\n    this.push(prefix.concat(item, ')'));\n  },\n  incrStack: function incrStack() {\n    this.stackSlot++;\n\n    if (this.stackSlot > this.stackVars.length) {\n      this.stackVars.push('stack' + this.stackSlot);\n    }\n\n    return this.topStackName();\n  },\n  topStackName: function topStackName() {\n    return 'stack' + this.stackSlot;\n  },\n  flushInline: function flushInline() {\n    var inlineStack = this.inlineStack;\n    this.inlineStack = [];\n\n    for (var i = 0, len = inlineStack.length; i < len; i++) {\n      var entry = inlineStack[i];\n      /* istanbul ignore if */\n\n      if (entry instanceof Literal) {\n        this.compileStack.push(entry);\n      } else {\n        var stack = this.incrStack();\n        this.pushSource([stack, ' = ', entry, ';']);\n        this.compileStack.push(stack);\n      }\n    }\n  },\n  isInline: function isInline() {\n    return this.inlineStack.length;\n  },\n  popStack: function popStack(wrapped) {\n    var inline = this.isInline(),\n        item = (inline ? this.inlineStack : this.compileStack).pop();\n\n    if (!wrapped && item instanceof Literal) {\n      return item.value;\n    } else {\n      if (!inline) {\n        /* istanbul ignore next */\n        if (!this.stackSlot) {\n          throw new _exception2['default']('Invalid stack pop');\n        }\n\n        this.stackSlot--;\n      }\n\n      return item;\n    }\n  },\n  topStack: function topStack() {\n    var stack = this.isInline() ? this.inlineStack : this.compileStack,\n        item = stack[stack.length - 1];\n    /* istanbul ignore if */\n\n    if (item instanceof Literal) {\n      return item.value;\n    } else {\n      return item;\n    }\n  },\n  contextName: function contextName(context) {\n    if (this.useDepths && context) {\n      return 'depths[' + context + ']';\n    } else {\n      return 'depth' + context;\n    }\n  },\n  quotedString: function quotedString(str) {\n    return this.source.quotedString(str);\n  },\n  objectLiteral: function objectLiteral(obj) {\n    return this.source.objectLiteral(obj);\n  },\n  aliasable: function aliasable(name) {\n    var ret = this.aliases[name];\n\n    if (ret) {\n      ret.referenceCount++;\n      return ret;\n    }\n\n    ret = this.aliases[name] = this.source.wrap(name);\n    ret.aliasable = true;\n    ret.referenceCount = 1;\n    return ret;\n  },\n  setupHelper: function setupHelper(paramSize, name, blockHelper) {\n    var params = [],\n        paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);\n    var foundHelper = this.nameLookup('helpers', name, 'helper'),\n        callContext = this.aliasable(this.contextName(0) + ' != null ? ' + this.contextName(0) + ' : (container.nullContext || {})');\n    return {\n      params: params,\n      paramsInit: paramsInit,\n      name: foundHelper,\n      callParams: [callContext].concat(params)\n    };\n  },\n  setupParams: function setupParams(helper, paramSize, params) {\n    var options = {},\n        contexts = [],\n        types = [],\n        ids = [],\n        objectArgs = !params,\n        param = undefined;\n\n    if (objectArgs) {\n      params = [];\n    }\n\n    options.name = this.quotedString(helper);\n    options.hash = this.popStack();\n\n    if (this.trackIds) {\n      options.hashIds = this.popStack();\n    }\n\n    if (this.stringParams) {\n      options.hashTypes = this.popStack();\n      options.hashContexts = this.popStack();\n    }\n\n    var inverse = this.popStack(),\n        program = this.popStack(); // Avoid setting fn and inverse if neither are set. This allows\n    // helpers to do a check for `if (options.fn)`\n\n    if (program || inverse) {\n      options.fn = program || 'container.noop';\n      options.inverse = inverse || 'container.noop';\n    } // The parameters go on to the stack in order (making sure that they are evaluated in order)\n    // so we need to pop them off the stack in reverse order\n\n\n    var i = paramSize;\n\n    while (i--) {\n      param = this.popStack();\n      params[i] = param;\n\n      if (this.trackIds) {\n        ids[i] = this.popStack();\n      }\n\n      if (this.stringParams) {\n        types[i] = this.popStack();\n        contexts[i] = this.popStack();\n      }\n    }\n\n    if (objectArgs) {\n      options.args = this.source.generateArray(params);\n    }\n\n    if (this.trackIds) {\n      options.ids = this.source.generateArray(ids);\n    }\n\n    if (this.stringParams) {\n      options.types = this.source.generateArray(types);\n      options.contexts = this.source.generateArray(contexts);\n    }\n\n    if (this.options.data) {\n      options.data = 'data';\n    }\n\n    if (this.useBlockParams) {\n      options.blockParams = 'blockParams';\n    }\n\n    return options;\n  },\n  setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {\n    var options = this.setupParams(helper, paramSize, params);\n    options.loc = JSON.stringify(this.source.currentLocation);\n    options = this.objectLiteral(options);\n\n    if (useRegister) {\n      this.useRegister('options');\n      params.push('options');\n      return ['options=', options];\n    } else if (params) {\n      params.push(options);\n      return '';\n    } else {\n      return options;\n    }\n  }\n};\n\n(function () {\n  var reservedWords = ('break else new var' + ' case finally return void' + ' catch for switch while' + ' continue function this with' + ' default if throw' + ' delete in try' + ' do instanceof typeof' + ' abstract enum int short' + ' boolean export interface static' + ' byte extends long super' + ' char final native synchronized' + ' class float package throws' + ' const goto private transient' + ' debugger implements protected volatile' + ' double import public let yield await' + ' null true false').split(' ');\n  var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};\n\n  for (var i = 0, l = reservedWords.length; i < l; i++) {\n    compilerWords[reservedWords[i]] = true;\n  }\n})();\n/**\n * @deprecated May be removed in the next major version\n */\n\n\nJavaScriptCompiler.isValidJavaScriptVariableName = function (name) {\n  return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);\n};\n\nfunction strictLookup(requireTerminal, compiler, parts, type) {\n  var stack = compiler.popStack(),\n      i = 0,\n      len = parts.length;\n\n  if (requireTerminal) {\n    len--;\n  }\n\n  for (; i < len; i++) {\n    stack = compiler.nameLookup(stack, parts[i], type);\n  }\n\n  if (requireTerminal) {\n    return [compiler.aliasable('container.strict'), '(', stack, ', ', compiler.quotedString(parts[i]), ', ', JSON.stringify(compiler.source.currentLocation), ' )'];\n  } else {\n    return stack;\n  }\n}\n\nexports['default'] = JavaScriptCompiler;\nmodule.exports = exports['default'];","map":{"version":3,"sources":["../../../../lib/handlebars/compiler/javascript-compiler.js"],"names":[],"mappings":"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","sourcesContent":["import { COMPILER_REVISION, REVISION_CHANGES } from '../base';\nimport Exception from '../exception';\nimport { isArray } from '../utils';\nimport CodeGen from './code-gen';\n\nfunction Literal(value) {\n  this.value = value;\n}\n\nfunction JavaScriptCompiler() {}\n\nJavaScriptCompiler.prototype = {\n  // PUBLIC API: You can override these methods in a subclass to provide\n  // alternative compiled forms for name lookup and buffering semantics\n  nameLookup: function(parent, name /*,  type */) {\n    return this.internalNameLookup(parent, name);\n  },\n  depthedLookup: function(name) {\n    return [this.aliasable('container.lookup'), '(depths, \"', name, '\")'];\n  },\n\n  compilerInfo: function() {\n    const revision = COMPILER_REVISION,\n      versions = REVISION_CHANGES[revision];\n    return [revision, versions];\n  },\n\n  appendToBuffer: function(source, location, explicit) {\n    // Force a source as this simplifies the merge logic.\n    if (!isArray(source)) {\n      source = [source];\n    }\n    source = this.source.wrap(source, location);\n\n    if (this.environment.isSimple) {\n      return ['return ', source, ';'];\n    } else if (explicit) {\n      // This is a case where the buffer operation occurs as a child of another\n      // construct, generally braces. We have to explicitly output these buffer\n      // operations to ensure that the emitted code goes in the correct location.\n      return ['buffer += ', source, ';'];\n    } else {\n      source.appendToBuffer = true;\n      return source;\n    }\n  },\n\n  initializeBuffer: function() {\n    return this.quotedString('');\n  },\n  // END PUBLIC API\n  internalNameLookup: function(parent, name) {\n    this.lookupPropertyFunctionIsUsed = true;\n    return ['lookupProperty(', parent, ',', JSON.stringify(name), ')'];\n  },\n\n  lookupPropertyFunctionIsUsed: false,\n\n  compile: function(environment, options, context, asObject) {\n    this.environment = environment;\n    this.options = options;\n    this.stringParams = this.options.stringParams;\n    this.trackIds = this.options.trackIds;\n    this.precompile = !asObject;\n\n    this.name = this.environment.name;\n    this.isChild = !!context;\n    this.context = context || {\n      decorators: [],\n      programs: [],\n      environments: []\n    };\n\n    this.preamble();\n\n    this.stackSlot = 0;\n    this.stackVars = [];\n    this.aliases = {};\n    this.registers = { list: [] };\n    this.hashes = [];\n    this.compileStack = [];\n    this.inlineStack = [];\n    this.blockParams = [];\n\n    this.compileChildren(environment, options);\n\n    this.useDepths =\n      this.useDepths ||\n      environment.useDepths ||\n      environment.useDecorators ||\n      this.options.compat;\n    this.useBlockParams = this.useBlockParams || environment.useBlockParams;\n\n    let opcodes = environment.opcodes,\n      opcode,\n      firstLoc,\n      i,\n      l;\n\n    for (i = 0, l = opcodes.length; i < l; i++) {\n      opcode = opcodes[i];\n\n      this.source.currentLocation = opcode.loc;\n      firstLoc = firstLoc || opcode.loc;\n      this[opcode.opcode].apply(this, opcode.args);\n    }\n\n    // Flush any trailing content that might be pending.\n    this.source.currentLocation = firstLoc;\n    this.pushSource('');\n\n    /* istanbul ignore next */\n    if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {\n      throw new Exception('Compile completed with content left on stack');\n    }\n\n    if (!this.decorators.isEmpty()) {\n      this.useDecorators = true;\n\n      this.decorators.prepend([\n        'var decorators = container.decorators, ',\n        this.lookupPropertyFunctionVarDeclaration(),\n        ';\\n'\n      ]);\n      this.decorators.push('return fn;');\n\n      if (asObject) {\n        this.decorators = Function.apply(this, [\n          'fn',\n          'props',\n          'container',\n          'depth0',\n          'data',\n          'blockParams',\n          'depths',\n          this.decorators.merge()\n        ]);\n      } else {\n        this.decorators.prepend(\n          'function(fn, props, container, depth0, data, blockParams, depths) {\\n'\n        );\n        this.decorators.push('}\\n');\n        this.decorators = this.decorators.merge();\n      }\n    } else {\n      this.decorators = undefined;\n    }\n\n    let fn = this.createFunctionContext(asObject);\n    if (!this.isChild) {\n      let ret = {\n        compiler: this.compilerInfo(),\n        main: fn\n      };\n\n      if (this.decorators) {\n        ret.main_d = this.decorators; // eslint-disable-line camelcase\n        ret.useDecorators = true;\n      }\n\n      let { programs, decorators } = this.context;\n      for (i = 0, l = programs.length; i < l; i++) {\n        if (programs[i]) {\n          ret[i] = programs[i];\n          if (decorators[i]) {\n            ret[i + '_d'] = decorators[i];\n            ret.useDecorators = true;\n          }\n        }\n      }\n\n      if (this.environment.usePartial) {\n        ret.usePartial = true;\n      }\n      if (this.options.data) {\n        ret.useData = true;\n      }\n      if (this.useDepths) {\n        ret.useDepths = true;\n      }\n      if (this.useBlockParams) {\n        ret.useBlockParams = true;\n      }\n      if (this.options.compat) {\n        ret.compat = true;\n      }\n\n      if (!asObject) {\n        ret.compiler = JSON.stringify(ret.compiler);\n\n        this.source.currentLocation = { start: { line: 1, column: 0 } };\n        ret = this.objectLiteral(ret);\n\n        if (options.srcName) {\n          ret = ret.toStringWithSourceMap({ file: options.destName });\n          ret.map = ret.map && ret.map.toString();\n        } else {\n          ret = ret.toString();\n        }\n      } else {\n        ret.compilerOptions = this.options;\n      }\n\n      return ret;\n    } else {\n      return fn;\n    }\n  },\n\n  preamble: function() {\n    // track the last context pushed into place to allow skipping the\n    // getContext opcode when it would be a noop\n    this.lastContext = 0;\n    this.source = new CodeGen(this.options.srcName);\n    this.decorators = new CodeGen(this.options.srcName);\n  },\n\n  createFunctionContext: function(asObject) {\n    let varDeclarations = '';\n\n    let locals = this.stackVars.concat(this.registers.list);\n    if (locals.length > 0) {\n      varDeclarations += ', ' + locals.join(', ');\n    }\n\n    // Generate minimizer alias mappings\n    //\n    // When using true SourceNodes, this will update all references to the given alias\n    // as the source nodes are reused in situ. For the non-source node compilation mode,\n    // aliases will not be used, but this case is already being run on the client and\n    // we aren't concern about minimizing the template size.\n    let aliasCount = 0;\n    Object.keys(this.aliases).forEach(alias => {\n      let node = this.aliases[alias];\n      if (node.children && node.referenceCount > 1) {\n        varDeclarations += ', alias' + ++aliasCount + '=' + alias;\n        node.children[0] = 'alias' + aliasCount;\n      }\n    });\n\n    if (this.lookupPropertyFunctionIsUsed) {\n      varDeclarations += ', ' + this.lookupPropertyFunctionVarDeclaration();\n    }\n\n    let params = ['container', 'depth0', 'helpers', 'partials', 'data'];\n\n    if (this.useBlockParams || this.useDepths) {\n      params.push('blockParams');\n    }\n    if (this.useDepths) {\n      params.push('depths');\n    }\n\n    // Perform a second pass over the output to merge content when possible\n    let source = this.mergeSource(varDeclarations);\n\n    if (asObject) {\n      params.push(source);\n\n      return Function.apply(this, params);\n    } else {\n      return this.source.wrap([\n        'function(',\n        params.join(','),\n        ') {\\n  ',\n        source,\n        '}'\n      ]);\n    }\n  },\n  mergeSource: function(varDeclarations) {\n    let isSimple = this.environment.isSimple,\n      appendOnly = !this.forceBuffer,\n      appendFirst,\n      sourceSeen,\n      bufferStart,\n      bufferEnd;\n    this.source.each(line => {\n      if (line.appendToBuffer) {\n        if (bufferStart) {\n          line.prepend('  + ');\n        } else {\n          bufferStart = line;\n        }\n        bufferEnd = line;\n      } else {\n        if (bufferStart) {\n          if (!sourceSeen) {\n            appendFirst = true;\n          } else {\n            bufferStart.prepend('buffer += ');\n          }\n          bufferEnd.add(';');\n          bufferStart = bufferEnd = undefined;\n        }\n\n        sourceSeen = true;\n        if (!isSimple) {\n          appendOnly = false;\n        }\n      }\n    });\n\n    if (appendOnly) {\n      if (bufferStart) {\n        bufferStart.prepend('return ');\n        bufferEnd.add(';');\n      } else if (!sourceSeen) {\n        this.source.push('return \"\";');\n      }\n    } else {\n      varDeclarations +=\n        ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());\n\n      if (bufferStart) {\n        bufferStart.prepend('return buffer + ');\n        bufferEnd.add(';');\n      } else {\n        this.source.push('return buffer;');\n      }\n    }\n\n    if (varDeclarations) {\n      this.source.prepend(\n        'var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\\n')\n      );\n    }\n\n    return this.source.merge();\n  },\n\n  lookupPropertyFunctionVarDeclaration: function() {\n    return `\n      lookupProperty = container.lookupProperty || function(parent, propertyName) {\n        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n          return parent[propertyName];\n        }\n        return undefined\n    }\n    `.trim();\n  },\n\n  // [blockValue]\n  //\n  // On stack, before: hash, inverse, program, value\n  // On stack, after: return value of blockHelperMissing\n  //\n  // The purpose of this opcode is to take a block of the form\n  // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and\n  // replace it on the stack with the result of properly\n  // invoking blockHelperMissing.\n  blockValue: function(name) {\n    let blockHelperMissing = this.aliasable(\n        'container.hooks.blockHelperMissing'\n      ),\n      params = [this.contextName(0)];\n    this.setupHelperArgs(name, 0, params);\n\n    let blockName = this.popStack();\n    params.splice(1, 0, blockName);\n\n    this.push(this.source.functionCall(blockHelperMissing, 'call', params));\n  },\n\n  // [ambiguousBlockValue]\n  //\n  // On stack, before: hash, inverse, program, value\n  // Compiler value, before: lastHelper=value of last found helper, if any\n  // On stack, after, if no lastHelper: same as [blockValue]\n  // On stack, after, if lastHelper: value\n  ambiguousBlockValue: function() {\n    // We're being a bit cheeky and reusing the options value from the prior exec\n    let blockHelperMissing = this.aliasable(\n        'container.hooks.blockHelperMissing'\n      ),\n      params = [this.contextName(0)];\n    this.setupHelperArgs('', 0, params, true);\n\n    this.flushInline();\n\n    let current = this.topStack();\n    params.splice(1, 0, current);\n\n    this.pushSource([\n      'if (!',\n      this.lastHelper,\n      ') { ',\n      current,\n      ' = ',\n      this.source.functionCall(blockHelperMissing, 'call', params),\n      '}'\n    ]);\n  },\n\n  // [appendContent]\n  //\n  // On stack, before: ...\n  // On stack, after: ...\n  //\n  // Appends the string value of `content` to the current buffer\n  appendContent: function(content) {\n    if (this.pendingContent) {\n      content = this.pendingContent + content;\n    } else {\n      this.pendingLocation = this.source.currentLocation;\n    }\n\n    this.pendingContent = content;\n  },\n\n  // [append]\n  //\n  // On stack, before: value, ...\n  // On stack, after: ...\n  //\n  // Coerces `value` to a String and appends it to the current buffer.\n  //\n  // If `value` is truthy, or 0, it is coerced into a string and appended\n  // Otherwise, the empty string is appended\n  append: function() {\n    if (this.isInline()) {\n      this.replaceStack(current => [' != null ? ', current, ' : \"\"']);\n\n      this.pushSource(this.appendToBuffer(this.popStack()));\n    } else {\n      let local = this.popStack();\n      this.pushSource([\n        'if (',\n        local,\n        ' != null) { ',\n        this.appendToBuffer(local, undefined, true),\n        ' }'\n      ]);\n      if (this.environment.isSimple) {\n        this.pushSource([\n          'else { ',\n          this.appendToBuffer(\"''\", undefined, true),\n          ' }'\n        ]);\n      }\n    }\n  },\n\n  // [appendEscaped]\n  //\n  // On stack, before: value, ...\n  // On stack, after: ...\n  //\n  // Escape `value` and append it to the buffer\n  appendEscaped: function() {\n    this.pushSource(\n      this.appendToBuffer([\n        this.aliasable('container.escapeExpression'),\n        '(',\n        this.popStack(),\n        ')'\n      ])\n    );\n  },\n\n  // [getContext]\n  //\n  // On stack, before: ...\n  // On stack, after: ...\n  // Compiler value, after: lastContext=depth\n  //\n  // Set the value of the `lastContext` compiler value to the depth\n  getContext: function(depth) {\n    this.lastContext = depth;\n  },\n\n  // [pushContext]\n  //\n  // On stack, before: ...\n  // On stack, after: currentContext, ...\n  //\n  // Pushes the value of the current context onto the stack.\n  pushContext: function() {\n    this.pushStackLiteral(this.contextName(this.lastContext));\n  },\n\n  // [lookupOnContext]\n  //\n  // On stack, before: ...\n  // On stack, after: currentContext[name], ...\n  //\n  // Looks up the value of `name` on the current context and pushes\n  // it onto the stack.\n  lookupOnContext: function(parts, falsy, strict, scoped) {\n    let i = 0;\n\n    if (!scoped && this.options.compat && !this.lastContext) {\n      // The depthed query is expected to handle the undefined logic for the root level that\n      // is implemented below, so we evaluate that directly in compat mode\n      this.push(this.depthedLookup(parts[i++]));\n    } else {\n      this.pushContext();\n    }\n\n    this.resolvePath('context', parts, i, falsy, strict);\n  },\n\n  // [lookupBlockParam]\n  //\n  // On stack, before: ...\n  // On stack, after: blockParam[name], ...\n  //\n  // Looks up the value of `parts` on the given block param and pushes\n  // it onto the stack.\n  lookupBlockParam: function(blockParamId, parts) {\n    this.useBlockParams = true;\n\n    this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);\n    this.resolvePath('context', parts, 1);\n  },\n\n  // [lookupData]\n  //\n  // On stack, before: ...\n  // On stack, after: data, ...\n  //\n  // Push the data lookup operator\n  lookupData: function(depth, parts, strict) {\n    if (!depth) {\n      this.pushStackLiteral('data');\n    } else {\n      this.pushStackLiteral('container.data(data, ' + depth + ')');\n    }\n\n    this.resolvePath('data', parts, 0, true, strict);\n  },\n\n  resolvePath: function(type, parts, i, falsy, strict) {\n    if (this.options.strict || this.options.assumeObjects) {\n      this.push(strictLookup(this.options.strict && strict, this, parts, type));\n      return;\n    }\n\n    let len = parts.length;\n    for (; i < len; i++) {\n      /* eslint-disable no-loop-func */\n      this.replaceStack(current => {\n        let lookup = this.nameLookup(current, parts[i], type);\n        // We want to ensure that zero and false are handled properly if the context (falsy flag)\n        // needs to have the special handling for these values.\n        if (!falsy) {\n          return [' != null ? ', lookup, ' : ', current];\n        } else {\n          // Otherwise we can use generic falsy handling\n          return [' && ', lookup];\n        }\n      });\n      /* eslint-enable no-loop-func */\n    }\n  },\n\n  // [resolvePossibleLambda]\n  //\n  // On stack, before: value, ...\n  // On stack, after: resolved value, ...\n  //\n  // If the `value` is a lambda, replace it on the stack by\n  // the return value of the lambda\n  resolvePossibleLambda: function() {\n    this.push([\n      this.aliasable('container.lambda'),\n      '(',\n      this.popStack(),\n      ', ',\n      this.contextName(0),\n      ')'\n    ]);\n  },\n\n  // [pushStringParam]\n  //\n  // On stack, before: ...\n  // On stack, after: string, currentContext, ...\n  //\n  // This opcode is designed for use in string mode, which\n  // provides the string value of a parameter along with its\n  // depth rather than resolving it immediately.\n  pushStringParam: function(string, type) {\n    this.pushContext();\n    this.pushString(type);\n\n    // If it's a subexpression, the string result\n    // will be pushed after this opcode.\n    if (type !== 'SubExpression') {\n      if (typeof string === 'string') {\n        this.pushString(string);\n      } else {\n        this.pushStackLiteral(string);\n      }\n    }\n  },\n\n  emptyHash: function(omitEmpty) {\n    if (this.trackIds) {\n      this.push('{}'); // hashIds\n    }\n    if (this.stringParams) {\n      this.push('{}'); // hashContexts\n      this.push('{}'); // hashTypes\n    }\n    this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');\n  },\n  pushHash: function() {\n    if (this.hash) {\n      this.hashes.push(this.hash);\n    }\n    this.hash = { values: {}, types: [], contexts: [], ids: [] };\n  },\n  popHash: function() {\n    let hash = this.hash;\n    this.hash = this.hashes.pop();\n\n    if (this.trackIds) {\n      this.push(this.objectLiteral(hash.ids));\n    }\n    if (this.stringParams) {\n      this.push(this.objectLiteral(hash.contexts));\n      this.push(this.objectLiteral(hash.types));\n    }\n\n    this.push(this.objectLiteral(hash.values));\n  },\n\n  // [pushString]\n  //\n  // On stack, before: ...\n  // On stack, after: quotedString(string), ...\n  //\n  // Push a quoted version of `string` onto the stack\n  pushString: function(string) {\n    this.pushStackLiteral(this.quotedString(string));\n  },\n\n  // [pushLiteral]\n  //\n  // On stack, before: ...\n  // On stack, after: value, ...\n  //\n  // Pushes a value onto the stack. This operation prevents\n  // the compiler from creating a temporary variable to hold\n  // it.\n  pushLiteral: function(value) {\n    this.pushStackLiteral(value);\n  },\n\n  // [pushProgram]\n  //\n  // On stack, before: ...\n  // On stack, after: program(guid), ...\n  //\n  // Push a program expression onto the stack. This takes\n  // a compile-time guid and converts it into a runtime-accessible\n  // expression.\n  pushProgram: function(guid) {\n    if (guid != null) {\n      this.pushStackLiteral(this.programExpression(guid));\n    } else {\n      this.pushStackLiteral(null);\n    }\n  },\n\n  // [registerDecorator]\n  //\n  // On stack, before: hash, program, params..., ...\n  // On stack, after: ...\n  //\n  // Pops off the decorator's parameters, invokes the decorator,\n  // and inserts the decorator into the decorators list.\n  registerDecorator(paramSize, name) {\n    let foundDecorator = this.nameLookup('decorators', name, 'decorator'),\n      options = this.setupHelperArgs(name, paramSize);\n\n    this.decorators.push([\n      'fn = ',\n      this.decorators.functionCall(foundDecorator, '', [\n        'fn',\n        'props',\n        'container',\n        options\n      ]),\n      ' || fn;'\n    ]);\n  },\n\n  // [invokeHelper]\n  //\n  // On stack, before: hash, inverse, program, params..., ...\n  // On stack, after: result of helper invocation\n  //\n  // Pops off the helper's parameters, invokes the helper,\n  // and pushes the helper's return value onto the stack.\n  //\n  // If the helper is not found, `helperMissing` is called.\n  invokeHelper: function(paramSize, name, isSimple) {\n    let nonHelper = this.popStack(),\n      helper = this.setupHelper(paramSize, name);\n\n    let possibleFunctionCalls = [];\n\n    if (isSimple) {\n      // direct call to helper\n      possibleFunctionCalls.push(helper.name);\n    }\n    // call a function from the input object\n    possibleFunctionCalls.push(nonHelper);\n    if (!this.options.strict) {\n      possibleFunctionCalls.push(\n        this.aliasable('container.hooks.helperMissing')\n      );\n    }\n\n    let functionLookupCode = [\n      '(',\n      this.itemsSeparatedBy(possibleFunctionCalls, '||'),\n      ')'\n    ];\n    let functionCall = this.source.functionCall(\n      functionLookupCode,\n      'call',\n      helper.callParams\n    );\n    this.push(functionCall);\n  },\n\n  itemsSeparatedBy: function(items, separator) {\n    let result = [];\n    result.push(items[0]);\n    for (let i = 1; i < items.length; i++) {\n      result.push(separator, items[i]);\n    }\n    return result;\n  },\n  // [invokeKnownHelper]\n  //\n  // On stack, before: hash, inverse, program, params..., ...\n  // On stack, after: result of helper invocation\n  //\n  // This operation is used when the helper is known to exist,\n  // so a `helperMissing` fallback is not required.\n  invokeKnownHelper: function(paramSize, name) {\n    let helper = this.setupHelper(paramSize, name);\n    this.push(this.source.functionCall(helper.name, 'call', helper.callParams));\n  },\n\n  // [invokeAmbiguous]\n  //\n  // On stack, before: hash, inverse, program, params..., ...\n  // On stack, after: result of disambiguation\n  //\n  // This operation is used when an expression like `{{foo}}`\n  // is provided, but we don't know at compile-time whether it\n  // is a helper or a path.\n  //\n  // This operation emits more code than the other options,\n  // and can be avoided by passing the `knownHelpers` and\n  // `knownHelpersOnly` flags at compile-time.\n  invokeAmbiguous: function(name, helperCall) {\n    this.useRegister('helper');\n\n    let nonHelper = this.popStack();\n\n    this.emptyHash();\n    let helper = this.setupHelper(0, name, helperCall);\n\n    let helperName = (this.lastHelper = this.nameLookup(\n      'helpers',\n      name,\n      'helper'\n    ));\n\n    let lookup = ['(', '(helper = ', helperName, ' || ', nonHelper, ')'];\n    if (!this.options.strict) {\n      lookup[0] = '(helper = ';\n      lookup.push(\n        ' != null ? helper : ',\n        this.aliasable('container.hooks.helperMissing')\n      );\n    }\n\n    this.push([\n      '(',\n      lookup,\n      helper.paramsInit ? ['),(', helper.paramsInit] : [],\n      '),',\n      '(typeof helper === ',\n      this.aliasable('\"function\"'),\n      ' ? ',\n      this.source.functionCall('helper', 'call', helper.callParams),\n      ' : helper))'\n    ]);\n  },\n\n  // [invokePartial]\n  //\n  // On stack, before: context, ...\n  // On stack after: result of partial invocation\n  //\n  // This operation pops off a context, invokes a partial with that context,\n  // and pushes the result of the invocation back.\n  invokePartial: function(isDynamic, name, indent) {\n    let params = [],\n      options = this.setupParams(name, 1, params);\n\n    if (isDynamic) {\n      name = this.popStack();\n      delete options.name;\n    }\n\n    if (indent) {\n      options.indent = JSON.stringify(indent);\n    }\n    options.helpers = 'helpers';\n    options.partials = 'partials';\n    options.decorators = 'container.decorators';\n\n    if (!isDynamic) {\n      params.unshift(this.nameLookup('partials', name, 'partial'));\n    } else {\n      params.unshift(name);\n    }\n\n    if (this.options.compat) {\n      options.depths = 'depths';\n    }\n    options = this.objectLiteral(options);\n    params.push(options);\n\n    this.push(this.source.functionCall('container.invokePartial', '', params));\n  },\n\n  // [assignToHash]\n  //\n  // On stack, before: value, ..., hash, ...\n  // On stack, after: ..., hash, ...\n  //\n  // Pops a value off the stack and assigns it to the current hash\n  assignToHash: function(key) {\n    let value = this.popStack(),\n      context,\n      type,\n      id;\n\n    if (this.trackIds) {\n      id = this.popStack();\n    }\n    if (this.stringParams) {\n      type = this.popStack();\n      context = this.popStack();\n    }\n\n    let hash = this.hash;\n    if (context) {\n      hash.contexts[key] = context;\n    }\n    if (type) {\n      hash.types[key] = type;\n    }\n    if (id) {\n      hash.ids[key] = id;\n    }\n    hash.values[key] = value;\n  },\n\n  pushId: function(type, name, child) {\n    if (type === 'BlockParam') {\n      this.pushStackLiteral(\n        'blockParams[' +\n          name[0] +\n          '].path[' +\n          name[1] +\n          ']' +\n          (child ? ' + ' + JSON.stringify('.' + child) : '')\n      );\n    } else if (type === 'PathExpression') {\n      this.pushString(name);\n    } else if (type === 'SubExpression') {\n      this.pushStackLiteral('true');\n    } else {\n      this.pushStackLiteral('null');\n    }\n  },\n\n  // HELPERS\n\n  compiler: JavaScriptCompiler,\n\n  compileChildren: function(environment, options) {\n    let children = environment.children,\n      child,\n      compiler;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      child = children[i];\n      compiler = new this.compiler(); // eslint-disable-line new-cap\n\n      let existing = this.matchExistingProgram(child);\n\n      if (existing == null) {\n        this.context.programs.push(''); // Placeholder to prevent name conflicts for nested children\n        let index = this.context.programs.length;\n        child.index = index;\n        child.name = 'program' + index;\n        this.context.programs[index] = compiler.compile(\n          child,\n          options,\n          this.context,\n          !this.precompile\n        );\n        this.context.decorators[index] = compiler.decorators;\n        this.context.environments[index] = child;\n\n        this.useDepths = this.useDepths || compiler.useDepths;\n        this.useBlockParams = this.useBlockParams || compiler.useBlockParams;\n        child.useDepths = this.useDepths;\n        child.useBlockParams = this.useBlockParams;\n      } else {\n        child.index = existing.index;\n        child.name = 'program' + existing.index;\n\n        this.useDepths = this.useDepths || existing.useDepths;\n        this.useBlockParams = this.useBlockParams || existing.useBlockParams;\n      }\n    }\n  },\n  matchExistingProgram: function(child) {\n    for (let i = 0, len = this.context.environments.length; i < len; i++) {\n      let environment = this.context.environments[i];\n      if (environment && environment.equals(child)) {\n        return environment;\n      }\n    }\n  },\n\n  programExpression: function(guid) {\n    let child = this.environment.children[guid],\n      programParams = [child.index, 'data', child.blockParams];\n\n    if (this.useBlockParams || this.useDepths) {\n      programParams.push('blockParams');\n    }\n    if (this.useDepths) {\n      programParams.push('depths');\n    }\n\n    return 'container.program(' + programParams.join(', ') + ')';\n  },\n\n  useRegister: function(name) {\n    if (!this.registers[name]) {\n      this.registers[name] = true;\n      this.registers.list.push(name);\n    }\n  },\n\n  push: function(expr) {\n    if (!(expr instanceof Literal)) {\n      expr = this.source.wrap(expr);\n    }\n\n    this.inlineStack.push(expr);\n    return expr;\n  },\n\n  pushStackLiteral: function(item) {\n    this.push(new Literal(item));\n  },\n\n  pushSource: function(source) {\n    if (this.pendingContent) {\n      this.source.push(\n        this.appendToBuffer(\n          this.source.quotedString(this.pendingContent),\n          this.pendingLocation\n        )\n      );\n      this.pendingContent = undefined;\n    }\n\n    if (source) {\n      this.source.push(source);\n    }\n  },\n\n  replaceStack: function(callback) {\n    let prefix = ['('],\n      stack,\n      createdStack,\n      usedLiteral;\n\n    /* istanbul ignore next */\n    if (!this.isInline()) {\n      throw new Exception('replaceStack on non-inline');\n    }\n\n    // We want to merge the inline statement into the replacement statement via ','\n    let top = this.popStack(true);\n\n    if (top instanceof Literal) {\n      // Literals do not need to be inlined\n      stack = [top.value];\n      prefix = ['(', stack];\n      usedLiteral = true;\n    } else {\n      // Get or create the current stack name for use by the inline\n      createdStack = true;\n      let name = this.incrStack();\n\n      prefix = ['((', this.push(name), ' = ', top, ')'];\n      stack = this.topStack();\n    }\n\n    let item = callback.call(this, stack);\n\n    if (!usedLiteral) {\n      this.popStack();\n    }\n    if (createdStack) {\n      this.stackSlot--;\n    }\n    this.push(prefix.concat(item, ')'));\n  },\n\n  incrStack: function() {\n    this.stackSlot++;\n    if (this.stackSlot > this.stackVars.length) {\n      this.stackVars.push('stack' + this.stackSlot);\n    }\n    return this.topStackName();\n  },\n  topStackName: function() {\n    return 'stack' + this.stackSlot;\n  },\n  flushInline: function() {\n    let inlineStack = this.inlineStack;\n    this.inlineStack = [];\n    for (let i = 0, len = inlineStack.length; i < len; i++) {\n      let entry = inlineStack[i];\n      /* istanbul ignore if */\n      if (entry instanceof Literal) {\n        this.compileStack.push(entry);\n      } else {\n        let stack = this.incrStack();\n        this.pushSource([stack, ' = ', entry, ';']);\n        this.compileStack.push(stack);\n      }\n    }\n  },\n  isInline: function() {\n    return this.inlineStack.length;\n  },\n\n  popStack: function(wrapped) {\n    let inline = this.isInline(),\n      item = (inline ? this.inlineStack : this.compileStack).pop();\n\n    if (!wrapped && item instanceof Literal) {\n      return item.value;\n    } else {\n      if (!inline) {\n        /* istanbul ignore next */\n        if (!this.stackSlot) {\n          throw new Exception('Invalid stack pop');\n        }\n        this.stackSlot--;\n      }\n      return item;\n    }\n  },\n\n  topStack: function() {\n    let stack = this.isInline() ? this.inlineStack : this.compileStack,\n      item = stack[stack.length - 1];\n\n    /* istanbul ignore if */\n    if (item instanceof Literal) {\n      return item.value;\n    } else {\n      return item;\n    }\n  },\n\n  contextName: function(context) {\n    if (this.useDepths && context) {\n      return 'depths[' + context + ']';\n    } else {\n      return 'depth' + context;\n    }\n  },\n\n  quotedString: function(str) {\n    return this.source.quotedString(str);\n  },\n\n  objectLiteral: function(obj) {\n    return this.source.objectLiteral(obj);\n  },\n\n  aliasable: function(name) {\n    let ret = this.aliases[name];\n    if (ret) {\n      ret.referenceCount++;\n      return ret;\n    }\n\n    ret = this.aliases[name] = this.source.wrap(name);\n    ret.aliasable = true;\n    ret.referenceCount = 1;\n\n    return ret;\n  },\n\n  setupHelper: function(paramSize, name, blockHelper) {\n    let params = [],\n      paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);\n    let foundHelper = this.nameLookup('helpers', name, 'helper'),\n      callContext = this.aliasable(\n        `${this.contextName(0)} != null ? ${this.contextName(\n          0\n        )} : (container.nullContext || {})`\n      );\n\n    return {\n      params: params,\n      paramsInit: paramsInit,\n      name: foundHelper,\n      callParams: [callContext].concat(params)\n    };\n  },\n\n  setupParams: function(helper, paramSize, params) {\n    let options = {},\n      contexts = [],\n      types = [],\n      ids = [],\n      objectArgs = !params,\n      param;\n\n    if (objectArgs) {\n      params = [];\n    }\n\n    options.name = this.quotedString(helper);\n    options.hash = this.popStack();\n\n    if (this.trackIds) {\n      options.hashIds = this.popStack();\n    }\n    if (this.stringParams) {\n      options.hashTypes = this.popStack();\n      options.hashContexts = this.popStack();\n    }\n\n    let inverse = this.popStack(),\n      program = this.popStack();\n\n    // Avoid setting fn and inverse if neither are set. This allows\n    // helpers to do a check for `if (options.fn)`\n    if (program || inverse) {\n      options.fn = program || 'container.noop';\n      options.inverse = inverse || 'container.noop';\n    }\n\n    // The parameters go on to the stack in order (making sure that they are evaluated in order)\n    // so we need to pop them off the stack in reverse order\n    let i = paramSize;\n    while (i--) {\n      param = this.popStack();\n      params[i] = param;\n\n      if (this.trackIds) {\n        ids[i] = this.popStack();\n      }\n      if (this.stringParams) {\n        types[i] = this.popStack();\n        contexts[i] = this.popStack();\n      }\n    }\n\n    if (objectArgs) {\n      options.args = this.source.generateArray(params);\n    }\n\n    if (this.trackIds) {\n      options.ids = this.source.generateArray(ids);\n    }\n    if (this.stringParams) {\n      options.types = this.source.generateArray(types);\n      options.contexts = this.source.generateArray(contexts);\n    }\n\n    if (this.options.data) {\n      options.data = 'data';\n    }\n    if (this.useBlockParams) {\n      options.blockParams = 'blockParams';\n    }\n    return options;\n  },\n\n  setupHelperArgs: function(helper, paramSize, params, useRegister) {\n    let options = this.setupParams(helper, paramSize, params);\n    options.loc = JSON.stringify(this.source.currentLocation);\n    options = this.objectLiteral(options);\n    if (useRegister) {\n      this.useRegister('options');\n      params.push('options');\n      return ['options=', options];\n    } else if (params) {\n      params.push(options);\n      return '';\n    } else {\n      return options;\n    }\n  }\n};\n\n(function() {\n  const reservedWords = (\n    'break else new var' +\n    ' case finally return void' +\n    ' catch for switch while' +\n    ' continue function this with' +\n    ' default if throw' +\n    ' delete in try' +\n    ' do instanceof typeof' +\n    ' abstract enum int short' +\n    ' boolean export interface static' +\n    ' byte extends long super' +\n    ' char final native synchronized' +\n    ' class float package throws' +\n    ' const goto private transient' +\n    ' debugger implements protected volatile' +\n    ' double import public let yield await' +\n    ' null true false'\n  ).split(' ');\n\n  const compilerWords = (JavaScriptCompiler.RESERVED_WORDS = {});\n\n  for (let i = 0, l = reservedWords.length; i < l; i++) {\n    compilerWords[reservedWords[i]] = true;\n  }\n})();\n\n/**\n * @deprecated May be removed in the next major version\n */\nJavaScriptCompiler.isValidJavaScriptVariableName = function(name) {\n  return (\n    !JavaScriptCompiler.RESERVED_WORDS[name] &&\n    /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name)\n  );\n};\n\nfunction strictLookup(requireTerminal, compiler, parts, type) {\n  let stack = compiler.popStack(),\n    i = 0,\n    len = parts.length;\n  if (requireTerminal) {\n    len--;\n  }\n\n  for (; i < len; i++) {\n    stack = compiler.nameLookup(stack, parts[i], type);\n  }\n\n  if (requireTerminal) {\n    return [\n      compiler.aliasable('container.strict'),\n      '(',\n      stack,\n      ', ',\n      compiler.quotedString(parts[i]),\n      ', ',\n      JSON.stringify(compiler.source.currentLocation),\n      ' )'\n    ];\n  } else {\n    return stack;\n  }\n}\n\nexport default JavaScriptCompiler;\n"]},"metadata":{},"sourceType":"script"}