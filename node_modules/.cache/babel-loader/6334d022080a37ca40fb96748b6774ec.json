{"ast":null,"code":"import { BigNumber } from '@uniswap/sdk'; // returns a deep copied + sorted list of values, as well as a sortmap\n\nexport function sortBigNumbers(values) {\n  const valueMap = values.map((value, i) => ({\n    value,\n    i\n  }));\n  valueMap.sort((a, b) => {\n    if (a.value.isGreaterThan(b.value)) {\n      return 1;\n    } else if (a.value.isLessThan(b.value)) {\n      return -1;\n    } else {\n      return 0;\n    }\n  });\n  return [valueMap.map(element => values[element.i]), values.map((_, i) => valueMap.findIndex(element => element.i === i))];\n}\nexport function getMedian(values) {\n  const [sortedValues, sortMap] = sortBigNumbers(values);\n\n  if (values.length % 2 === 0) {\n    const middle = values.length / 2;\n    const indices = [middle - 1, middle];\n    return [sortedValues[middle - 1].plus(sortedValues[middle]).dividedBy(2), sortMap.map(element => indices.includes(element) ? new BigNumber(0.5) : new BigNumber(0))];\n  } else {\n    const middle = Math.floor(values.length / 2);\n    return [sortedValues[middle], sortMap.map(element => element === middle ? new BigNumber(1) : new BigNumber(0))];\n  }\n}\nexport function getMean(values, _weights) {\n  const weights = _weights ? _weights : values.map(() => new BigNumber(1));\n  const weightedValues = values.map((value, i) => value.multipliedBy(weights[i]));\n  const numerator = weightedValues.reduce((accumulator, currentValue) => accumulator.plus(currentValue), new BigNumber(0));\n  const denominator = weights.reduce((accumulator, currentValue) => accumulator.plus(currentValue), new BigNumber(0));\n  return [numerator.dividedBy(denominator), weights.map(weight => weight.dividedBy(denominator))];\n}","map":{"version":3,"sources":["/Users/kerp/Documents/GitHub/landing-page/src/utils/math.js"],"names":["BigNumber","sortBigNumbers","values","valueMap","map","value","i","sort","a","b","isGreaterThan","isLessThan","element","_","findIndex","getMedian","sortedValues","sortMap","length","middle","indices","plus","dividedBy","includes","Math","floor","getMean","_weights","weights","weightedValues","multipliedBy","numerator","reduce","accumulator","currentValue","denominator","weight"],"mappings":"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","sourcesContent":["import { BigNumber } from '@uniswap/sdk'\n\n// returns a deep copied + sorted list of values, as well as a sortmap\nexport function sortBigNumbers(values) {\n  const valueMap = values.map((value, i) => ({ value, i }))\n\n  valueMap.sort((a, b) => {\n    if (a.value.isGreaterThan(b.value)) {\n      return 1\n    } else if (a.value.isLessThan(b.value)) {\n      return -1\n    } else {\n      return 0\n    }\n  })\n\n  return [\n    valueMap.map(element => values[element.i]),\n    values.map((_, i) => valueMap.findIndex(element => element.i === i))\n  ]\n}\n\nexport function getMedian(values) {\n  const [sortedValues, sortMap] = sortBigNumbers(values)\n  if (values.length % 2 === 0) {\n    const middle = values.length / 2\n    const indices = [middle - 1, middle]\n    return [\n      sortedValues[middle - 1].plus(sortedValues[middle]).dividedBy(2),\n      sortMap.map(element => (indices.includes(element) ? new BigNumber(0.5) : new BigNumber(0)))\n    ]\n  } else {\n    const middle = Math.floor(values.length / 2)\n    return [sortedValues[middle], sortMap.map(element => (element === middle ? new BigNumber(1) : new BigNumber(0)))]\n  }\n}\n\nexport function getMean(values, _weights) {\n  const weights = _weights ? _weights : values.map(() => new BigNumber(1))\n\n  const weightedValues = values.map((value, i) => value.multipliedBy(weights[i]))\n  const numerator = weightedValues.reduce(\n    (accumulator, currentValue) => accumulator.plus(currentValue),\n    new BigNumber(0)\n  )\n  const denominator = weights.reduce((accumulator, currentValue) => accumulator.plus(currentValue), new BigNumber(0))\n\n  return [numerator.dividedBy(denominator), weights.map(weight => weight.dividedBy(denominator))]\n}\n"]},"metadata":{},"sourceType":"module"}