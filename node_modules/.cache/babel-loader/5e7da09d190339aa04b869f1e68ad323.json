{"ast":null,"code":"const inherits = require('util').inherits;\n\nconst ethUtil = require('ethereumjs-util');\n\nconst BN = ethUtil.BN;\n\nconst clone = require('clone');\n\nconst cacheUtils = require('../util/rpc-cache-utils.js');\n\nconst Stoplight = require('../util/stoplight.js');\n\nconst Subprovider = require('./subprovider.js');\n\nmodule.exports = BlockCacheProvider;\ninherits(BlockCacheProvider, Subprovider);\n\nfunction BlockCacheProvider(opts) {\n  const self = this;\n  opts = opts || {}; // set initialization blocker\n\n  self._ready = new Stoplight();\n  self.strategies = {\n    perma: new ConditionalPermaCacheStrategy({\n      eth_getTransactionByHash: containsBlockhash,\n      eth_getTransactionReceipt: containsBlockhash\n    }),\n    block: new BlockCacheStrategy(self),\n    fork: new BlockCacheStrategy(self)\n  };\n} // setup a block listener on 'setEngine'\n\n\nBlockCacheProvider.prototype.setEngine = function (engine) {\n  const self = this;\n  self.engine = engine; // unblock initialization after first block\n\n  engine.once('block', function (block) {\n    self.currentBlock = block;\n\n    self._ready.go(); // from now on, empty old cache every block\n\n\n    engine.on('block', clearOldCache);\n  });\n\n  function clearOldCache(newBlock) {\n    var previousBlock = self.currentBlock;\n    self.currentBlock = newBlock;\n    if (!previousBlock) return;\n    self.strategies.block.cacheRollOff(previousBlock);\n    self.strategies.fork.cacheRollOff(previousBlock);\n  }\n};\n\nBlockCacheProvider.prototype.handleRequest = function (payload, next, end) {\n  const self = this; // skip cache if told to do so\n\n  if (payload.skipCache) {\n    // console.log('CACHE SKIP - skip cache if told to do so')\n    return next();\n  } // Ignore block polling requests.\n\n\n  if (payload.method === 'eth_getBlockByNumber' && payload.params[0] === 'latest') {\n    // console.log('CACHE SKIP - Ignore block polling requests.')\n    return next();\n  } // wait for first block\n\n\n  self._ready.await(function () {\n    // actually handle the request\n    self._handleRequest(payload, next, end);\n  });\n};\n\nBlockCacheProvider.prototype._handleRequest = function (payload, next, end) {\n  const self = this;\n  var type = cacheUtils.cacheTypeForPayload(payload);\n  var strategy = this.strategies[type]; // If there's no strategy in place, pass it down the chain.\n\n  if (!strategy) {\n    return next();\n  } // If the strategy can't cache this request, ignore it.\n\n\n  if (!strategy.canCache(payload)) {\n    return next();\n  }\n\n  var blockTag = cacheUtils.blockTagForPayload(payload);\n  if (!blockTag) blockTag = 'latest';\n  var requestedBlockNumber;\n\n  if (blockTag === 'earliest') {\n    requestedBlockNumber = '0x00';\n  } else if (blockTag === 'latest') {\n    requestedBlockNumber = ethUtil.bufferToHex(self.currentBlock.number);\n  } else {\n    // We have a hex number\n    requestedBlockNumber = blockTag;\n  } //console.log('REQUEST at block 0x' + requestedBlockNumber.toString('hex'))\n  // end on a hit, continue on a miss\n\n\n  strategy.hitCheck(payload, requestedBlockNumber, end, function () {\n    // miss fallthrough to provider chain, caching the result on the way back up.\n    next(function (err, result, cb) {\n      // err is already handled by engine\n      if (err) return cb();\n      strategy.cacheResult(payload, result, requestedBlockNumber, cb);\n    });\n  });\n}; //\n// Cache Strategies\n//\n\n\nfunction PermaCacheStrategy() {\n  var self = this;\n  self.cache = {}; // clear cache every ten minutes\n\n  var timeout = setInterval(function () {\n    self.cache = {};\n  }, 10 * 60 * 1e3); // do not require the Node.js event loop to remain active\n\n  if (timeout.unref) timeout.unref();\n}\n\nPermaCacheStrategy.prototype.hitCheck = function (payload, requestedBlockNumber, hit, miss) {\n  var identifier = cacheUtils.cacheIdentifierForPayload(payload);\n  var cached = this.cache[identifier];\n  if (!cached) return miss(); // If the block number we're requesting at is greater than or\n  // equal to the block where we cached a previous response,\n  // the cache is valid. If it's from earlier than the cache,\n  // send it back down to the client (where it will be recached.)\n\n  var cacheIsEarlyEnough = compareHex(requestedBlockNumber, cached.blockNumber) >= 0;\n\n  if (cacheIsEarlyEnough) {\n    var clonedValue = clone(cached.result);\n    return hit(null, clonedValue);\n  } else {\n    return miss();\n  }\n};\n\nPermaCacheStrategy.prototype.cacheResult = function (payload, result, requestedBlockNumber, callback) {\n  var identifier = cacheUtils.cacheIdentifierForPayload(payload);\n\n  if (result) {\n    var clonedValue = clone(result);\n    this.cache[identifier] = {\n      blockNumber: requestedBlockNumber,\n      result: clonedValue\n    };\n  }\n\n  callback();\n};\n\nPermaCacheStrategy.prototype.canCache = function (payload) {\n  return cacheUtils.canCache(payload);\n}; //\n// ConditionalPermaCacheStrategy\n//\n\n\nfunction ConditionalPermaCacheStrategy(conditionals) {\n  this.strategy = new PermaCacheStrategy();\n  this.conditionals = conditionals;\n}\n\nConditionalPermaCacheStrategy.prototype.hitCheck = function (payload, requestedBlockNumber, hit, miss) {\n  return this.strategy.hitCheck(payload, requestedBlockNumber, hit, miss);\n};\n\nConditionalPermaCacheStrategy.prototype.cacheResult = function (payload, result, requestedBlockNumber, callback) {\n  var conditional = this.conditionals[payload.method];\n\n  if (conditional) {\n    if (conditional(result)) {\n      this.strategy.cacheResult(payload, result, requestedBlockNumber, callback);\n    } else {\n      callback();\n    }\n  } else {\n    // Cache all requests that don't have a conditional\n    this.strategy.cacheResult(payload, result, requestedBlockNumber, callback);\n  }\n};\n\nConditionalPermaCacheStrategy.prototype.canCache = function (payload) {\n  return this.strategy.canCache(payload);\n}; //\n// BlockCacheStrategy\n//\n\n\nfunction BlockCacheStrategy() {\n  this.cache = {};\n}\n\nBlockCacheStrategy.prototype.getBlockCacheForPayload = function (payload, blockNumberHex) {\n  const blockNumber = Number.parseInt(blockNumberHex, 16);\n  let blockCache = this.cache[blockNumber]; // create new cache if necesary\n\n  if (!blockCache) {\n    const newCache = {};\n    this.cache[blockNumber] = newCache;\n    blockCache = newCache;\n  }\n\n  return blockCache;\n};\n\nBlockCacheStrategy.prototype.hitCheck = function (payload, requestedBlockNumber, hit, miss) {\n  var blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);\n\n  if (!blockCache) {\n    return miss();\n  }\n\n  var identifier = cacheUtils.cacheIdentifierForPayload(payload);\n  var cached = blockCache[identifier];\n\n  if (cached) {\n    return hit(null, cached);\n  } else {\n    return miss();\n  }\n};\n\nBlockCacheStrategy.prototype.cacheResult = function (payload, result, requestedBlockNumber, callback) {\n  if (result) {\n    var blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);\n    var identifier = cacheUtils.cacheIdentifierForPayload(payload);\n    blockCache[identifier] = result;\n  }\n\n  callback();\n};\n\nBlockCacheStrategy.prototype.canCache = function (payload) {\n  if (!cacheUtils.canCache(payload)) {\n    return false;\n  }\n\n  var blockTag = cacheUtils.blockTagForPayload(payload);\n  return blockTag !== 'pending';\n}; // naively removes older block caches\n\n\nBlockCacheStrategy.prototype.cacheRollOff = function (previousBlock) {\n  const self = this;\n  const previousHex = ethUtil.bufferToHex(previousBlock.number);\n  const oldBlockNumber = Number.parseInt(previousHex, 16); // clear old caches\n\n  Object.keys(self.cache).map(Number).filter(num => num <= oldBlockNumber).forEach(num => delete self.cache[num]);\n}; // util\n\n\nfunction compareHex(hexA, hexB) {\n  var numA = parseInt(hexA, 16);\n  var numB = parseInt(hexB, 16);\n  return numA === numB ? 0 : numA > numB ? 1 : -1;\n}\n\nfunction hexToBN(hex) {\n  return new BN(ethUtil.toBuffer(hex));\n}\n\nfunction containsBlockhash(result) {\n  if (!result) return false;\n  if (!result.blockHash) return false;\n  const hasNonZeroHash = hexToBN(result.blockHash).gt(new BN(0));\n  return hasNonZeroHash;\n}","map":{"version":3,"sources":["/Users/kerp/Documents/GitHub/landing-page/node_modules/web3-provider-engine/subproviders/cache.js"],"names":["inherits","require","ethUtil","BN","clone","cacheUtils","Stoplight","Subprovider","module","exports","BlockCacheProvider","opts","self","_ready","strategies","perma","ConditionalPermaCacheStrategy","eth_getTransactionByHash","containsBlockhash","eth_getTransactionReceipt","block","BlockCacheStrategy","fork","prototype","setEngine","engine","once","currentBlock","go","on","clearOldCache","newBlock","previousBlock","cacheRollOff","handleRequest","payload","next","end","skipCache","method","params","await","_handleRequest","type","cacheTypeForPayload","strategy","canCache","blockTag","blockTagForPayload","requestedBlockNumber","bufferToHex","number","hitCheck","err","result","cb","cacheResult","PermaCacheStrategy","cache","timeout","setInterval","unref","hit","miss","identifier","cacheIdentifierForPayload","cached","cacheIsEarlyEnough","compareHex","blockNumber","clonedValue","callback","conditionals","conditional","getBlockCacheForPayload","blockNumberHex","Number","parseInt","blockCache","newCache","previousHex","oldBlockNumber","Object","keys","map","filter","num","forEach","hexA","hexB","numA","numB","hexToBN","hex","toBuffer","blockHash","hasNonZeroHash","gt"],"mappings":"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","sourcesContent":["const inherits = require('util').inherits\nconst ethUtil = require('ethereumjs-util')\nconst BN = ethUtil.BN\nconst clone = require('clone')\nconst cacheUtils = require('../util/rpc-cache-utils.js')\nconst Stoplight = require('../util/stoplight.js')\nconst Subprovider = require('./subprovider.js')\n\nmodule.exports = BlockCacheProvider\n\ninherits(BlockCacheProvider, Subprovider)\n\nfunction BlockCacheProvider(opts) {\n  const self = this\n  opts = opts || {}\n  // set initialization blocker\n  self._ready = new Stoplight()\n  self.strategies = {\n    perma: new ConditionalPermaCacheStrategy({\n      eth_getTransactionByHash: containsBlockhash,\n      eth_getTransactionReceipt: containsBlockhash,\n    }),\n    block: new BlockCacheStrategy(self),\n    fork: new BlockCacheStrategy(self),\n  }\n}\n\n// setup a block listener on 'setEngine'\nBlockCacheProvider.prototype.setEngine = function(engine) {\n  const self = this\n  self.engine = engine\n  // unblock initialization after first block\n  engine.once('block', function(block) {\n    self.currentBlock = block\n    self._ready.go()\n    // from now on, empty old cache every block\n    engine.on('block', clearOldCache)\n  })\n\n  function clearOldCache(newBlock) {\n    var previousBlock = self.currentBlock\n    self.currentBlock = newBlock\n    if (!previousBlock) return\n    self.strategies.block.cacheRollOff(previousBlock)\n    self.strategies.fork.cacheRollOff(previousBlock)\n  }\n}\n\nBlockCacheProvider.prototype.handleRequest = function(payload, next, end){\n  const self = this\n\n  // skip cache if told to do so\n  if (payload.skipCache) {\n    // console.log('CACHE SKIP - skip cache if told to do so')\n    return next()\n  }\n\n  // Ignore block polling requests.\n  if (payload.method === 'eth_getBlockByNumber' && payload.params[0] === 'latest') {\n    // console.log('CACHE SKIP - Ignore block polling requests.')\n    return next()\n  }\n\n  // wait for first block\n  self._ready.await(function(){\n    // actually handle the request\n    self._handleRequest(payload, next, end)\n  })\n}\n\nBlockCacheProvider.prototype._handleRequest = function(payload, next, end){\n  const self = this\n\n  var type = cacheUtils.cacheTypeForPayload(payload)\n  var strategy = this.strategies[type]\n\n  // If there's no strategy in place, pass it down the chain.\n  if (!strategy) {\n    return next()\n  }\n\n  // If the strategy can't cache this request, ignore it.\n  if (!strategy.canCache(payload)) {\n    return next()\n  }\n\n  var blockTag = cacheUtils.blockTagForPayload(payload)\n  if (!blockTag) blockTag = 'latest'\n  var requestedBlockNumber\n\n  if (blockTag === 'earliest') {\n    requestedBlockNumber = '0x00'\n  } else if (blockTag === 'latest') {\n    requestedBlockNumber = ethUtil.bufferToHex(self.currentBlock.number)\n  } else {\n    // We have a hex number\n    requestedBlockNumber = blockTag\n  }\n\n  //console.log('REQUEST at block 0x' + requestedBlockNumber.toString('hex'))\n\n  // end on a hit, continue on a miss\n  strategy.hitCheck(payload, requestedBlockNumber, end, function() {\n    // miss fallthrough to provider chain, caching the result on the way back up.\n    next(function(err, result, cb) {\n      // err is already handled by engine\n      if (err) return cb()\n      strategy.cacheResult(payload, result, requestedBlockNumber, cb)\n    })\n  })\n}\n\n//\n// Cache Strategies\n//\n\nfunction PermaCacheStrategy() {\n  var self = this\n  self.cache = {}\n  // clear cache every ten minutes\n  var timeout = setInterval(function(){\n    self.cache = {}\n  }, 10 * 60 * 1e3)\n  // do not require the Node.js event loop to remain active\n  if (timeout.unref) timeout.unref()\n}\n\nPermaCacheStrategy.prototype.hitCheck = function(payload, requestedBlockNumber, hit, miss) {\n  var identifier = cacheUtils.cacheIdentifierForPayload(payload)\n  var cached = this.cache[identifier]\n\n  if (!cached) return miss()\n\n  // If the block number we're requesting at is greater than or\n  // equal to the block where we cached a previous response,\n  // the cache is valid. If it's from earlier than the cache,\n  // send it back down to the client (where it will be recached.)\n  var cacheIsEarlyEnough = compareHex(requestedBlockNumber, cached.blockNumber) >= 0\n  if (cacheIsEarlyEnough) {\n    var clonedValue = clone(cached.result)\n    return hit(null, clonedValue)\n  } else {\n    return miss()\n  }\n}\n\nPermaCacheStrategy.prototype.cacheResult = function(payload, result, requestedBlockNumber, callback) {\n  var identifier = cacheUtils.cacheIdentifierForPayload(payload)\n\n  if (result) {\n    var clonedValue = clone(result)\n    this.cache[identifier] = {\n      blockNumber: requestedBlockNumber,\n      result: clonedValue,\n    }\n  }\n\n  callback()\n}\n\nPermaCacheStrategy.prototype.canCache = function(payload) {\n  return cacheUtils.canCache(payload)\n}\n\n//\n// ConditionalPermaCacheStrategy\n//\n\nfunction ConditionalPermaCacheStrategy(conditionals) {\n  this.strategy = new PermaCacheStrategy()\n  this.conditionals = conditionals\n}\n\nConditionalPermaCacheStrategy.prototype.hitCheck = function(payload, requestedBlockNumber, hit, miss) {\n  return this.strategy.hitCheck(payload, requestedBlockNumber, hit, miss)\n}\n\nConditionalPermaCacheStrategy.prototype.cacheResult = function(payload, result, requestedBlockNumber, callback) {\n  var conditional = this.conditionals[payload.method]\n\n  if (conditional) {\n    if (conditional(result)) {\n      this.strategy.cacheResult(payload, result, requestedBlockNumber, callback)\n    } else {\n      callback()\n    }\n  } else {\n    // Cache all requests that don't have a conditional\n    this.strategy.cacheResult(payload, result, requestedBlockNumber, callback)\n  }\n}\n\nConditionalPermaCacheStrategy.prototype.canCache = function(payload) {\n  return this.strategy.canCache(payload)\n}\n\n//\n// BlockCacheStrategy\n//\n\nfunction BlockCacheStrategy() {\n  this.cache = {}\n}\n\nBlockCacheStrategy.prototype.getBlockCacheForPayload = function(payload, blockNumberHex) {\n  const blockNumber = Number.parseInt(blockNumberHex, 16)\n  let blockCache = this.cache[blockNumber]\n  // create new cache if necesary\n  if (!blockCache) {\n    const newCache = {}\n    this.cache[blockNumber] = newCache\n    blockCache = newCache\n  }\n  return blockCache\n}\n\nBlockCacheStrategy.prototype.hitCheck = function(payload, requestedBlockNumber, hit, miss) {\n  var blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber)\n\n  if (!blockCache) {\n    return miss()\n  }\n\n  var identifier = cacheUtils.cacheIdentifierForPayload(payload)\n  var cached = blockCache[identifier]\n\n  if (cached) {\n    return hit(null, cached)\n  } else {\n    return miss()\n  }\n}\n\nBlockCacheStrategy.prototype.cacheResult = function(payload, result, requestedBlockNumber, callback) {\n  if (result) {\n    var blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber)\n    var identifier = cacheUtils.cacheIdentifierForPayload(payload)\n    blockCache[identifier] = result\n  }\n  callback()\n}\n\nBlockCacheStrategy.prototype.canCache = function(payload) {\n  if (!cacheUtils.canCache(payload)) {\n    return false\n  }\n\n  var blockTag = cacheUtils.blockTagForPayload(payload)\n\n  return (blockTag !== 'pending')\n}\n\n// naively removes older block caches\nBlockCacheStrategy.prototype.cacheRollOff = function(previousBlock){\n  const self = this\n  const previousHex = ethUtil.bufferToHex(previousBlock.number)\n  const oldBlockNumber = Number.parseInt(previousHex, 16)\n  // clear old caches\n  Object.keys(self.cache)\n    .map(Number)\n    .filter(num => num <= oldBlockNumber)\n    .forEach(num => delete self.cache[num])\n}\n\n\n// util\n\nfunction compareHex(hexA, hexB){\n  var numA = parseInt(hexA, 16)\n  var numB = parseInt(hexB, 16)\n  return numA === numB ? 0 : (numA > numB ? 1 : -1 )\n}\n\nfunction hexToBN(hex){\n  return new BN(ethUtil.toBuffer(hex))\n}\n\nfunction containsBlockhash(result) {\n  if (!result) return false\n  if (!result.blockHash) return false\n  const hasNonZeroHash = hexToBN(result.blockHash).gt(new BN(0))\n  return hasNonZeroHash\n}\n"]},"metadata":{},"sourceType":"script"}