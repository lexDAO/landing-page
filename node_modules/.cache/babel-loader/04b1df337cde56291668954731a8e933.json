{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\n\nvar constants_1 = require(\"../constants\");\n\nvar _utils_1 = require(\"../_utils\");\n\nfunction removeUndefined(methodArguments) {\n  return methodArguments.filter(function (a) {\n    return a !== undefined;\n  });\n}\n\nfunction calculateSlippage(value, maxSlippage) {\n  var offset = value.multipliedBy(maxSlippage).dividedBy(constants_1._10000);\n  var minimum = value.minus(offset).integerValue(bignumber_js_1.default.ROUND_FLOOR);\n  var maximum = value.plus(offset).integerValue(bignumber_js_1.default.ROUND_CEIL);\n  return {\n    minimum: minimum.isLessThan(constants_1._0) ? constants_1._0 : minimum,\n    maximum: maximum.isGreaterThan(constants_1._MAX_UINT256) ? constants_1._MAX_UINT256 : maximum\n  };\n}\n\nfunction getReserves(trade) {\n  switch (trade.tradeType) {\n    case constants_1.TRADE_TYPE.ETH_TO_TOKEN:\n      {\n        return trade.marketDetailsPre.outputReserves;\n      }\n\n    case constants_1.TRADE_TYPE.TOKEN_TO_ETH:\n      {\n        return trade.marketDetailsPre.inputReserves;\n      }\n\n    case constants_1.TRADE_TYPE.TOKEN_TO_TOKEN:\n      {\n        return trade.marketDetailsPre.inputReserves;\n      }\n\n    default:\n      {\n        throw Error(\"tradeType \" + trade.tradeType + \" is invalid.\");\n      }\n  }\n}\n\nfunction getMethodName(trade, transfer) {\n  if (transfer === void 0) {\n    transfer = false;\n  }\n\n  switch (trade.tradeType) {\n    case constants_1.TRADE_TYPE.ETH_TO_TOKEN:\n      {\n        if (trade.tradeExact === constants_1.TRADE_EXACT.INPUT && !transfer) {\n          return constants_1.TRADE_METHODS.ethToTokenSwapInput;\n        } else if (trade.tradeExact === constants_1.TRADE_EXACT.INPUT && transfer) {\n          return constants_1.TRADE_METHODS.ethToTokenTransferInput;\n        } else if (trade.tradeExact === constants_1.TRADE_EXACT.OUTPUT && !transfer) {\n          return constants_1.TRADE_METHODS.ethToTokenSwapOutput;\n        } else {\n          return constants_1.TRADE_METHODS.ethToTokenTransferOutput;\n        }\n      }\n\n    case constants_1.TRADE_TYPE.TOKEN_TO_ETH:\n      {\n        if (trade.tradeExact === constants_1.TRADE_EXACT.INPUT && !transfer) {\n          return constants_1.TRADE_METHODS.tokenToEthSwapInput;\n        } else if (trade.tradeExact === constants_1.TRADE_EXACT.INPUT && transfer) {\n          return constants_1.TRADE_METHODS.tokenToEthTransferInput;\n        } else if (trade.tradeExact === constants_1.TRADE_EXACT.OUTPUT && !transfer) {\n          return constants_1.TRADE_METHODS.tokenToEthSwapOutput;\n        } else {\n          return constants_1.TRADE_METHODS.tokenToEthTransferOutput;\n        }\n      }\n\n    case constants_1.TRADE_TYPE.TOKEN_TO_TOKEN:\n      {\n        if (trade.tradeExact === constants_1.TRADE_EXACT.INPUT && !transfer) {\n          return constants_1.TRADE_METHODS.tokenToTokenSwapInput;\n        } else if (trade.tradeExact === constants_1.TRADE_EXACT.INPUT && transfer) {\n          return constants_1.TRADE_METHODS.tokenToTokenTransferInput;\n        } else if (trade.tradeExact === constants_1.TRADE_EXACT.OUTPUT && !transfer) {\n          return constants_1.TRADE_METHODS.tokenToTokenSwapOutput;\n        } else {\n          return constants_1.TRADE_METHODS.tokenToTokenTransferOutput;\n        }\n      }\n\n    default:\n      {\n        throw Error(\"tradeType \" + trade.tradeType + \" is invalid.\");\n      }\n  }\n}\n\nfunction getValueAndMethodArguments(trade, methodName, maxSlippage, deadline, recipient) {\n  switch (methodName) {\n    case constants_1.TRADE_METHODS.ethToTokenSwapInput:\n    case constants_1.TRADE_METHODS.ethToTokenTransferInput:\n      {\n        return {\n          value: trade.inputAmount.amount,\n          methodArguments: removeUndefined([calculateSlippage(trade.outputAmount.amount, maxSlippage).minimum, deadline, recipient])\n        };\n      }\n\n    case constants_1.TRADE_METHODS.ethToTokenSwapOutput:\n    case constants_1.TRADE_METHODS.ethToTokenTransferOutput:\n      {\n        return {\n          value: calculateSlippage(trade.inputAmount.amount, maxSlippage).maximum,\n          methodArguments: removeUndefined([trade.outputAmount.amount, deadline, recipient])\n        };\n      }\n\n    case constants_1.TRADE_METHODS.tokenToEthSwapInput:\n    case constants_1.TRADE_METHODS.tokenToEthTransferInput:\n      {\n        return {\n          value: constants_1._0,\n          methodArguments: removeUndefined([trade.inputAmount.amount, calculateSlippage(trade.outputAmount.amount, maxSlippage).minimum, deadline, recipient])\n        };\n      }\n\n    case constants_1.TRADE_METHODS.tokenToEthSwapOutput:\n    case constants_1.TRADE_METHODS.tokenToEthTransferOutput:\n      {\n        return {\n          value: constants_1._0,\n          methodArguments: removeUndefined([trade.outputAmount.amount, calculateSlippage(trade.inputAmount.amount, maxSlippage).maximum, deadline, recipient])\n        };\n      }\n\n    case constants_1.TRADE_METHODS.tokenToTokenSwapInput:\n    case constants_1.TRADE_METHODS.tokenToTokenTransferInput:\n      {\n        if (!trade.outputAmount.token.address) {\n          throw Error('trade does not include output token address.');\n        }\n\n        return {\n          value: constants_1._0,\n          methodArguments: removeUndefined([trade.inputAmount.amount, calculateSlippage(trade.outputAmount.amount, maxSlippage).minimum, constants_1._1, deadline, recipient, trade.outputAmount.token.address])\n        };\n      }\n\n    case constants_1.TRADE_METHODS.tokenToTokenSwapOutput:\n    case constants_1.TRADE_METHODS.tokenToTokenTransferOutput:\n      {\n        if (!trade.outputAmount.token.address) {\n          throw Error('trade does not include output token address.');\n        }\n\n        return {\n          value: constants_1._0,\n          methodArguments: removeUndefined([trade.outputAmount.amount, calculateSlippage(trade.inputAmount.amount, maxSlippage).maximum, constants_1._MAX_UINT256, deadline, recipient, trade.outputAmount.token.address])\n        };\n      }\n\n    default:\n      {\n        throw Error(\"methodName \" + methodName + \" is invalid.\");\n      }\n  }\n}\n\nfunction getExecutionDetails(trade, maxSlippage, deadline, recipient) {\n  var reserves = getReserves(trade);\n\n  if (!reserves.exchange || !reserves.exchange.address) {\n    throw Error('trade does not include exchange address.');\n  }\n\n  var methodName = getMethodName(trade, !!recipient);\n  var methodId = constants_1.TRADE_METHOD_IDS[methodName];\n\n  var _a = getValueAndMethodArguments(trade, methodName, maxSlippage || 200, deadline || Math.round(Date.now() / 1000 + 60 * 10), recipient && _utils_1.normalizeAddress(recipient)),\n      value = _a.value,\n      methodArguments = _a.methodArguments;\n\n  return {\n    exchangeAddress: reserves.exchange.address,\n    methodName: methodName,\n    methodId: methodId,\n    value: value,\n    methodArguments: methodArguments\n  };\n}\n\nexports.getExecutionDetails = getExecutionDetails;","map":{"version":3,"sources":["../../src/transact/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\nvar constants_1 = require(\"../constants\");\nvar _utils_1 = require(\"../_utils\");\nfunction removeUndefined(methodArguments) {\n    return methodArguments.filter(function (a) { return a !== undefined; });\n}\nfunction calculateSlippage(value, maxSlippage) {\n    var offset = value.multipliedBy(maxSlippage).dividedBy(constants_1._10000);\n    var minimum = value.minus(offset).integerValue(bignumber_js_1.default.ROUND_FLOOR);\n    var maximum = value.plus(offset).integerValue(bignumber_js_1.default.ROUND_CEIL);\n    return {\n        minimum: minimum.isLessThan(constants_1._0) ? constants_1._0 : minimum,\n        maximum: maximum.isGreaterThan(constants_1._MAX_UINT256) ? constants_1._MAX_UINT256 : maximum\n    };\n}\nfunction getReserves(trade) {\n    switch (trade.tradeType) {\n        case constants_1.TRADE_TYPE.ETH_TO_TOKEN: {\n            return trade.marketDetailsPre.outputReserves;\n        }\n        case constants_1.TRADE_TYPE.TOKEN_TO_ETH: {\n            return trade.marketDetailsPre.inputReserves;\n        }\n        case constants_1.TRADE_TYPE.TOKEN_TO_TOKEN: {\n            return trade.marketDetailsPre.inputReserves;\n        }\n        default: {\n            throw Error(\"tradeType \" + trade.tradeType + \" is invalid.\");\n        }\n    }\n}\nfunction getMethodName(trade, transfer) {\n    if (transfer === void 0) { transfer = false; }\n    switch (trade.tradeType) {\n        case constants_1.TRADE_TYPE.ETH_TO_TOKEN: {\n            if (trade.tradeExact === constants_1.TRADE_EXACT.INPUT && !transfer) {\n                return constants_1.TRADE_METHODS.ethToTokenSwapInput;\n            }\n            else if (trade.tradeExact === constants_1.TRADE_EXACT.INPUT && transfer) {\n                return constants_1.TRADE_METHODS.ethToTokenTransferInput;\n            }\n            else if (trade.tradeExact === constants_1.TRADE_EXACT.OUTPUT && !transfer) {\n                return constants_1.TRADE_METHODS.ethToTokenSwapOutput;\n            }\n            else {\n                return constants_1.TRADE_METHODS.ethToTokenTransferOutput;\n            }\n        }\n        case constants_1.TRADE_TYPE.TOKEN_TO_ETH: {\n            if (trade.tradeExact === constants_1.TRADE_EXACT.INPUT && !transfer) {\n                return constants_1.TRADE_METHODS.tokenToEthSwapInput;\n            }\n            else if (trade.tradeExact === constants_1.TRADE_EXACT.INPUT && transfer) {\n                return constants_1.TRADE_METHODS.tokenToEthTransferInput;\n            }\n            else if (trade.tradeExact === constants_1.TRADE_EXACT.OUTPUT && !transfer) {\n                return constants_1.TRADE_METHODS.tokenToEthSwapOutput;\n            }\n            else {\n                return constants_1.TRADE_METHODS.tokenToEthTransferOutput;\n            }\n        }\n        case constants_1.TRADE_TYPE.TOKEN_TO_TOKEN: {\n            if (trade.tradeExact === constants_1.TRADE_EXACT.INPUT && !transfer) {\n                return constants_1.TRADE_METHODS.tokenToTokenSwapInput;\n            }\n            else if (trade.tradeExact === constants_1.TRADE_EXACT.INPUT && transfer) {\n                return constants_1.TRADE_METHODS.tokenToTokenTransferInput;\n            }\n            else if (trade.tradeExact === constants_1.TRADE_EXACT.OUTPUT && !transfer) {\n                return constants_1.TRADE_METHODS.tokenToTokenSwapOutput;\n            }\n            else {\n                return constants_1.TRADE_METHODS.tokenToTokenTransferOutput;\n            }\n        }\n        default: {\n            throw Error(\"tradeType \" + trade.tradeType + \" is invalid.\");\n        }\n    }\n}\nfunction getValueAndMethodArguments(trade, methodName, maxSlippage, deadline, recipient) {\n    switch (methodName) {\n        case constants_1.TRADE_METHODS.ethToTokenSwapInput:\n        case constants_1.TRADE_METHODS.ethToTokenTransferInput: {\n            return {\n                value: trade.inputAmount.amount,\n                methodArguments: removeUndefined([\n                    calculateSlippage(trade.outputAmount.amount, maxSlippage).minimum,\n                    deadline,\n                    recipient\n                ])\n            };\n        }\n        case constants_1.TRADE_METHODS.ethToTokenSwapOutput:\n        case constants_1.TRADE_METHODS.ethToTokenTransferOutput: {\n            return {\n                value: calculateSlippage(trade.inputAmount.amount, maxSlippage).maximum,\n                methodArguments: removeUndefined([trade.outputAmount.amount, deadline, recipient])\n            };\n        }\n        case constants_1.TRADE_METHODS.tokenToEthSwapInput:\n        case constants_1.TRADE_METHODS.tokenToEthTransferInput: {\n            return {\n                value: constants_1._0,\n                methodArguments: removeUndefined([\n                    trade.inputAmount.amount,\n                    calculateSlippage(trade.outputAmount.amount, maxSlippage).minimum,\n                    deadline,\n                    recipient\n                ])\n            };\n        }\n        case constants_1.TRADE_METHODS.tokenToEthSwapOutput:\n        case constants_1.TRADE_METHODS.tokenToEthTransferOutput: {\n            return {\n                value: constants_1._0,\n                methodArguments: removeUndefined([\n                    trade.outputAmount.amount,\n                    calculateSlippage(trade.inputAmount.amount, maxSlippage).maximum,\n                    deadline,\n                    recipient\n                ])\n            };\n        }\n        case constants_1.TRADE_METHODS.tokenToTokenSwapInput:\n        case constants_1.TRADE_METHODS.tokenToTokenTransferInput: {\n            if (!trade.outputAmount.token.address) {\n                throw Error('trade does not include output token address.');\n            }\n            return {\n                value: constants_1._0,\n                methodArguments: removeUndefined([\n                    trade.inputAmount.amount,\n                    calculateSlippage(trade.outputAmount.amount, maxSlippage).minimum,\n                    constants_1._1,\n                    deadline,\n                    recipient,\n                    trade.outputAmount.token.address\n                ])\n            };\n        }\n        case constants_1.TRADE_METHODS.tokenToTokenSwapOutput:\n        case constants_1.TRADE_METHODS.tokenToTokenTransferOutput: {\n            if (!trade.outputAmount.token.address) {\n                throw Error('trade does not include output token address.');\n            }\n            return {\n                value: constants_1._0,\n                methodArguments: removeUndefined([\n                    trade.outputAmount.amount,\n                    calculateSlippage(trade.inputAmount.amount, maxSlippage).maximum,\n                    constants_1._MAX_UINT256,\n                    deadline,\n                    recipient,\n                    trade.outputAmount.token.address\n                ])\n            };\n        }\n        default: {\n            throw Error(\"methodName \" + methodName + \" is invalid.\");\n        }\n    }\n}\nfunction getExecutionDetails(trade, maxSlippage, deadline, recipient) {\n    var reserves = getReserves(trade);\n    if (!reserves.exchange || !reserves.exchange.address) {\n        throw Error('trade does not include exchange address.');\n    }\n    var methodName = getMethodName(trade, !!recipient);\n    var methodId = constants_1.TRADE_METHOD_IDS[methodName];\n    var _a = getValueAndMethodArguments(trade, methodName, maxSlippage || 200, deadline || Math.round(Date.now() / 1000 + 60 * 10), recipient && _utils_1.normalizeAddress(recipient)), value = _a.value, methodArguments = _a.methodArguments;\n    return {\n        exchangeAddress: reserves.exchange.address,\n        methodName: methodName,\n        methodId: methodId,\n        value: value,\n        methodArguments: methodArguments\n    };\n}\nexports.getExecutionDetails = getExecutionDetails;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}